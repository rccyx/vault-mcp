import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var argv = process.argv;
  var terminator = argv.indexOf("--");
  var hasFlag = function(flag) {
    flag = "--" + flag;
    var pos = argv.indexOf(flag);
    return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
  };
  module.exports = function() {
    if ("FORCE_COLOR" in process.env) {
      return true;
    }
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      return false;
    }
    if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      return true;
    }
    if (process.stdout && !process.stdout.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return true;
    }
    if ("COLORTERM" in process.env) {
      return true;
    }
    if (process.env.TERM === "dumb") {
      return false;
    }
    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
      return true;
    }
    return false;
  }();
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj2, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj2[prop] = val;
    return obj2;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/tv4/tv4.js
var require_tv4 = __commonJS((exports, module) => {
  (function(global2, factory) {
    if (typeof define === "function" && define.amd) {
      define([], factory);
    } else if (typeof module !== "undefined" && module.exports) {
      module.exports = factory();
    } else {
      global2.tv4 = factory();
    }
  })(exports, function() {
    if (!Object.keys) {
      Object.keys = function() {
        var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable("toString"), dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ], dontEnumsLength = dontEnums.length;
        return function(obj2) {
          if (typeof obj2 !== "object" && typeof obj2 !== "function" || obj2 === null) {
            throw new TypeError("Object.keys called on non-object");
          }
          var result = [];
          for (var prop in obj2) {
            if (hasOwnProperty.call(obj2, prop)) {
              result.push(prop);
            }
          }
          if (hasDontEnumBug) {
            for (var i = 0;i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj2, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }
          return result;
        };
      }();
    }
    if (!Object.create) {
      Object.create = function() {
        function F() {}
        return function(o) {
          if (arguments.length !== 1) {
            throw new Error("Object.create implementation only accepts one parameter.");
          }
          F.prototype = o;
          return new F;
        };
      }();
    }
    if (!Array.isArray) {
      Array.isArray = function(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
      };
    }
    if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function(searchElement) {
        if (this === null) {
          throw new TypeError;
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
          return -1;
        }
        var n = 0;
        if (arguments.length > 1) {
          n = Number(arguments[1]);
          if (n !== n) {
            n = 0;
          } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
          }
        }
        if (n >= len) {
          return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (;k < len; k++) {
          if (k in t && t[k] === searchElement) {
            return k;
          }
        }
        return -1;
      };
    }
    if (!Object.isFrozen) {
      Object.isFrozen = function(obj2) {
        var key2 = "tv4_test_frozen_key";
        while (obj2.hasOwnProperty(key2)) {
          key2 += Math.random();
        }
        try {
          obj2[key2] = true;
          delete obj2[key2];
          return false;
        } catch (e) {
          return true;
        }
      };
    }
    var uriTemplateGlobalModifiers = {
      "+": true,
      "#": true,
      ".": true,
      "/": true,
      ";": true,
      "?": true,
      "&": true
    };
    var uriTemplateSuffices = {
      "*": true
    };
    function notReallyPercentEncode(string) {
      return encodeURI(string).replace(/%25[0-9][0-9]/g, function(doubleEncoded) {
        return "%" + doubleEncoded.substring(3);
      });
    }
    function uriTemplateSubstitution(spec) {
      var modifier = "";
      if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
        modifier = spec.charAt(0);
        spec = spec.substring(1);
      }
      var separator = "";
      var prefix = "";
      var shouldEscape = true;
      var showVariables = false;
      var trimEmptyString = false;
      if (modifier === "+") {
        shouldEscape = false;
      } else if (modifier === ".") {
        prefix = ".";
        separator = ".";
      } else if (modifier === "/") {
        prefix = "/";
        separator = "/";
      } else if (modifier === "#") {
        prefix = "#";
        shouldEscape = false;
      } else if (modifier === ";") {
        prefix = ";";
        separator = ";";
        showVariables = true;
        trimEmptyString = true;
      } else if (modifier === "?") {
        prefix = "?";
        separator = "&";
        showVariables = true;
      } else if (modifier === "&") {
        prefix = "&";
        separator = "&";
        showVariables = true;
      }
      var varNames = [];
      var varList = spec.split(",");
      var varSpecs = [];
      var varSpecMap = {};
      for (var i = 0;i < varList.length; i++) {
        var varName = varList[i];
        var truncate = null;
        if (varName.indexOf(":") !== -1) {
          var parts = varName.split(":");
          varName = parts[0];
          truncate = parseInt(parts[1], 10);
        }
        var suffices = {};
        while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
          suffices[varName.charAt(varName.length - 1)] = true;
          varName = varName.substring(0, varName.length - 1);
        }
        var varSpec = {
          truncate,
          name: varName,
          suffices
        };
        varSpecs.push(varSpec);
        varSpecMap[varName] = varSpec;
        varNames.push(varName);
      }
      var subFunction = function(valueFunction) {
        var result = "";
        var startIndex = 0;
        for (var i2 = 0;i2 < varSpecs.length; i2++) {
          var varSpec2 = varSpecs[i2];
          var value = valueFunction(varSpec2.name);
          if (value === null || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === "object" && Object.keys(value).length === 0) {
            startIndex++;
            continue;
          }
          if (i2 === startIndex) {
            result += prefix;
          } else {
            result += separator || ",";
          }
          if (Array.isArray(value)) {
            if (showVariables) {
              result += varSpec2.name + "=";
            }
            for (var j = 0;j < value.length; j++) {
              if (j > 0) {
                result += varSpec2.suffices["*"] ? separator || "," : ",";
                if (varSpec2.suffices["*"] && showVariables) {
                  result += varSpec2.name + "=";
                }
              }
              result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
            }
          } else if (typeof value === "object") {
            if (showVariables && !varSpec2.suffices["*"]) {
              result += varSpec2.name + "=";
            }
            var first = true;
            for (var key2 in value) {
              if (!first) {
                result += varSpec2.suffices["*"] ? separator || "," : ",";
              }
              first = false;
              result += shouldEscape ? encodeURIComponent(key2).replace(/!/g, "%21") : notReallyPercentEncode(key2);
              result += varSpec2.suffices["*"] ? "=" : ",";
              result += shouldEscape ? encodeURIComponent(value[key2]).replace(/!/g, "%21") : notReallyPercentEncode(value[key2]);
            }
          } else {
            if (showVariables) {
              result += varSpec2.name;
              if (!trimEmptyString || value !== "") {
                result += "=";
              }
            }
            if (varSpec2.truncate != null) {
              value = value.substring(0, varSpec2.truncate);
            }
            result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21") : notReallyPercentEncode(value);
          }
        }
        return result;
      };
      subFunction.varNames = varNames;
      return {
        prefix,
        substitution: subFunction
      };
    }
    function UriTemplate(template) {
      if (!(this instanceof UriTemplate)) {
        return new UriTemplate(template);
      }
      var parts = template.split("{");
      var textParts = [parts.shift()];
      var prefixes = [];
      var substitutions = [];
      var varNames = [];
      while (parts.length > 0) {
        var part = parts.shift();
        var spec = part.split("}")[0];
        var remainder = part.substring(spec.length + 1);
        var funcs = uriTemplateSubstitution(spec);
        substitutions.push(funcs.substitution);
        prefixes.push(funcs.prefix);
        textParts.push(remainder);
        varNames = varNames.concat(funcs.substitution.varNames);
      }
      this.fill = function(valueFunction) {
        var result = textParts[0];
        for (var i = 0;i < substitutions.length; i++) {
          var substitution = substitutions[i];
          result += substitution(valueFunction);
          result += textParts[i + 1];
        }
        return result;
      };
      this.varNames = varNames;
      this.template = template;
    }
    UriTemplate.prototype = {
      toString: function() {
        return this.template;
      },
      fillFromObject: function(obj2) {
        return this.fill(function(varName) {
          return obj2[varName];
        });
      }
    };
    var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
      this.missing = [];
      this.missingMap = {};
      this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
      this.schemas = parent ? Object.create(parent.schemas) : {};
      this.collectMultiple = collectMultiple;
      this.errors = [];
      this.handleError = collectMultiple ? this.collectError : this.returnError;
      if (checkRecursive) {
        this.checkRecursive = true;
        this.scanned = [];
        this.scannedFrozen = [];
        this.scannedFrozenSchemas = [];
        this.scannedFrozenValidationErrors = [];
        this.validatedSchemasKey = "tv4_validation_id";
        this.validationErrorsKey = "tv4_validation_errors_id";
      }
      if (trackUnknownProperties) {
        this.trackUnknownProperties = true;
        this.knownPropertyPaths = {};
        this.unknownPropertyPaths = {};
      }
      this.errorReporter = errorReporter || defaultErrorReporter("en");
      if (typeof this.errorReporter === "string") {
        throw new Error("debug");
      }
      this.definedKeywords = {};
      if (parent) {
        for (var key2 in parent.definedKeywords) {
          this.definedKeywords[key2] = parent.definedKeywords[key2].slice(0);
        }
      }
    };
    ValidatorContext.prototype.defineKeyword = function(keyword, keywordFunction) {
      this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
      this.definedKeywords[keyword].push(keywordFunction);
    };
    ValidatorContext.prototype.createError = function(code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
      var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
      error.message = this.errorReporter(error, data, schema);
      return error;
    };
    ValidatorContext.prototype.returnError = function(error) {
      return error;
    };
    ValidatorContext.prototype.collectError = function(error) {
      if (error) {
        this.errors.push(error);
      }
      return null;
    };
    ValidatorContext.prototype.prefixErrors = function(startIndex, dataPath, schemaPath) {
      for (var i = startIndex;i < this.errors.length; i++) {
        this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
      }
      return this;
    };
    ValidatorContext.prototype.banUnknownProperties = function(data, schema) {
      for (var unknownPath in this.unknownPropertyPaths) {
        var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, { path: unknownPath }, unknownPath, "", null, data, schema);
        var result = this.handleError(error);
        if (result) {
          return result;
        }
      }
      return null;
    };
    ValidatorContext.prototype.addFormat = function(format, validator) {
      if (typeof format === "object") {
        for (var key2 in format) {
          this.addFormat(key2, format[key2]);
        }
        return this;
      }
      this.formatValidators[format] = validator;
    };
    ValidatorContext.prototype.resolveRefs = function(schema, urlHistory) {
      if (schema["$ref"] !== undefined) {
        urlHistory = urlHistory || {};
        if (urlHistory[schema["$ref"]]) {
          return this.createError(ErrorCodes.CIRCULAR_REFERENCE, { urls: Object.keys(urlHistory).join(", ") }, "", "", null, undefined, schema);
        }
        urlHistory[schema["$ref"]] = true;
        schema = this.getSchema(schema["$ref"], urlHistory);
      }
      return schema;
    };
    ValidatorContext.prototype.getSchema = function(url, urlHistory) {
      var schema;
      if (this.schemas[url] !== undefined) {
        schema = this.schemas[url];
        return this.resolveRefs(schema, urlHistory);
      }
      var baseUrl = url;
      var fragment = "";
      if (url.indexOf("#") !== -1) {
        fragment = url.substring(url.indexOf("#") + 1);
        baseUrl = url.substring(0, url.indexOf("#"));
      }
      if (typeof this.schemas[baseUrl] === "object") {
        schema = this.schemas[baseUrl];
        var pointerPath = decodeURIComponent(fragment);
        if (pointerPath === "") {
          return this.resolveRefs(schema, urlHistory);
        } else if (pointerPath.charAt(0) !== "/") {
          return;
        }
        var parts = pointerPath.split("/").slice(1);
        for (var i = 0;i < parts.length; i++) {
          var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
          if (schema[component] === undefined) {
            schema = undefined;
            break;
          }
          schema = schema[component];
        }
        if (schema !== undefined) {
          return this.resolveRefs(schema, urlHistory);
        }
      }
      if (this.missing[baseUrl] === undefined) {
        this.missing.push(baseUrl);
        this.missing[baseUrl] = baseUrl;
        this.missingMap[baseUrl] = baseUrl;
      }
    };
    ValidatorContext.prototype.searchSchemas = function(schema, url) {
      if (Array.isArray(schema)) {
        for (var i = 0;i < schema.length; i++) {
          this.searchSchemas(schema[i], url);
        }
      } else if (schema && typeof schema === "object") {
        if (typeof schema.id === "string") {
          if (isTrustedUrl(url, schema.id)) {
            if (this.schemas[schema.id] === undefined) {
              this.schemas[schema.id] = schema;
            }
          }
        }
        for (var key2 in schema) {
          if (key2 !== "enum") {
            if (typeof schema[key2] === "object") {
              this.searchSchemas(schema[key2], url);
            } else if (key2 === "$ref") {
              var uri = getDocumentUri(schema[key2]);
              if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
                this.missingMap[uri] = uri;
              }
            }
          }
        }
      }
    };
    ValidatorContext.prototype.addSchema = function(url, schema) {
      if (typeof url !== "string" || typeof schema === "undefined") {
        if (typeof url === "object" && typeof url.id === "string") {
          schema = url;
          url = schema.id;
        } else {
          return;
        }
      }
      if (url === getDocumentUri(url) + "#") {
        url = getDocumentUri(url);
      }
      this.schemas[url] = schema;
      delete this.missingMap[url];
      normSchema(schema, url);
      this.searchSchemas(schema, url);
    };
    ValidatorContext.prototype.getSchemaMap = function() {
      var map = {};
      for (var key2 in this.schemas) {
        map[key2] = this.schemas[key2];
      }
      return map;
    };
    ValidatorContext.prototype.getSchemaUris = function(filterRegExp) {
      var list = [];
      for (var key2 in this.schemas) {
        if (!filterRegExp || filterRegExp.test(key2)) {
          list.push(key2);
        }
      }
      return list;
    };
    ValidatorContext.prototype.getMissingUris = function(filterRegExp) {
      var list = [];
      for (var key2 in this.missingMap) {
        if (!filterRegExp || filterRegExp.test(key2)) {
          list.push(key2);
        }
      }
      return list;
    };
    ValidatorContext.prototype.dropSchemas = function() {
      this.schemas = {};
      this.reset();
    };
    ValidatorContext.prototype.reset = function() {
      this.missing = [];
      this.missingMap = {};
      this.errors = [];
    };
    ValidatorContext.prototype.validateAll = function(data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
      var topLevel;
      schema = this.resolveRefs(schema);
      if (!schema) {
        return null;
      } else if (schema instanceof ValidationError) {
        this.errors.push(schema);
        return schema;
      }
      var startErrorCount = this.errors.length;
      var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
      if (this.checkRecursive && data && typeof data === "object") {
        topLevel = !this.scanned.length;
        if (data[this.validatedSchemasKey]) {
          var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
          if (schemaIndex !== -1) {
            this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
            return null;
          }
        }
        if (Object.isFrozen(data)) {
          frozenIndex = this.scannedFrozen.indexOf(data);
          if (frozenIndex !== -1) {
            var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
            if (frozenSchemaIndex !== -1) {
              this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
              return null;
            }
          }
        }
        this.scanned.push(data);
        if (Object.isFrozen(data)) {
          if (frozenIndex === -1) {
            frozenIndex = this.scannedFrozen.length;
            this.scannedFrozen.push(data);
            this.scannedFrozenSchemas.push([]);
          }
          scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
          this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
          this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
        } else {
          if (!data[this.validatedSchemasKey]) {
            try {
              Object.defineProperty(data, this.validatedSchemasKey, {
                value: [],
                configurable: true
              });
              Object.defineProperty(data, this.validationErrorsKey, {
                value: [],
                configurable: true
              });
            } catch (e) {
              data[this.validatedSchemasKey] = [];
              data[this.validationErrorsKey] = [];
            }
          }
          scannedSchemasIndex = data[this.validatedSchemasKey].length;
          data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
          data[this.validationErrorsKey][scannedSchemasIndex] = [];
        }
      }
      var errorCount = this.errors.length;
      var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;
      if (topLevel) {
        while (this.scanned.length) {
          var item = this.scanned.pop();
          delete item[this.validatedSchemasKey];
        }
        this.scannedFrozen = [];
        this.scannedFrozenSchemas = [];
      }
      if (error || errorCount !== this.errors.length) {
        while (dataPathParts && dataPathParts.length || schemaPathParts && schemaPathParts.length) {
          var dataPart = dataPathParts && dataPathParts.length ? "" + dataPathParts.pop() : null;
          var schemaPart = schemaPathParts && schemaPathParts.length ? "" + schemaPathParts.pop() : null;
          if (error) {
            error = error.prefixWith(dataPart, schemaPart);
          }
          this.prefixErrors(errorCount, dataPart, schemaPart);
        }
      }
      if (scannedFrozenSchemaIndex !== null) {
        this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
      } else if (scannedSchemasIndex !== null) {
        data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
      }
      return this.handleError(error);
    };
    ValidatorContext.prototype.validateFormat = function(data, schema) {
      if (typeof schema.format !== "string" || !this.formatValidators[schema.format]) {
        return null;
      }
      var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
      if (typeof errorMessage === "string" || typeof errorMessage === "number") {
        return this.createError(ErrorCodes.FORMAT_CUSTOM, { message: errorMessage }, "", "/format", null, data, schema);
      } else if (errorMessage && typeof errorMessage === "object") {
        return this.createError(ErrorCodes.FORMAT_CUSTOM, { message: errorMessage.message || "?" }, errorMessage.dataPath || "", errorMessage.schemaPath || "/format", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateDefinedKeywords = function(data, schema, dataPointerPath) {
      for (var key2 in this.definedKeywords) {
        if (typeof schema[key2] === "undefined") {
          continue;
        }
        var validationFunctions = this.definedKeywords[key2];
        for (var i = 0;i < validationFunctions.length; i++) {
          var func = validationFunctions[i];
          var result = func(data, schema[key2], schema, dataPointerPath);
          if (typeof result === "string" || typeof result === "number") {
            return this.createError(ErrorCodes.KEYWORD_CUSTOM, { key: key2, message: result }, "", "", null, data, schema).prefixWith(null, key2);
          } else if (result && typeof result === "object") {
            var code = result.code;
            if (typeof code === "string") {
              if (!ErrorCodes[code]) {
                throw new Error("Undefined error code (use defineError): " + code);
              }
              code = ErrorCodes[code];
            } else if (typeof code !== "number") {
              code = ErrorCodes.KEYWORD_CUSTOM;
            }
            var messageParams = typeof result.message === "object" ? result.message : { key: key2, message: result.message || "?" };
            var schemaPath = result.schemaPath || "/" + key2.replace(/~/g, "~0").replace(/\//g, "~1");
            return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
          }
        }
      }
      return null;
    };
    function recursiveCompare(A, B) {
      if (A === B) {
        return true;
      }
      if (A && B && typeof A === "object" && typeof B === "object") {
        if (Array.isArray(A) !== Array.isArray(B)) {
          return false;
        } else if (Array.isArray(A)) {
          if (A.length !== B.length) {
            return false;
          }
          for (var i = 0;i < A.length; i++) {
            if (!recursiveCompare(A[i], B[i])) {
              return false;
            }
          }
        } else {
          var key2;
          for (key2 in A) {
            if (B[key2] === undefined && A[key2] !== undefined) {
              return false;
            }
          }
          for (key2 in B) {
            if (A[key2] === undefined && B[key2] !== undefined) {
              return false;
            }
          }
          for (key2 in A) {
            if (!recursiveCompare(A[key2], B[key2])) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    }
    ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
      var error;
      if (error = this.validateType(data, schema, dataPointerPath)) {
        return error.prefixWith(null, "type");
      }
      if (error = this.validateEnum(data, schema, dataPointerPath)) {
        return error.prefixWith(null, "type");
      }
      return null;
    };
    ValidatorContext.prototype.validateType = function validateType(data, schema) {
      if (schema.type === undefined) {
        return null;
      }
      var dataType = typeof data;
      if (data === null) {
        dataType = "null";
      } else if (Array.isArray(data)) {
        dataType = "array";
      }
      var allowedTypes = schema.type;
      if (!Array.isArray(allowedTypes)) {
        allowedTypes = [allowedTypes];
      }
      for (var i = 0;i < allowedTypes.length; i++) {
        var type = allowedTypes[i];
        if (type === dataType || type === "integer" && dataType === "number" && data % 1 === 0) {
          return null;
        }
      }
      return this.createError(ErrorCodes.INVALID_TYPE, { type: dataType, expected: allowedTypes.join("/") }, "", "", null, data, schema);
    };
    ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
      if (schema["enum"] === undefined) {
        return null;
      }
      for (var i = 0;i < schema["enum"].length; i++) {
        var enumVal = schema["enum"][i];
        if (recursiveCompare(data, enumVal)) {
          return null;
        }
      }
      return this.createError(ErrorCodes.ENUM_MISMATCH, { value: typeof JSON !== "undefined" ? JSON.stringify(data) : data }, "", "", null, data, schema);
    };
    ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
      return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;
    };
    var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
    var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
    ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
      var multipleOf = schema.multipleOf || schema.divisibleBy;
      if (multipleOf === undefined) {
        return null;
      }
      if (typeof data === "number") {
        var remainder = data / multipleOf % 1;
        if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
          return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, { value: data, multipleOf }, "", "", null, data, schema);
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
      if (typeof data !== "number") {
        return null;
      }
      if (schema.minimum !== undefined) {
        if (data < schema.minimum) {
          return this.createError(ErrorCodes.NUMBER_MINIMUM, { value: data, minimum: schema.minimum }, "", "/minimum", null, data, schema);
        }
        if (schema.exclusiveMinimum && data === schema.minimum) {
          return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, { value: data, minimum: schema.minimum }, "", "/exclusiveMinimum", null, data, schema);
        }
      }
      if (schema.maximum !== undefined) {
        if (data > schema.maximum) {
          return this.createError(ErrorCodes.NUMBER_MAXIMUM, { value: data, maximum: schema.maximum }, "", "/maximum", null, data, schema);
        }
        if (schema.exclusiveMaximum && data === schema.maximum) {
          return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, { value: data, maximum: schema.maximum }, "", "/exclusiveMaximum", null, data, schema);
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
      if (typeof data !== "number") {
        return null;
      }
      if (isNaN(data) === true || data === Infinity || data === -Infinity) {
        return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, { value: data }, "", "/type", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
      return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
      if (typeof data !== "string") {
        return null;
      }
      if (schema.minLength !== undefined) {
        if (data.length < schema.minLength) {
          return this.createError(ErrorCodes.STRING_LENGTH_SHORT, { length: data.length, minimum: schema.minLength }, "", "/minLength", null, data, schema);
        }
      }
      if (schema.maxLength !== undefined) {
        if (data.length > schema.maxLength) {
          return this.createError(ErrorCodes.STRING_LENGTH_LONG, { length: data.length, maximum: schema.maxLength }, "", "/maxLength", null, data, schema);
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
      if (typeof data !== "string" || typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp)) {
        return null;
      }
      var regexp;
      if (schema.pattern instanceof RegExp) {
        regexp = schema.pattern;
      } else {
        var body, flags = "";
        var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
        if (literal) {
          body = literal[1];
          flags = literal[2];
        } else {
          body = schema.pattern;
        }
        regexp = new RegExp(body, flags);
      }
      if (!regexp.test(data)) {
        return this.createError(ErrorCodes.STRING_PATTERN, { pattern: schema.pattern }, "", "/pattern", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
      if (!Array.isArray(data)) {
        return null;
      }
      return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
      var error;
      if (schema.minItems !== undefined) {
        if (data.length < schema.minItems) {
          error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, { length: data.length, minimum: schema.minItems }, "", "/minItems", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      if (schema.maxItems !== undefined) {
        if (data.length > schema.maxItems) {
          error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, { length: data.length, maximum: schema.maxItems }, "", "/maxItems", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
      if (schema.uniqueItems) {
        for (var i = 0;i < data.length; i++) {
          for (var j = i + 1;j < data.length; j++) {
            if (recursiveCompare(data[i], data[j])) {
              var error = this.createError(ErrorCodes.ARRAY_UNIQUE, { match1: i, match2: j }, "", "/uniqueItems", null, data, schema);
              if (this.handleError(error)) {
                return error;
              }
            }
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
      if (schema.items === undefined) {
        return null;
      }
      var error, i;
      if (Array.isArray(schema.items)) {
        for (i = 0;i < data.length; i++) {
          if (i < schema.items.length) {
            if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
              return error;
            }
          } else if (schema.additionalItems !== undefined) {
            if (typeof schema.additionalItems === "boolean") {
              if (!schema.additionalItems) {
                error = this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, "/" + i, "/additionalItems", null, data, schema);
                if (this.handleError(error)) {
                  return error;
                }
              }
            } else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
              return error;
            }
          }
        }
      } else {
        for (i = 0;i < data.length; i++) {
          if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
            return error;
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
      if (typeof data !== "object" || data === null || Array.isArray(data)) {
        return null;
      }
      return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
      var keys = Object.keys(data);
      var error;
      if (schema.minProperties !== undefined) {
        if (keys.length < schema.minProperties) {
          error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, { propertyCount: keys.length, minimum: schema.minProperties }, "", "/minProperties", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      if (schema.maxProperties !== undefined) {
        if (keys.length > schema.maxProperties) {
          error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, { propertyCount: keys.length, maximum: schema.maxProperties }, "", "/maxProperties", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
      if (schema.required !== undefined) {
        for (var i = 0;i < schema.required.length; i++) {
          var key2 = schema.required[i];
          if (data[key2] === undefined) {
            var error = this.createError(ErrorCodes.OBJECT_REQUIRED, { key: key2 }, "", "/required/" + i, null, data, schema);
            if (this.handleError(error)) {
              return error;
            }
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
      var error;
      for (var key2 in data) {
        var keyPointerPath = dataPointerPath + "/" + key2.replace(/~/g, "~0").replace(/\//g, "~1");
        var foundMatch = false;
        if (schema.properties !== undefined && schema.properties[key2] !== undefined) {
          foundMatch = true;
          if (error = this.validateAll(data[key2], schema.properties[key2], [key2], ["properties", key2], keyPointerPath)) {
            return error;
          }
        }
        if (schema.patternProperties !== undefined) {
          for (var patternKey in schema.patternProperties) {
            var regexp = new RegExp(patternKey);
            if (regexp.test(key2)) {
              foundMatch = true;
              if (error = this.validateAll(data[key2], schema.patternProperties[patternKey], [key2], ["patternProperties", patternKey], keyPointerPath)) {
                return error;
              }
            }
          }
        }
        if (!foundMatch) {
          if (schema.additionalProperties !== undefined) {
            if (this.trackUnknownProperties) {
              this.knownPropertyPaths[keyPointerPath] = true;
              delete this.unknownPropertyPaths[keyPointerPath];
            }
            if (typeof schema.additionalProperties === "boolean") {
              if (!schema.additionalProperties) {
                error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, { key: key2 }, "", "/additionalProperties", null, data, schema).prefixWith(key2, null);
                if (this.handleError(error)) {
                  return error;
                }
              }
            } else {
              if (error = this.validateAll(data[key2], schema.additionalProperties, [key2], ["additionalProperties"], keyPointerPath)) {
                return error;
              }
            }
          } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
            this.unknownPropertyPaths[keyPointerPath] = true;
          }
        } else if (this.trackUnknownProperties) {
          this.knownPropertyPaths[keyPointerPath] = true;
          delete this.unknownPropertyPaths[keyPointerPath];
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
      var error;
      if (schema.dependencies !== undefined) {
        for (var depKey in schema.dependencies) {
          if (data[depKey] !== undefined) {
            var dep = schema.dependencies[depKey];
            if (typeof dep === "string") {
              if (data[dep] === undefined) {
                error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, { key: depKey, missing: dep }, "", "", null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
                if (this.handleError(error)) {
                  return error;
                }
              }
            } else if (Array.isArray(dep)) {
              for (var i = 0;i < dep.length; i++) {
                var requiredKey = dep[i];
                if (data[requiredKey] === undefined) {
                  error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, { key: depKey, missing: requiredKey }, "", "/" + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              }
            } else {
              if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
                return error;
              }
            }
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
      return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
      if (schema.allOf === undefined) {
        return null;
      }
      var error;
      for (var i = 0;i < schema.allOf.length; i++) {
        var subSchema = schema.allOf[i];
        if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
          return error;
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
      if (schema.anyOf === undefined) {
        return null;
      }
      var errors = [];
      var startErrorCount = this.errors.length;
      var oldUnknownPropertyPaths, oldKnownPropertyPaths;
      if (this.trackUnknownProperties) {
        oldUnknownPropertyPaths = this.unknownPropertyPaths;
        oldKnownPropertyPaths = this.knownPropertyPaths;
      }
      var errorAtEnd = true;
      for (var i = 0;i < schema.anyOf.length; i++) {
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = {};
          this.knownPropertyPaths = {};
        }
        var subSchema = schema.anyOf[i];
        var errorCount = this.errors.length;
        var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);
        if (error === null && errorCount === this.errors.length) {
          this.errors = this.errors.slice(0, startErrorCount);
          if (this.trackUnknownProperties) {
            for (var knownKey in this.knownPropertyPaths) {
              oldKnownPropertyPaths[knownKey] = true;
              delete oldUnknownPropertyPaths[knownKey];
            }
            for (var unknownKey in this.unknownPropertyPaths) {
              if (!oldKnownPropertyPaths[unknownKey]) {
                oldUnknownPropertyPaths[unknownKey] = true;
              }
            }
            errorAtEnd = false;
            continue;
          }
          return null;
        }
        if (error) {
          errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
        }
      }
      if (this.trackUnknownProperties) {
        this.unknownPropertyPaths = oldUnknownPropertyPaths;
        this.knownPropertyPaths = oldKnownPropertyPaths;
      }
      if (errorAtEnd) {
        errors = errors.concat(this.errors.slice(startErrorCount));
        this.errors = this.errors.slice(0, startErrorCount);
        return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
      }
    };
    ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
      if (schema.oneOf === undefined) {
        return null;
      }
      var validIndex = null;
      var errors = [];
      var startErrorCount = this.errors.length;
      var oldUnknownPropertyPaths, oldKnownPropertyPaths;
      if (this.trackUnknownProperties) {
        oldUnknownPropertyPaths = this.unknownPropertyPaths;
        oldKnownPropertyPaths = this.knownPropertyPaths;
      }
      for (var i = 0;i < schema.oneOf.length; i++) {
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = {};
          this.knownPropertyPaths = {};
        }
        var subSchema = schema.oneOf[i];
        var errorCount = this.errors.length;
        var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);
        if (error === null && errorCount === this.errors.length) {
          if (validIndex === null) {
            validIndex = i;
          } else {
            this.errors = this.errors.slice(0, startErrorCount);
            return this.createError(ErrorCodes.ONE_OF_MULTIPLE, { index1: validIndex, index2: i }, "", "/oneOf", null, data, schema);
          }
          if (this.trackUnknownProperties) {
            for (var knownKey in this.knownPropertyPaths) {
              oldKnownPropertyPaths[knownKey] = true;
              delete oldUnknownPropertyPaths[knownKey];
            }
            for (var unknownKey in this.unknownPropertyPaths) {
              if (!oldKnownPropertyPaths[unknownKey]) {
                oldUnknownPropertyPaths[unknownKey] = true;
              }
            }
          }
        } else if (error) {
          errors.push(error);
        }
      }
      if (this.trackUnknownProperties) {
        this.unknownPropertyPaths = oldUnknownPropertyPaths;
        this.knownPropertyPaths = oldKnownPropertyPaths;
      }
      if (validIndex === null) {
        errors = errors.concat(this.errors.slice(startErrorCount));
        this.errors = this.errors.slice(0, startErrorCount);
        return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
      } else {
        this.errors = this.errors.slice(0, startErrorCount);
      }
      return null;
    };
    ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
      if (schema.not === undefined) {
        return null;
      }
      var oldErrorCount = this.errors.length;
      var oldUnknownPropertyPaths, oldKnownPropertyPaths;
      if (this.trackUnknownProperties) {
        oldUnknownPropertyPaths = this.unknownPropertyPaths;
        oldKnownPropertyPaths = this.knownPropertyPaths;
        this.unknownPropertyPaths = {};
        this.knownPropertyPaths = {};
      }
      var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
      var notErrors = this.errors.slice(oldErrorCount);
      this.errors = this.errors.slice(0, oldErrorCount);
      if (this.trackUnknownProperties) {
        this.unknownPropertyPaths = oldUnknownPropertyPaths;
        this.knownPropertyPaths = oldKnownPropertyPaths;
      }
      if (error === null && notErrors.length === 0) {
        return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
      if (!schema.links) {
        return null;
      }
      var error;
      for (var i = 0;i < schema.links.length; i++) {
        var ldo = schema.links[i];
        if (ldo.rel === "describedby") {
          var template = new UriTemplate(ldo.href);
          var allPresent = true;
          for (var j = 0;j < template.varNames.length; j++) {
            if (!(template.varNames[j] in data)) {
              allPresent = false;
              break;
            }
          }
          if (allPresent) {
            var schemaUrl = template.fillFromObject(data);
            var subSchema = { $ref: schemaUrl };
            if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
              return error;
            }
          }
        }
      }
    };
    function parseURI(url) {
      var m = String(url).replace(/^\s+|\s+$/g, "").match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
      return m ? {
        href: m[0] || "",
        protocol: m[1] || "",
        authority: m[2] || "",
        host: m[3] || "",
        hostname: m[4] || "",
        port: m[5] || "",
        pathname: m[6] || "",
        search: m[7] || "",
        hash: m[8] || ""
      } : null;
    }
    function resolveUrl(base, href) {
      function removeDotSegments(input) {
        var output = [];
        input.replace(/^(\.\.?(\/|$))+/, "").replace(/\/(\.(\/|$))+/g, "/").replace(/\/\.\.$/, "/../").replace(/\/?[^\/]*/g, function(p) {
          if (p === "/..") {
            output.pop();
          } else {
            output.push(p);
          }
        });
        return output.join("").replace(/^\//, input.charAt(0) === "/" ? "/" : "");
      }
      href = parseURI(href || "");
      base = parseURI(base || "");
      return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === "/" ? href.pathname : href.pathname ? (base.authority && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    }
    function getDocumentUri(uri) {
      return uri.split("#")[0];
    }
    function normSchema(schema, baseUri) {
      if (schema && typeof schema === "object") {
        if (baseUri === undefined) {
          baseUri = schema.id;
        } else if (typeof schema.id === "string") {
          baseUri = resolveUrl(baseUri, schema.id);
          schema.id = baseUri;
        }
        if (Array.isArray(schema)) {
          for (var i = 0;i < schema.length; i++) {
            normSchema(schema[i], baseUri);
          }
        } else {
          if (typeof schema["$ref"] === "string") {
            schema["$ref"] = resolveUrl(baseUri, schema["$ref"]);
          }
          for (var key2 in schema) {
            if (key2 !== "enum") {
              normSchema(schema[key2], baseUri);
            }
          }
        }
      }
    }
    function defaultErrorReporter(language) {
      language = language || "en";
      var errorMessages = languages[language];
      return function(error) {
        var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
        if (typeof messageTemplate !== "string") {
          return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
        }
        var messageParams = error.params;
        return messageTemplate.replace(/\{([^{}]*)\}/g, function(whole, varName) {
          var subValue = messageParams[varName];
          return typeof subValue === "string" || typeof subValue === "number" ? subValue : whole;
        });
      };
    }
    var ErrorCodes = {
      INVALID_TYPE: 0,
      ENUM_MISMATCH: 1,
      ANY_OF_MISSING: 10,
      ONE_OF_MISSING: 11,
      ONE_OF_MULTIPLE: 12,
      NOT_PASSED: 13,
      NUMBER_MULTIPLE_OF: 100,
      NUMBER_MINIMUM: 101,
      NUMBER_MINIMUM_EXCLUSIVE: 102,
      NUMBER_MAXIMUM: 103,
      NUMBER_MAXIMUM_EXCLUSIVE: 104,
      NUMBER_NOT_A_NUMBER: 105,
      STRING_LENGTH_SHORT: 200,
      STRING_LENGTH_LONG: 201,
      STRING_PATTERN: 202,
      OBJECT_PROPERTIES_MINIMUM: 300,
      OBJECT_PROPERTIES_MAXIMUM: 301,
      OBJECT_REQUIRED: 302,
      OBJECT_ADDITIONAL_PROPERTIES: 303,
      OBJECT_DEPENDENCY_KEY: 304,
      ARRAY_LENGTH_SHORT: 400,
      ARRAY_LENGTH_LONG: 401,
      ARRAY_UNIQUE: 402,
      ARRAY_ADDITIONAL_ITEMS: 403,
      FORMAT_CUSTOM: 500,
      KEYWORD_CUSTOM: 501,
      CIRCULAR_REFERENCE: 600,
      UNKNOWN_PROPERTY: 1000
    };
    var ErrorCodeLookup = {};
    for (var key in ErrorCodes) {
      ErrorCodeLookup[ErrorCodes[key]] = key;
    }
    var ErrorMessagesDefault = {
      INVALID_TYPE: "Invalid type: {type} (expected {expected})",
      ENUM_MISMATCH: "No enum match for: {value}",
      ANY_OF_MISSING: 'Data does not match any schemas from "anyOf"',
      ONE_OF_MISSING: 'Data does not match any schemas from "oneOf"',
      ONE_OF_MULTIPLE: 'Data is valid against more than one schema from "oneOf": indices {index1} and {index2}',
      NOT_PASSED: 'Data matches schema from "not"',
      NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
      NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
      NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
      NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
      NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
      NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
      STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
      STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
      STRING_PATTERN: "String does not match pattern: {pattern}",
      OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
      OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
      OBJECT_REQUIRED: "Missing required property: {key}",
      OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
      OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
      ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
      ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
      ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
      ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
      FORMAT_CUSTOM: "Format validation failed ({message})",
      KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
      CIRCULAR_REFERENCE: "Circular $refs: {urls}",
      UNKNOWN_PROPERTY: "Unknown property (not in schema)"
    };
    function ValidationError(code, params, dataPath, schemaPath, subErrors) {
      Error.call(this);
      if (code === undefined) {
        throw new Error("No error code supplied: " + schemaPath);
      }
      this.message = "";
      this.params = params;
      this.code = code;
      this.dataPath = dataPath || "";
      this.schemaPath = schemaPath || "";
      this.subErrors = subErrors || null;
      var err = new Error(this.message);
      this.stack = err.stack || err.stacktrace;
      if (!this.stack) {
        try {
          throw err;
        } catch (err2) {
          this.stack = err2.stack || err2.stacktrace;
        }
      }
    }
    ValidationError.prototype = Object.create(Error.prototype);
    ValidationError.prototype.constructor = ValidationError;
    ValidationError.prototype.name = "ValidationError";
    ValidationError.prototype.prefixWith = function(dataPrefix, schemaPrefix) {
      if (dataPrefix !== null) {
        dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
        this.dataPath = "/" + dataPrefix + this.dataPath;
      }
      if (schemaPrefix !== null) {
        schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
        this.schemaPath = "/" + schemaPrefix + this.schemaPath;
      }
      if (this.subErrors !== null) {
        for (var i = 0;i < this.subErrors.length; i++) {
          this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
        }
      }
      return this;
    };
    function isTrustedUrl(baseUrl, testUrl) {
      if (testUrl.substring(0, baseUrl.length) === baseUrl) {
        var remainder = testUrl.substring(baseUrl.length);
        if (testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/" || remainder.charAt(0) === "#" || remainder.charAt(0) === "?") {
          return true;
        }
      }
      return false;
    }
    var languages = {};
    function createApi(language) {
      var globalContext = new ValidatorContext;
      var currentLanguage;
      var customErrorReporter;
      var api = {
        setErrorReporter: function(reporter) {
          if (typeof reporter === "string") {
            return this.language(reporter);
          }
          customErrorReporter = reporter;
          return true;
        },
        addFormat: function() {
          globalContext.addFormat.apply(globalContext, arguments);
        },
        language: function(code) {
          if (!code) {
            return currentLanguage;
          }
          if (!languages[code]) {
            code = code.split("-")[0];
          }
          if (languages[code]) {
            currentLanguage = code;
            return code;
          }
          return false;
        },
        addLanguage: function(code, messageMap) {
          var key2;
          for (key2 in ErrorCodes) {
            if (messageMap[key2] && !messageMap[ErrorCodes[key2]]) {
              messageMap[ErrorCodes[key2]] = messageMap[key2];
            }
          }
          var rootCode = code.split("-")[0];
          if (!languages[rootCode]) {
            languages[code] = messageMap;
            languages[rootCode] = messageMap;
          } else {
            languages[code] = Object.create(languages[rootCode]);
            for (key2 in messageMap) {
              if (typeof languages[rootCode][key2] === "undefined") {
                languages[rootCode][key2] = messageMap[key2];
              }
              languages[code][key2] = messageMap[key2];
            }
          }
          return this;
        },
        freshApi: function(language2) {
          var result = createApi();
          if (language2) {
            result.language(language2);
          }
          return result;
        },
        validate: function(data, schema, checkRecursive, banUnknownProperties) {
          var def = defaultErrorReporter(currentLanguage);
          var errorReporter = customErrorReporter ? function(error2, data2, schema2) {
            return customErrorReporter(error2, data2, schema2) || def(error2, data2, schema2);
          } : def;
          var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
          if (typeof schema === "string") {
            schema = { $ref: schema };
          }
          context.addSchema("", schema);
          var error = context.validateAll(data, schema, null, null, "");
          if (!error && banUnknownProperties) {
            error = context.banUnknownProperties(data, schema);
          }
          this.error = error;
          this.missing = context.missing;
          this.valid = error === null;
          return this.valid;
        },
        validateResult: function() {
          var result = { toString: function() {
            return this.valid ? "valid" : this.error.message;
          } };
          this.validate.apply(result, arguments);
          return result;
        },
        validateMultiple: function(data, schema, checkRecursive, banUnknownProperties) {
          var def = defaultErrorReporter(currentLanguage);
          var errorReporter = customErrorReporter ? function(error, data2, schema2) {
            return customErrorReporter(error, data2, schema2) || def(error, data2, schema2);
          } : def;
          var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
          if (typeof schema === "string") {
            schema = { $ref: schema };
          }
          context.addSchema("", schema);
          context.validateAll(data, schema, null, null, "");
          if (banUnknownProperties) {
            context.banUnknownProperties(data, schema);
          }
          var result = { toString: function() {
            return this.valid ? "valid" : this.error.message;
          } };
          result.errors = context.errors;
          result.missing = context.missing;
          result.valid = result.errors.length === 0;
          return result;
        },
        addSchema: function() {
          return globalContext.addSchema.apply(globalContext, arguments);
        },
        getSchema: function() {
          return globalContext.getSchema.apply(globalContext, arguments);
        },
        getSchemaMap: function() {
          return globalContext.getSchemaMap.apply(globalContext, arguments);
        },
        getSchemaUris: function() {
          return globalContext.getSchemaUris.apply(globalContext, arguments);
        },
        getMissingUris: function() {
          return globalContext.getMissingUris.apply(globalContext, arguments);
        },
        dropSchemas: function() {
          globalContext.dropSchemas.apply(globalContext, arguments);
        },
        defineKeyword: function() {
          globalContext.defineKeyword.apply(globalContext, arguments);
        },
        defineError: function(codeName, codeNumber, defaultMessage) {
          if (typeof codeName !== "string" || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
            throw new Error("Code name must be a string in UPPER_CASE_WITH_UNDERSCORES");
          }
          if (typeof codeNumber !== "number" || codeNumber % 1 !== 0 || codeNumber < 1e4) {
            throw new Error("Code number must be an integer > 10000");
          }
          if (typeof ErrorCodes[codeName] !== "undefined") {
            throw new Error("Error already defined: " + codeName + " as " + ErrorCodes[codeName]);
          }
          if (typeof ErrorCodeLookup[codeNumber] !== "undefined") {
            throw new Error("Error code already used: " + ErrorCodeLookup[codeNumber] + " as " + codeNumber);
          }
          ErrorCodes[codeName] = codeNumber;
          ErrorCodeLookup[codeNumber] = codeName;
          ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
          for (var langCode in languages) {
            var language2 = languages[langCode];
            if (language2[codeName]) {
              language2[codeNumber] = language2[codeNumber] || language2[codeName];
            }
          }
        },
        reset: function() {
          globalContext.reset();
          this.error = null;
          this.missing = [];
          this.valid = true;
        },
        missing: [],
        error: null,
        valid: true,
        normSchema,
        resolveUrl,
        getDocumentUri,
        errorCodes: ErrorCodes
      };
      api.language(language || "en");
      return api;
    }
    var tv4 = createApi();
    tv4.addLanguage("en-gb", ErrorMessagesDefault);
    tv4.tv4 = tv4;
    return tv4;
  });
});

// node_modules/node-vault/src/commands.js
var require_commands = __commonJS((exports, module) => {
  var sealStatusResponse = {
    type: "object",
    properties: {
      sealed: {
        type: "boolean"
      },
      t: {
        type: "integer"
      },
      n: {
        type: "integer"
      },
      progress: {
        type: "integer"
      }
    },
    required: ["sealed", "t", "n", "progress"]
  };
  var auth = {
    type: "object",
    properties: {
      client_token: {
        type: "string"
      },
      policies: {
        type: "array",
        items: {
          type: "string"
        }
      },
      metadata: {
        type: "object"
      },
      lease_duration: {
        type: "integer"
      },
      renewable: {
        type: "boolean"
      }
    }
  };
  var tokenResponse = {
    type: "object",
    properties: {
      auth
    },
    required: ["auth"]
  };
  var kubernetesRoleResponse = {
    type: "object",
    properties: {
      auth,
      name: {
        type: "string"
      },
      bound_cidrs: {
        type: "array"
      },
      bound_service_account_names: {
        type: "array"
      },
      bound_service_account_namespaces: {
        type: "array"
      },
      ttl: {
        type: "integer"
      },
      max_ttl: {
        type: "integer"
      },
      policies: {
        type: "array"
      },
      num_uses: {
        type: "integer"
      },
      period: {
        type: "integer"
      }
    }
  };
  var approleResponse = {
    type: "object",
    properties: {
      auth,
      warnings: {
        type: "string"
      },
      wrap_info: {
        type: "string"
      },
      data: {
        type: "object"
      },
      lease_duration: {
        type: "integer"
      },
      renewable: {
        type: "boolean"
      },
      lease_id: {
        type: "string"
      }
    }
  };
  module.exports = {
    status: {
      method: "GET",
      path: "/sys/seal-status",
      schema: {
        res: sealStatusResponse
      }
    },
    initialized: {
      method: "GET",
      path: "/sys/init"
    },
    init: {
      method: "PUT",
      path: "/sys/init",
      schema: {
        req: {
          type: "object",
          properties: {
            secret_shares: {
              type: "integer",
              minimum: 1
            },
            secret_threshold: {
              type: "integer",
              minimum: 1
            },
            pgp_keys: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            }
          },
          required: ["secret_shares", "secret_threshold"]
        },
        res: {
          type: "object",
          properties: {
            keys: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            },
            root_token: {
              type: "string"
            }
          },
          required: ["keys", "root_token"]
        }
      }
    },
    unseal: {
      method: "PUT",
      path: "/sys/unseal",
      schema: {
        req: {
          type: "object",
          properties: {
            key: {
              type: "string"
            },
            reset: {
              type: "boolean"
            },
            migrate: {
              type: "boolean"
            }
          }
        },
        res: sealStatusResponse
      }
    },
    seal: {
      method: "PUT",
      path: "/sys/seal"
    },
    getTokenRole: {
      method: "GET",
      path: "/auth/token/roles/{{role_name}}"
    },
    removeTokenRole: {
      method: "DELETE",
      path: "/auth/token/roles/{{role_name}}"
    },
    approleRoles: {
      method: "LIST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/role",
      schema: {
        res: approleResponse
      }
    },
    addKubernetesRole: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}kubernetes{{/mount_point}}/role/{{ role_name }}",
      schema: {
        req: {
          name: {
            type: "string"
          },
          bound_cidrs: {
            type: "array"
          },
          bound_service_account_names: {
            type: "array"
          },
          bound_service_account_namespaces: {
            type: "array"
          },
          ttl: {
            type: "integer"
          },
          max_ttl: {
            type: "integer"
          },
          policies: {
            type: "array"
          },
          num_uses: {
            type: "integer"
          },
          period: {
            type: "integer"
          }
        }
      }
    },
    getKubernetesRole: {
      method: "GET",
      path: "/auth/{{mount_point}}{{^mount_point}}kubernetes{{/mount_point}}/role/{{ role_name }}",
      schema: {
        res: kubernetesRoleResponse
      }
    },
    deleteKubernetesRole: {
      method: "DELETE",
      path: "/auth/{{mount_point}}{{^mount_point}}kubernetes{{/mount_point}}/role/{{ role_name }}"
    },
    addApproleRole: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/role/{{role_name}}",
      schema: {
        req: {
          type: "object",
          properties: {
            bind_secret_id: {
              type: "boolean"
            },
            bound_cidr_list: {
              type: "string"
            },
            policies: {
              type: "string"
            },
            secret_id_num_uses: {
              type: "integer"
            },
            secret_id_ttl: {
              type: "integer"
            },
            token_num_uses: {
              type: "integer"
            },
            token_ttl: {
              type: "integer"
            },
            token_max_ttl: {
              type: "integer"
            },
            period: {
              type: "integer"
            }
          }
        }
      }
    },
    getApproleRole: {
      method: "GET",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/role/{{role_name}}",
      schema: {
        res: approleResponse
      }
    },
    deleteApproleRole: {
      method: "DELETE",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/role/{{role_name}}"
    },
    getApproleRoleId: {
      method: "GET",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/role/{{role_name}}/role-id",
      schema: {
        res: approleResponse
      }
    },
    updateApproleRoleId: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/role/{{role_name}}/role-id",
      schema: {
        req: {
          type: "object",
          properties: {
            role_id: {
              type: "string"
            }
          },
          required: ["role_id"]
        }
      }
    },
    getApproleRoleSecret: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}" + "/role/{{role_name}}/secret-id",
      schema: {
        req: {
          type: "object",
          properties: {
            metadata: {
              type: "string"
            },
            cidr_list: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      }
    },
    generateRootInit: {
      method: "PUT",
      path: "/sys/generate-root/attempt",
      schema: {
        req: {
          type: "object",
          properties: {
            otp: {
              type: "string"
            },
            pgp_key: {
              type: "string"
            }
          }
        },
        res: {
          type: "object",
          properties: {
            started: {
              type: "boolean"
            },
            nonce: {
              type: "string"
            },
            progress: {
              type: "integer",
              minimum: 0
            },
            required: {
              type: "integer",
              minimum: 1
            },
            pgp_fingerprint: {
              type: "string"
            },
            complete: {
              type: "boolean"
            }
          },
          required: ["started", "nonce", "progress", "required", "pgp_fingerprint", "complete"]
        }
      }
    },
    generateRootCancel: {
      method: "DELETE",
      path: "/sys/generate-root/attempt"
    },
    generateRootUpdate: {
      method: "PUT",
      path: "/sys/generate-root/update",
      schema: {
        req: {
          type: "object",
          properties: {
            key: {
              type: "string"
            },
            nonce: {
              type: "string"
            }
          },
          required: ["key", "nonce"]
        },
        res: {
          type: "object",
          properties: {
            started: {
              type: "boolean"
            },
            nonce: {
              type: "string"
            },
            progress: {
              type: "integer",
              minimum: 0
            },
            required: {
              type: "integer",
              minimum: 1
            },
            pgp_fingerprint: {
              type: "string"
            },
            complete: {
              type: "boolean"
            },
            encoded_root_token: {
              type: "string"
            }
          },
          required: ["started", "nonce", "progress", "required", "pgp_fingerprint", "complete"]
        }
      }
    },
    mounts: {
      method: "GET",
      path: "/sys/mounts"
    },
    mount: {
      method: "POST",
      path: "/sys/mounts/{{mount_point}}"
    },
    encryptData: {
      method: "POST",
      path: "/transit/encrypt/{{name}}"
    },
    decryptData: {
      method: "POST",
      path: "/transit/decrypt/{{name}}"
    },
    generateDatabaseCredentials: {
      method: "GET",
      path: "/{{databasePath}}/creds/{{name}}"
    },
    unmount: {
      method: "DELETE",
      path: "/sys/mounts/{{mount_point}}"
    },
    remount: {
      method: "POST",
      path: "/sys/remount"
    },
    policies: {
      method: "GET",
      path: "/sys/policy"
    },
    addPolicy: {
      method: "PUT",
      path: "/sys/policy/{{name}}"
    },
    getPolicy: {
      method: "GET",
      path: "/sys/policy/{{name}}"
    },
    removePolicy: {
      method: "DELETE",
      path: "/sys/policy/{{name}}"
    },
    auths: {
      method: "GET",
      path: "/sys/auth"
    },
    enableAuth: {
      method: "POST",
      path: "/sys/auth/{{mount_point}}"
    },
    disableAuth: {
      method: "DELETE",
      path: "/sys/auth/{{mount_point}}"
    },
    audits: {
      method: "GET",
      path: "/sys/audit"
    },
    enableAudit: {
      method: "PUT",
      path: "/sys/audit/{{name}}"
    },
    disableAudit: {
      method: "DELETE",
      path: "/sys/audit/{{name}}"
    },
    renew: {
      method: "PUT",
      path: "/sys/leases/renew",
      schema: {
        req: {
          type: "object",
          properties: {
            lease_id: {
              type: "string"
            },
            increment: {
              type: "integer"
            }
          },
          required: ["lease_id"]
        },
        res: {
          type: "object",
          properties: {
            lease_id: {
              type: "string"
            },
            renewable: {
              type: "boolean"
            },
            lease_duration: {
              type: "integer"
            }
          }
        }
      }
    },
    revoke: {
      method: "PUT",
      path: "/sys/leases/revoke",
      schema: {
        req: {
          type: "object",
          properties: {
            lease_id: {
              type: "string"
            }
          },
          required: ["lease_id"]
        }
      }
    },
    revokePrefix: {
      method: "PUT",
      path: "/sys/revoke-prefix/{{path_prefix}}"
    },
    rotate: {
      method: "PUT",
      path: "/sys/rotate"
    },
    unwrap: {
      method: "POST",
      path: "/sys/wrapping/unwrap",
      schema: {
        req: {
          type: "object",
          properties: {
            token: {
              type: "string"
            }
          }
        }
      }
    },
    gcpLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}gcp{{/mount_point}}/login",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            role: {
              type: "string"
            },
            jwt: {
              type: "string"
            }
          },
          required: ["role", "jwt"]
        },
        res: tokenResponse
      }
    },
    githubLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}github{{/mount_point}}/login",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            token: {
              type: "string"
            }
          },
          required: ["token"]
        },
        res: tokenResponse
      }
    },
    kubernetesLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}kubernetes{{/mount_point}}/login",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            role: {
              type: "string"
            },
            jwt: {
              type: "string"
            }
          },
          required: ["role", "jwt"]
        },
        res: tokenResponse
      }
    },
    awsIamLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}aws{{/mount_point}}/login",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            role: {
              type: "string"
            },
            iam_http_request_method: {
              type: "string"
            },
            iam_request_url: {
              type: "string"
            },
            iam_request_body: {
              type: "string"
            },
            iam_request_headers: {
              type: "string"
            }
          },
          required: [
            "role",
            "iam_http_request_method",
            "iam_request_url",
            "iam_request_body",
            "iam_request_headers"
          ]
        },
        res: tokenResponse
      }
    },
    userpassLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}userpass{{/mount_point}}/login/{{username}}",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            password: {
              type: "string"
            }
          },
          required: ["password"]
        },
        res: tokenResponse
      }
    },
    ldapLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}ldap{{/mount_point}}/login/{{username}}",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            password: {
              type: "string"
            }
          },
          required: ["password"]
        },
        res: tokenResponse
      }
    },
    oktaLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}okta{{/mount_point}}/login/{{username}}",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            password: {
              type: "string"
            }
          },
          required: ["password"]
        },
        res: tokenResponse
      }
    },
    radiusLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}radius{{/mount_point}}/login/{{username}}",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            password: {
              type: "string"
            }
          },
          required: ["password"]
        },
        res: tokenResponse
      }
    },
    certLogin: {
      method: "POST",
      path: "/auth/cert/login",
      tokenSource: true,
      schema: {
        req: {
          type: "object"
        },
        res: tokenResponse
      }
    },
    tokenAccessors: {
      method: "LIST",
      path: "/auth/token/accessors",
      schema: {
        res: {
          type: "object",
          properties: {
            data: {
              type: "object",
              properties: {
                keys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          },
          required: ["data"]
        }
      }
    },
    tokenCreate: {
      method: "POST",
      path: "/auth/token/create",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            id: {
              type: "string"
            },
            policies: {
              type: "array",
              items: {
                type: "string"
              }
            },
            meta: {
              type: "object"
            },
            no_parent: {
              type: "boolean"
            },
            no_default_policy: {
              type: "boolean"
            },
            renewable: {
              type: "boolean"
            },
            ttl: {
              type: "string"
            },
            explicit_max_ttl: {
              type: "string"
            },
            display_name: {
              type: "string"
            },
            num_uses: {
              type: "integer"
            }
          }
        },
        res: tokenResponse
      }
    },
    tokenCreateOrphan: {
      method: "POST",
      path: "/auth/token/create-orphan",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            id: {
              type: "string"
            },
            policies: {
              type: "array",
              items: {
                type: "string"
              }
            },
            meta: {
              type: "object"
            },
            no_parent: {
              type: "boolean"
            },
            no_default_policy: {
              type: "boolean"
            },
            renewable: {
              type: "boolean"
            },
            ttl: {
              type: "string"
            },
            explicit_max_ttl: {
              type: "string"
            },
            display_name: {
              type: "string"
            },
            num_uses: {
              type: "integer"
            }
          }
        },
        res: tokenResponse
      }
    },
    tokenCreateRole: {
      method: "POST",
      path: "/auth/token/create/{{role_name}}",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            id: {
              type: "string"
            },
            policies: {
              type: "array",
              items: {
                type: "string"
              }
            },
            meta: {
              type: "object"
            },
            no_parent: {
              type: "boolean"
            },
            no_default_policy: {
              type: "boolean"
            },
            renewable: {
              type: "boolean"
            },
            ttl: {
              type: "string"
            },
            explicit_max_ttl: {
              type: "string"
            },
            display_name: {
              type: "string"
            },
            num_uses: {
              type: "integer"
            }
          }
        },
        res: tokenResponse
      }
    },
    tokenLookup: {
      method: "POST",
      path: "/auth/token/lookup",
      schema: {
        req: {
          type: "object",
          properties: {
            token: {
              type: "string"
            }
          },
          required: ["token"]
        },
        res: {
          type: "object",
          properties: {
            data: {
              type: "object",
              properties: {
                id: {
                  type: "string"
                },
                policies: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                path: {
                  type: "string"
                },
                meta: {
                  type: "object"
                },
                display_name: {
                  type: "string"
                },
                num_uses: {
                  type: "integer"
                }
              }
            }
          },
          required: ["data"]
        }
      }
    },
    tokenLookupAccessor: {
      method: "POST",
      path: "/auth/token/lookup-accessor",
      schema: {
        req: {
          type: "object",
          properties: {
            accessor: {
              type: "string"
            }
          },
          required: ["accessor"]
        },
        res: {
          type: "object",
          properties: {
            data: {
              type: "object",
              properties: {
                id: {
                  type: "string"
                },
                policies: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                path: {
                  type: "string"
                },
                meta: {
                  type: "object"
                },
                display_name: {
                  type: "string"
                },
                num_uses: {
                  type: "integer"
                }
              }
            }
          },
          required: ["data"]
        }
      }
    },
    tokenLookupSelf: {
      method: "GET",
      path: "/auth/token/lookup-self",
      schema: {
        res: {
          type: "object",
          properties: {
            data: {
              type: "object",
              properties: {
                id: {
                  type: "string"
                },
                policies: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                path: {
                  type: "string"
                },
                meta: {
                  type: "object"
                },
                display_name: {
                  type: "string"
                },
                num_uses: {
                  type: "integer"
                }
              }
            }
          },
          required: ["data"]
        }
      }
    },
    tokenRenew: {
      method: "POST",
      path: "/auth/token/renew",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            token: {
              type: "string"
            },
            increment: {
              type: ["integer", "string"]
            }
          },
          required: ["token"]
        },
        res: tokenResponse
      }
    },
    tokenRenewSelf: {
      method: "POST",
      path: "/auth/token/renew-self",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            increment: {
              type: ["integer", "string"]
            }
          }
        },
        res: tokenResponse
      }
    },
    tokenRevoke: {
      method: "POST",
      path: "/auth/token/revoke",
      schema: {
        req: {
          type: "object",
          properties: {
            token: {
              type: "string"
            }
          },
          required: ["token"]
        }
      }
    },
    tokenRevokeAccessor: {
      method: "POST",
      path: "/auth/token/revoke-accessor",
      schema: {
        req: {
          type: "object",
          properties: {
            accessor: {
              type: "string"
            }
          },
          required: ["accessor"]
        }
      }
    },
    tokenRevokeOrphan: {
      method: "POST",
      path: "/auth/token/revoke-orphan",
      schema: {
        req: {
          type: "object",
          properties: {
            token: {
              type: "string"
            }
          },
          required: ["token"]
        }
      }
    },
    tokenRevokeSelf: {
      method: "POST",
      path: "/auth/token/revoke-self"
    },
    tokenRoles: {
      method: "GET",
      path: "/auth/token/roles?list=true",
      schema: {
        res: {
          type: "object",
          properties: {
            data: {
              type: "object",
              properties: {
                keys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          },
          required: ["data"]
        }
      }
    },
    addTokenRole: {
      method: "POST",
      path: "/auth/token/roles/{{role_name}}",
      schema: {
        req: {
          type: "object",
          properties: {
            allowed_policies: {
              type: "string"
            },
            disallowed_policies: {
              type: "string"
            },
            orphan: {
              type: "boolean"
            },
            period: {
              type: "integer"
            },
            renewable: {
              type: "boolean"
            },
            path_suffix: {
              type: "string"
            },
            explicit_max_ttl: {
              type: "integer"
            }
          }
        }
      }
    },
    approleSecretAccessors: {
      method: "LIST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}" + "/role/{{role_name}}/secret-id",
      schema: {
        res: approleResponse
      }
    },
    approleSecretLookup: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}" + "/role/{{role_name}}/secret-id/lookup",
      schema: {
        req: {
          type: "object",
          properties: {
            secret_id: {
              type: "string"
            }
          },
          required: ["secret_id"]
        },
        res: approleResponse
      }
    },
    approleSecretDestroy: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}" + "/role/{{role_name}}/secret-id/destroy",
      schema: {
        req: {
          type: "object",
          properties: {
            secret_id: {
              type: "string"
            }
          },
          required: ["secret_id"]
        }
      }
    },
    approleSecretAccessorLookup: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}" + "/role/{{role_name}}/secret-id-accessor/lookup",
      schema: {
        req: {
          type: "object",
          properties: {
            secret_id_accessor: {
              type: "string"
            }
          },
          required: ["secret_id_accessor"]
        }
      }
    },
    approleSecretAccessorDestroy: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}" + "/role/{{role_name}}/secret-id-accessor/destroy"
    },
    approleLogin: {
      method: "POST",
      path: "/auth/{{mount_point}}{{^mount_point}}approle{{/mount_point}}/login",
      tokenSource: true,
      schema: {
        req: {
          type: "object",
          properties: {
            role_id: {
              type: "string"
            },
            secret_id: {
              type: "string"
            }
          },
          required: ["role_id"]
        },
        res: approleResponse
      }
    },
    health: {
      method: "GET",
      path: "/sys/health",
      schema: {
        query: {
          type: "object",
          properties: {
            standbyok: {
              type: "boolean"
            },
            activecode: {
              type: "integer"
            },
            standbycode: {
              type: "integer"
            },
            sealedcode: {
              type: "integer"
            },
            uninitcode: {
              type: "integer"
            }
          }
        },
        res: {
          type: "object",
          properties: {
            cluster_id: {
              type: "string"
            },
            cluster_name: {
              type: "string"
            },
            version: {
              type: "string"
            },
            server_time_utc: {
              type: "integer"
            },
            standby: {
              type: "boolean"
            },
            sealed: {
              type: "boolean"
            },
            initialized: {
              type: "boolean"
            }
          }
        }
      }
    },
    leader: {
      method: "GET",
      path: "/sys/leader",
      schema: {
        res: {
          type: "object",
          properties: {
            ha_enabled: {
              type: "boolean"
            },
            is_self: {
              type: "boolean"
            },
            leader_address: {
              type: "string"
            }
          }
        }
      }
    },
    stepDown: {
      method: "PUT",
      path: "/sys/step-down"
    }
  };
});

// node_modules/mustache/mustache.js
var require_mustache = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
  })(exports, function() {
    /*!
       * mustache.js - Logic-less {{mustache}} templates with JavaScript
       * http://github.com/janl/mustache.js
       */
    var objectToString = Object.prototype.toString;
    var isArray = Array.isArray || function isArrayPolyfill(object) {
      return objectToString.call(object) === "[object Array]";
    };
    function isFunction(object) {
      return typeof object === "function";
    }
    function typeStr(obj2) {
      return isArray(obj2) ? "array" : typeof obj2;
    }
    function escapeRegExp(string) {
      return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function hasProperty(obj2, propName) {
      return obj2 != null && typeof obj2 === "object" && propName in obj2;
    }
    function primitiveHasOwnProperty(primitive, propName) {
      return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
    }
    var regExpTest = RegExp.prototype.test;
    function testRegExp(re, string) {
      return regExpTest.call(re, string);
    }
    var nonSpaceRe = /\S/;
    function isWhitespace(string) {
      return !testRegExp(nonSpaceRe, string);
    }
    var entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    function escapeHtml(string) {
      return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
        return entityMap[s];
      });
    }
    var whiteRe = /\s*/;
    var spaceRe = /\s+/;
    var equalsRe = /\s*=/;
    var curlyRe = /\s*\}/;
    var tagRe = /#|\^|\/|>|\{|&|=|!/;
    function parseTemplate(template, tags) {
      if (!template)
        return [];
      var lineHasNonSpace = false;
      var sections = [];
      var tokens = [];
      var spaces = [];
      var hasTag = false;
      var nonSpace = false;
      var indentation = "";
      var tagIndex = 0;
      function stripSpace() {
        if (hasTag && !nonSpace) {
          while (spaces.length)
            delete tokens[spaces.pop()];
        } else {
          spaces = [];
        }
        hasTag = false;
        nonSpace = false;
      }
      var openingTagRe, closingTagRe, closingCurlyRe;
      function compileTags(tagsToCompile) {
        if (typeof tagsToCompile === "string")
          tagsToCompile = tagsToCompile.split(spaceRe, 2);
        if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
          throw new Error("Invalid tags: " + tagsToCompile);
        openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
        closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
        closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
      }
      compileTags(tags || mustache.tags);
      var scanner = new Scanner(template);
      var start, type, value, chr, token, openSection;
      while (!scanner.eos()) {
        start = scanner.pos;
        value = scanner.scanUntil(openingTagRe);
        if (value) {
          for (var i = 0, valueLength = value.length;i < valueLength; ++i) {
            chr = value.charAt(i);
            if (isWhitespace(chr)) {
              spaces.push(tokens.length);
              indentation += chr;
            } else {
              nonSpace = true;
              lineHasNonSpace = true;
              indentation += " ";
            }
            tokens.push(["text", chr, start, start + 1]);
            start += 1;
            if (chr === `
`) {
              stripSpace();
              indentation = "";
              tagIndex = 0;
              lineHasNonSpace = false;
            }
          }
        }
        if (!scanner.scan(openingTagRe))
          break;
        hasTag = true;
        type = scanner.scan(tagRe) || "name";
        scanner.scan(whiteRe);
        if (type === "=") {
          value = scanner.scanUntil(equalsRe);
          scanner.scan(equalsRe);
          scanner.scanUntil(closingTagRe);
        } else if (type === "{") {
          value = scanner.scanUntil(closingCurlyRe);
          scanner.scan(curlyRe);
          scanner.scanUntil(closingTagRe);
          type = "&";
        } else {
          value = scanner.scanUntil(closingTagRe);
        }
        if (!scanner.scan(closingTagRe))
          throw new Error("Unclosed tag at " + scanner.pos);
        if (type == ">") {
          token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
        } else {
          token = [type, value, start, scanner.pos];
        }
        tagIndex++;
        tokens.push(token);
        if (type === "#" || type === "^") {
          sections.push(token);
        } else if (type === "/") {
          openSection = sections.pop();
          if (!openSection)
            throw new Error('Unopened section "' + value + '" at ' + start);
          if (openSection[1] !== value)
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
        } else if (type === "name" || type === "{" || type === "&") {
          nonSpace = true;
        } else if (type === "=") {
          compileTags(value);
        }
      }
      stripSpace();
      openSection = sections.pop();
      if (openSection)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
      return nestTokens(squashTokens(tokens));
    }
    function squashTokens(tokens) {
      var squashedTokens = [];
      var token, lastToken;
      for (var i = 0, numTokens = tokens.length;i < numTokens; ++i) {
        token = tokens[i];
        if (token) {
          if (token[0] === "text" && lastToken && lastToken[0] === "text") {
            lastToken[1] += token[1];
            lastToken[3] = token[3];
          } else {
            squashedTokens.push(token);
            lastToken = token;
          }
        }
      }
      return squashedTokens;
    }
    function nestTokens(tokens) {
      var nestedTokens = [];
      var collector = nestedTokens;
      var sections = [];
      var token, section;
      for (var i = 0, numTokens = tokens.length;i < numTokens; ++i) {
        token = tokens[i];
        switch (token[0]) {
          case "#":
          case "^":
            collector.push(token);
            sections.push(token);
            collector = token[4] = [];
            break;
          case "/":
            section = sections.pop();
            section[5] = token[2];
            collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
            break;
          default:
            collector.push(token);
        }
      }
      return nestedTokens;
    }
    function Scanner(string) {
      this.string = string;
      this.tail = string;
      this.pos = 0;
    }
    Scanner.prototype.eos = function eos() {
      return this.tail === "";
    };
    Scanner.prototype.scan = function scan(re) {
      var match = this.tail.match(re);
      if (!match || match.index !== 0)
        return "";
      var string = match[0];
      this.tail = this.tail.substring(string.length);
      this.pos += string.length;
      return string;
    };
    Scanner.prototype.scanUntil = function scanUntil(re) {
      var index = this.tail.search(re), match;
      switch (index) {
        case -1:
          match = this.tail;
          this.tail = "";
          break;
        case 0:
          match = "";
          break;
        default:
          match = this.tail.substring(0, index);
          this.tail = this.tail.substring(index);
      }
      this.pos += match.length;
      return match;
    };
    function Context(view, parentContext) {
      this.view = view;
      this.cache = { ".": this.view };
      this.parent = parentContext;
    }
    Context.prototype.push = function push(view) {
      return new Context(view, this);
    };
    Context.prototype.lookup = function lookup(name) {
      var cache = this.cache;
      var value;
      if (cache.hasOwnProperty(name)) {
        value = cache[name];
      } else {
        var context = this, intermediateValue, names, index, lookupHit = false;
        while (context) {
          if (name.indexOf(".") > 0) {
            intermediateValue = context.view;
            names = name.split(".");
            index = 0;
            while (intermediateValue != null && index < names.length) {
              if (index === names.length - 1)
                lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
              intermediateValue = intermediateValue[names[index++]];
            }
          } else {
            intermediateValue = context.view[name];
            lookupHit = hasProperty(context.view, name);
          }
          if (lookupHit) {
            value = intermediateValue;
            break;
          }
          context = context.parent;
        }
        cache[name] = value;
      }
      if (isFunction(value))
        value = value.call(this.view);
      return value;
    };
    function Writer() {
      this.templateCache = {
        _cache: {},
        set: function set(key, value) {
          this._cache[key] = value;
        },
        get: function get(key) {
          return this._cache[key];
        },
        clear: function clear() {
          this._cache = {};
        }
      };
    }
    Writer.prototype.clearCache = function clearCache() {
      if (typeof this.templateCache !== "undefined") {
        this.templateCache.clear();
      }
    };
    Writer.prototype.parse = function parse(template, tags) {
      var cache = this.templateCache;
      var cacheKey = template + ":" + (tags || mustache.tags).join(":");
      var isCacheEnabled = typeof cache !== "undefined";
      var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;
      if (tokens == undefined) {
        tokens = parseTemplate(template, tags);
        isCacheEnabled && cache.set(cacheKey, tokens);
      }
      return tokens;
    };
    Writer.prototype.render = function render(template, view, partials, config) {
      var tags = this.getConfigTags(config);
      var tokens = this.parse(template, tags);
      var context = view instanceof Context ? view : new Context(view, undefined);
      return this.renderTokens(tokens, context, partials, template, config);
    };
    Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
      var buffer = "";
      var token, symbol, value;
      for (var i = 0, numTokens = tokens.length;i < numTokens; ++i) {
        value = undefined;
        token = tokens[i];
        symbol = token[0];
        if (symbol === "#")
          value = this.renderSection(token, context, partials, originalTemplate, config);
        else if (symbol === "^")
          value = this.renderInverted(token, context, partials, originalTemplate, config);
        else if (symbol === ">")
          value = this.renderPartial(token, context, partials, config);
        else if (symbol === "&")
          value = this.unescapedValue(token, context);
        else if (symbol === "name")
          value = this.escapedValue(token, context, config);
        else if (symbol === "text")
          value = this.rawValue(token);
        if (value !== undefined)
          buffer += value;
      }
      return buffer;
    };
    Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
      var self2 = this;
      var buffer = "";
      var value = context.lookup(token[1]);
      function subRender(template) {
        return self2.render(template, context, partials, config);
      }
      if (!value)
        return;
      if (isArray(value)) {
        for (var j = 0, valueLength = value.length;j < valueLength; ++j) {
          buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
        }
      } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
        buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
      } else if (isFunction(value)) {
        if (typeof originalTemplate !== "string")
          throw new Error("Cannot use higher-order sections without the original template");
        value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
        if (value != null)
          buffer += value;
      } else {
        buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
      }
      return buffer;
    };
    Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
      var value = context.lookup(token[1]);
      if (!value || isArray(value) && value.length === 0)
        return this.renderTokens(token[4], context, partials, originalTemplate, config);
    };
    Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
      var filteredIndentation = indentation.replace(/[^ \t]/g, "");
      var partialByNl = partial.split(`
`);
      for (var i = 0;i < partialByNl.length; i++) {
        if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
          partialByNl[i] = filteredIndentation + partialByNl[i];
        }
      }
      return partialByNl.join(`
`);
    };
    Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
      if (!partials)
        return;
      var tags = this.getConfigTags(config);
      var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
      if (value != null) {
        var lineHasNonSpace = token[6];
        var tagIndex = token[5];
        var indentation = token[4];
        var indentedValue = value;
        if (tagIndex == 0 && indentation) {
          indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
        }
        var tokens = this.parse(indentedValue, tags);
        return this.renderTokens(tokens, context, partials, indentedValue, config);
      }
    };
    Writer.prototype.unescapedValue = function unescapedValue(token, context) {
      var value = context.lookup(token[1]);
      if (value != null)
        return value;
    };
    Writer.prototype.escapedValue = function escapedValue(token, context, config) {
      var escape = this.getConfigEscape(config) || mustache.escape;
      var value = context.lookup(token[1]);
      if (value != null)
        return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
    };
    Writer.prototype.rawValue = function rawValue(token) {
      return token[1];
    };
    Writer.prototype.getConfigTags = function getConfigTags(config) {
      if (isArray(config)) {
        return config;
      } else if (config && typeof config === "object") {
        return config.tags;
      } else {
        return;
      }
    };
    Writer.prototype.getConfigEscape = function getConfigEscape(config) {
      if (config && typeof config === "object" && !isArray(config)) {
        return config.escape;
      } else {
        return;
      }
    };
    var mustache = {
      name: "mustache.js",
      version: "4.2.0",
      tags: ["{{", "}}"],
      clearCache: undefined,
      escape: undefined,
      parse: undefined,
      render: undefined,
      Scanner: undefined,
      Context: undefined,
      Writer: undefined,
      set templateCache(cache) {
        defaultWriter.templateCache = cache;
      },
      get templateCache() {
        return defaultWriter.templateCache;
      }
    };
    var defaultWriter = new Writer;
    mustache.clearCache = function clearCache() {
      return defaultWriter.clearCache();
    };
    mustache.parse = function parse(template, tags) {
      return defaultWriter.parse(template, tags);
    };
    mustache.render = function render(template, view, partials, config) {
      if (typeof template !== "string") {
        throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + "argument for mustache#render(template, view, partials)");
      }
      return defaultWriter.render(template, view, partials, config);
    };
    mustache.escape = escapeHtml;
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    mustache.Writer = Writer;
    return mustache;
  });
});

// node_modules/extend/index.js
var require_extend = __commonJS((exports, module) => {
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject = function isPlainObject(obj2) {
    if (!obj2 || toStr.call(obj2) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj2, "constructor");
    var hasIsPrototypeOf = obj2.constructor && obj2.constructor.prototype && hasOwn.call(obj2.constructor.prototype, "isPrototypeOf");
    if (obj2.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj2) {}
    return typeof key === "undefined" || hasOwn.call(obj2, key);
  };
  var setProperty = function setProperty(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty(obj2, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj2, name)) {
        return;
      } else if (gOPD) {
        return gOPD(obj2, name).value;
      }
    }
    return obj2[name];
  };
  module.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (;i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/psl/dist/psl.cjs
var require_psl = __commonJS((exports) => {
  Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
  function K(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var O;
  var F;
  function Q() {
    if (F)
      return O;
    F = 1;
    const e = 2147483647, s = 36, c = 1, o = 26, t = 38, d = 700, z = 72, y = 128, g = "-", P = /^xn--/, V = /[^\0-\x7F]/, G = /[\x2E\u3002\uFF0E\uFF61]/g, W = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, C = s - c, h = Math.floor, I = String.fromCharCode;
    function v(a) {
      throw new RangeError(W[a]);
    }
    function U(a, i) {
      const m = [];
      let n = a.length;
      for (;n--; )
        m[n] = i(a[n]);
      return m;
    }
    function S(a, i) {
      const m = a.split("@");
      let n = "";
      m.length > 1 && (n = m[0] + "@", a = m[1]), a = a.replace(G, ".");
      const r = a.split("."), p = U(r, i).join(".");
      return n + p;
    }
    function L(a) {
      const i = [];
      let m = 0;
      const n = a.length;
      for (;m < n; ) {
        const r = a.charCodeAt(m++);
        if (r >= 55296 && r <= 56319 && m < n) {
          const p = a.charCodeAt(m++);
          (p & 64512) == 56320 ? i.push(((r & 1023) << 10) + (p & 1023) + 65536) : (i.push(r), m--);
        } else
          i.push(r);
      }
      return i;
    }
    const $ = (a) => String.fromCodePoint(...a), J = function(a) {
      return a >= 48 && a < 58 ? 26 + (a - 48) : a >= 65 && a < 91 ? a - 65 : a >= 97 && a < 123 ? a - 97 : s;
    }, D = function(a, i) {
      return a + 22 + 75 * (a < 26) - ((i != 0) << 5);
    }, T = function(a, i, m) {
      let n = 0;
      for (a = m ? h(a / d) : a >> 1, a += h(a / i);a > C * o >> 1; n += s)
        a = h(a / C);
      return h(n + (C + 1) * a / (a + t));
    }, E = function(a) {
      const i = [], m = a.length;
      let n = 0, r = y, p = z, j = a.lastIndexOf(g);
      j < 0 && (j = 0);
      for (let u = 0;u < j; ++u)
        a.charCodeAt(u) >= 128 && v("not-basic"), i.push(a.charCodeAt(u));
      for (let u = j > 0 ? j + 1 : 0;u < m; ) {
        const k = n;
        for (let l2 = 1, b = s;; b += s) {
          u >= m && v("invalid-input");
          const w = J(a.charCodeAt(u++));
          w >= s && v("invalid-input"), w > h((e - n) / l2) && v("overflow"), n += w * l2;
          const x = b <= p ? c : b >= p + o ? o : b - p;
          if (w < x)
            break;
          const q2 = s - x;
          l2 > h(e / q2) && v("overflow"), l2 *= q2;
        }
        const f2 = i.length + 1;
        p = T(n - k, f2, k == 0), h(n / f2) > e - r && v("overflow"), r += h(n / f2), n %= f2, i.splice(n++, 0, r);
      }
      return String.fromCodePoint(...i);
    }, B = function(a) {
      const i = [];
      a = L(a);
      const m = a.length;
      let n = y, r = 0, p = z;
      for (const k of a)
        k < 128 && i.push(I(k));
      const j = i.length;
      let u = j;
      for (j && i.push(g);u < m; ) {
        let k = e;
        for (const l2 of a)
          l2 >= n && l2 < k && (k = l2);
        const f2 = u + 1;
        k - n > h((e - r) / f2) && v("overflow"), r += (k - n) * f2, n = k;
        for (const l2 of a)
          if (l2 < n && ++r > e && v("overflow"), l2 === n) {
            let b = r;
            for (let w = s;; w += s) {
              const x = w <= p ? c : w >= p + o ? o : w - p;
              if (b < x)
                break;
              const q2 = b - x, M = s - x;
              i.push(I(D(x + q2 % M, 0))), b = h(q2 / M);
            }
            i.push(I(D(b, 0))), p = T(r, f2, u === j), r = 0, ++u;
          }
        ++r, ++n;
      }
      return i.join("");
    };
    return O = { version: "2.3.1", ucs2: { decode: L, encode: $ }, decode: E, encode: B, toASCII: function(a) {
      return S(a, function(i) {
        return V.test(i) ? "xn--" + B(i) : i;
      });
    }, toUnicode: function(a) {
      return S(a, function(i) {
        return P.test(i) ? E(i.slice(4).toLowerCase()) : i;
      });
    } }, O;
  }
  var X = Q();
  var A = K(X);
  var Y = ["ac", "com.ac", "edu.ac", "gov.ac", "mil.ac", "net.ac", "org.ac", "ad", "ae", "ac.ae", "co.ae", "gov.ae", "mil.ae", "net.ae", "org.ae", "sch.ae", "aero", "airline.aero", "airport.aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "air-surveillance.aero", "air-traffic-control.aero", "aircraft.aero", "airtraffic.aero", "ambulance.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "marketplace.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "taxi.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "com.af", "edu.af", "gov.af", "net.af", "org.af", "ag", "co.ag", "com.ag", "net.ag", "nom.ag", "org.ag", "ai", "com.ai", "net.ai", "off.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "co.ao", "ed.ao", "edu.ao", "gov.ao", "gv.ao", "it.ao", "og.ao", "org.ao", "pb.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "home.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "sth.ac.at", "co.at", "gv.at", "or.at", "au", "asn.au", "com.au", "edu.au", "gov.au", "id.au", "net.au", "org.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "biz.az", "com.az", "edu.az", "gov.az", "info.az", "int.az", "mil.az", "name.az", "net.az", "org.az", "pp.az", "pro.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "bh", "com.bh", "edu.bh", "gov.bh", "net.bh", "org.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "africa.bj", "agro.bj", "architectes.bj", "assur.bj", "avocats.bj", "co.bj", "com.bj", "eco.bj", "econo.bj", "edu.bj", "info.bj", "loisirs.bj", "money.bj", "net.bj", "org.bj", "ote.bj", "restaurant.bj", "resto.bj", "tourism.bj", "univ.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "mil.bo", "net.bo", "org.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "plurinacional.bo", "politica.bo", "profesional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bet.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "leilao.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "edu.bs", "gov.bs", "net.bs", "org.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "co.bz", "com.bz", "edu.bz", "gov.bz", "net.bz", "org.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "ac.ci", "aroport.ci", "asso.ci", "co.ci", "com.ci", "ed.ci", "edu.ci", "go.ci", "gouv.ci", "int.ci", "net.ci", "or.ci", "org.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "mil.cn", "net.cn", "org.cn", ".cn", ".cn", ".cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gx.cn", "gz.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hk.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "mo.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "tw.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "co", "com.co", "edu.co", "gov.co", "mil.co", "net.co", "nom.co", "org.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "gob.cu", "inf.cu", "nat.cu", "net.cu", "org.cu", "cv", "com.cv", "edu.cv", "id.cv", "int.cv", "net.cv", "nome.cv", "org.cv", "publ.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "co.dm", "com.dm", "edu.dm", "gov.dm", "net.dm", "org.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "net.dz", "org.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "edu.ec", "fin.ec", "gob.ec", "gov.ec", "info.ec", "k12.ec", "med.ec", "mil.ec", "net.ec", "org.ec", "pro.ec", "edu", "ee", "aip.ee", "com.ee", "edu.ee", "fie.ee", "gov.ee", "lib.ee", "med.ee", "org.ee", "pri.ee", "riik.ee", "eg", "ac.eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "info.eg", "me.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "sport.eg", "tv.eg", "*.er", "es", "com.es", "edu.es", "gob.es", "nom.es", "org.es", "et", "biz.et", "com.et", "edu.et", "gov.et", "info.et", "name.et", "net.et", "org.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "fm", "com.fm", "edu.fm", "net.fm", "org.fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "avoues.fr", "cci.fr", "greta.fr", "huissier-justice.fr", "ga", "gb", "gd", "edu.gd", "gov.gd", "ge", "com.ge", "edu.ge", "gov.ge", "net.ge", "org.ge", "pvt.ge", "school.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "mil.gh", "org.gh", "gi", "com.gi", "edu.gi", "gov.gi", "ltd.gi", "mod.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "net.gn", "org.gn", "gov", "gp", "asso.gp", "com.gp", "edu.gp", "mobi.gp", "net.gp", "org.gp", "gq", "gr", "com.gr", "edu.gr", "gov.gr", "net.gr", "org.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", "hm", "hn", "com.hn", "edu.hn", "gob.hn", "mil.hn", "net.hn", "org.hn", "hr", "com.hr", "from.hr", "iz.hr", "name.hr", "ht", "adult.ht", "art.ht", "asso.ht", "com.ht", "coop.ht", "edu.ht", "firm.ht", "gouv.ht", "info.ht", "med.ht", "net.ht", "org.ht", "perso.ht", "pol.ht", "pro.ht", "rel.ht", "shop.ht", "hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "co.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "info.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "org.hu", "priv.hu", "reklam.hu", "sex.hu", "shop.hu", "sport.hu", "suli.hu", "szex.hu", "tm.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "", ".", ".", ".", ".", "im", "ac.im", "co.im", "ltd.co.im", "plc.co.im", "com.im", "net.im", "org.im", "tt.im", "tv.im", "in", "5g.in", "6g.in", "ac.in", "ai.in", "am.in", "bihar.in", "biz.in", "business.in", "ca.in", "cn.in", "co.in", "com.in", "coop.in", "cs.in", "delhi.in", "dr.in", "edu.in", "er.in", "firm.in", "gen.in", "gov.in", "gujarat.in", "ind.in", "info.in", "int.in", "internet.in", "io.in", "me.in", "mil.in", "net.in", "nic.in", "org.in", "pg.in", "post.in", "pro.in", "res.in", "travel.in", "tv.in", "uk.in", "up.in", "us.in", "info", "int", "eu.int", "io", "co.io", "com.io", "edu.io", "gov.io", "mil.io", "net.io", "nom.io", "org.io", "iq", "com.iq", "edu.iq", "gov.iq", "mil.iq", "net.iq", "org.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", ".ir", ".ir", "is", "it", "edu.it", "gov.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-sd-tirol.it", "trentin-sudtirol.it", "trentin-sdtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-sd-tirol.it", "trentino-sudtirol.it", "trentino-sdtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosd-tirol.it", "trentinosudtirol.it", "trentinosdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsd-tirol.it", "trentinsudtirol.it", "trentinsdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "valle-aoste.it", "vallee-d-aoste.it", "valle-d-aoste.it", "valleeaoste.it", "valleaoste.it", "valleedaoste.it", "valledaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan.it", "balsan-sudtirol.it", "balsan-sdtirol.it", "balsan-suedtirol.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano.it", "bolzano-altoadige.it", "bozen.it", "bozen-sudtirol.it", "bozen-sdtirol.it", "bozen-suedtirol.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan.it", "bulsan-sudtirol.it", "bulsan-sdtirol.it", "bulsan-suedtirol.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forl.it", "cesenaforli.it", "cesenaforl.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forl-cesena.it", "forlicesena.it", "forlcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza.it", "monza-brianza.it", "monza-e-della-brianza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "sdtirol.it", "suedtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "agri.jo", "ai.jo", "com.jo", "edu.jo", "eng.jo", "fm.jo", "gov.jo", "mil.jo", "net.jo", "org.jo", "per.jo", "phd.jo", "sch.jo", "tv.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", "*.kawasaki.jp", "!city.kawasaki.jp", "*.kitakyushu.jp", "!city.kitakyushu.jp", "*.kobe.jp", "!city.kobe.jp", "*.nagoya.jp", "!city.nagoya.jp", "*.sapporo.jp", "!city.sapporo.jp", "*.sendai.jp", "!city.sendai.jp", "*.yokohama.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "net.kg", "org.kg", "*.kh", "ki", "biz.ki", "com.ki", "edu.ki", "gov.ki", "info.ki", "net.ki", "org.ki", "km", "ass.km", "com.km", "edu.km", "gov.km", "mil.km", "nom.km", "org.km", "prd.km", "tm.km", "asso.km", "coop.km", "gouv.km", "medecin.km", "notaires.km", "pharmaciens.km", "presse.km", "veterinaire.km", "kn", "edu.kn", "gov.kn", "net.kn", "org.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "com.kz", "edu.kz", "gov.kz", "mil.kz", "net.kz", "org.kz", "la", "com.la", "edu.la", "gov.la", "info.la", "int.la", "net.la", "org.la", "per.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "co.lc", "com.lc", "edu.lc", "gov.lc", "net.lc", "org.lc", "li", "lk", "ac.lk", "assn.lk", "com.lk", "edu.lk", "gov.lk", "grp.lk", "hotel.lk", "int.lk", "ltd.lk", "net.lk", "ngo.lk", "org.lk", "sch.lk", "soc.lk", "web.lk", "lr", "com.lr", "edu.lr", "gov.lr", "net.lr", "org.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "asn.lv", "com.lv", "conf.lv", "edu.lv", "gov.lv", "id.lv", "mil.lv", "net.lv", "org.lv", "ly", "com.ly", "edu.ly", "gov.ly", "id.ly", "med.ly", "net.ly", "org.ly", "plc.ly", "sch.ly", "ma", "ac.ma", "co.ma", "gov.ma", "net.ma", "org.ma", "press.ma", "mc", "asso.mc", "tm.mc", "md", "me", "ac.me", "co.me", "edu.me", "gov.me", "its.me", "net.me", "org.me", "priv.me", "mg", "co.mg", "com.mg", "edu.mg", "gov.mg", "mil.mg", "nom.mg", "org.mg", "prd.mg", "mh", "mil", "mk", "com.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "net.mk", "org.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "edu.mn", "gov.mn", "org.mn", "mo", "com.mo", "edu.mo", "gov.mo", "net.mo", "org.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "ac.mu", "co.mu", "com.mu", "gov.mu", "net.mu", "or.mu", "org.mu", "museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "net.mw", "org.mw", "mx", "com.mx", "edu.mx", "gob.mx", "net.mx", "org.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "alt.na", "co.na", "com.na", "gov.na", "net.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "arts.nf", "com.nf", "firm.nf", "info.nf", "net.nf", "other.nf", "per.nf", "rec.nf", "store.nf", "web.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "folkebibl.no", "fylkesbibl.no", "idrett.no", "museum.no", "priv.no", "vgs.no", "dep.no", "herad.no", "kommune.no", "mil.no", "stat.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "krehamn.no", "algard.no", "lgrd.no", "arna.no", "bronnoysund.no", "brnnysund.no", "brumunddal.no", "bryne.no", "drobak.no", "drbak.no", "egersund.no", "fetsund.no", "floro.no", "flor.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hnefoss.no", "jessheim.no", "jorpeland.no", "jrpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevg.no", "leirvik.no", "mjondalen.no", "mjndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjen.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osyro.no", "raholt.no", "rholt.no", "sandnessjoen.no", "sandnessjen.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjrdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "aarborte.no", "aejrie.no", "afjord.no", "fjord.no", "agdenes.no", "nes.akershus.no", "aknoluokta.no", "koluokta.no", "al.no", "l.no", "alaheadju.no", "laheadju.no", "alesund.no", "lesund.no", "alstahaug.no", "alta.no", "lt.no", "alvdal.no", "amli.no", "mli.no", "amot.no", "mot.no", "andasuolo.no", "andebu.no", "andoy.no", "andy.no", "ardal.no", "rdal.no", "aremark.no", "arendal.no", "s.no", "aseral.no", "seral.no", "asker.no", "askim.no", "askoy.no", "asky.no", "askvoll.no", "asnes.no", "snes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-hland.no", "austevoll.no", "austrheim.no", "averoy.no", "avery.no", "badaddja.no", "bdddj.no", "brum.no", "bahcavuotna.no", "bhcavuotna.no", "bahccavuotna.no", "bhccavuotna.no", "baidar.no", "bidr.no", "bajddar.no", "bjddar.no", "balat.no", "blt.no", "balestrand.no", "ballangen.no", "balsfjord.no", "bamble.no", "bardu.no", "barum.no", "batsfjord.no", "btsfjord.no", "bearalvahki.no", "bearalvhki.no", "beardu.no", "beiarn.no", "berg.no", "bergen.no", "berlevag.no", "berlevg.no", "bievat.no", "bievt.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarky.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bod.no", "bokn.no", "bomlo.no", "bmlo.no", "bremanger.no", "bronnoy.no", "brnny.no", "budejju.no", "nes.buskerud.no", "bygland.no", "bykle.no", "cahcesuolo.no", "hcesuolo.no", "davvenjarga.no", "davvenjrga.no", "davvesiida.no", "deatnu.no", "dielddanuorri.no", "divtasvuodna.no", "divttasvuotna.no", "donna.no", "dnna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyry.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenassi.no", "eveni.no", "evenes.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fedje.no", "fet.no", "finnoy.no", "finny.no", "fitjar.no", "fjaler.no", "fjell.no", "fla.no", "fl.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "folldal.no", "forde.no", "frde.no", "forsand.no", "fosnes.no", "frna.no", "frana.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "froya.no", "frya.no", "fuoisku.no", "fuossko.no", "fusa.no", "fyresdal.no", "gaivuotna.no", "givuotna.no", "galsa.no", "gls.no", "gamvik.no", "gangaviika.no", "ggaviika.no", "gaular.no", "gausdal.no", "giehtavuoatna.no", "gildeskal.no", "gildeskl.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjvik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "grue.no", "gulen.no", "guovdageaidnu.no", "ha.no", "h.no", "habmer.no", "hbmer.no", "hadsel.no", "hgebostad.no", "hagebostad.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "hammarfeasta.no", "hmmrfeasta.no", "hammerfest.no", "hapmir.no", "hpmir.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "hattfjelldal.no", "haugesund.no", "os.hedmark.no", "valer.hedmark.no", "vler.hedmark.no", "hemne.no", "hemnes.no", "hemsedal.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobl.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtlen.no", "os.hordaland.no", "hornindal.no", "horten.no", "hoyanger.no", "hyanger.no", "hoylandet.no", "hylandet.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "ibestad.no", "inderoy.no", "indery.no", "iveland.no", "ivgu.no", "jevnaker.no", "jolster.no", "jlster.no", "jondal.no", "kafjord.no", "kfjord.no", "karasjohka.no", "krjohka.no", "karasjok.no", "karlsoy.no", "karmoy.no", "karmy.no", "kautokeino.no", "klabu.no", "klbu.no", "klepp.no", "kongsberg.no", "kongsvinger.no", "kraanghke.no", "kranghke.no", "kragero.no", "krager.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krdsherad.no", "kvfjord.no", "kvnangen.no", "kvafjord.no", "kvalsund.no", "kvam.no", "kvanangen.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsy.no", "laakesvuemie.no", "lrdal.no", "lahppi.no", "lhppi.no", "lardal.no", "larvik.no", "lavagis.no", "lavangen.no", "leangaviika.no", "leagaviika.no", "lebesby.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "lerdal.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindas.no", "linds.no", "lindesnes.no", "loabat.no", "loabt.no", "lodingen.no", "ldingen.no", "lom.no", "loppa.no", "lorenskog.no", "lrenskog.no", "loten.no", "lten.no", "lund.no", "lunner.no", "luroy.no", "lury.no", "luster.no", "lyngdal.no", "lyngen.no", "malatvuopmi.no", "mlatvuopmi.no", "malselv.no", "mlselv.no", "malvik.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "masoy.no", "msy.no", "matta-varjjat.no", "mtta-vrjjat.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "mely.no", "meraker.no", "merker.no", "midsund.no", "midtre-gauldal.no", "moareke.no", "moreke.no", "modalen.no", "modum.no", "molde.no", "heroy.more-og-romsdal.no", "sande.more-og-romsdal.no", "hery.mre-og-romsdal.no", "sande.mre-og-romsdal.no", "moskenes.no", "moss.no", "mosvik.no", "muosat.no", "muost.no", "naamesjevuemie.no", "nmesjevuemie.no", "nry.no", "namdalseid.no", "namsos.no", "namsskogan.no", "nannestad.no", "naroy.no", "narviika.no", "narvik.no", "naustdal.no", "navuotna.no", "nvuotna.no", "nedre-eiker.no", "nesna.no", "nesodden.no", "nesseby.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "bo.nordland.no", "b.nordland.no", "heroy.nordland.no", "hery.nordland.no", "nordre-land.no", "nordreisa.no", "nore-og-uvdal.no", "notodden.no", "notteroy.no", "nttery.no", "odda.no", "oksnes.no", "ksnes.no", "omasvuotna.no", "oppdal.no", "oppegard.no", "oppegrd.no", "orkdal.no", "orland.no", "rland.no", "orskog.no", "rskog.no", "orsta.no", "rsta.no", "osen.no", "osteroy.no", "ostery.no", "valer.ostfold.no", "vler.stfold.no", "ostre-toten.no", "stre-toten.no", "overhalla.no", "ovre-eiker.no", "vre-eiker.no", "oyer.no", "yer.no", "oygarden.no", "ygarden.no", "oystre-slidre.no", "ystre-slidre.no", "porsanger.no", "porsangu.no", "porsgu.no", "porsgrunn.no", "rade.no", "rde.no", "radoy.no", "rady.no", "rlingen.no", "rahkkeravju.no", "rhkkervju.no", "raisa.no", "risa.no", "rakkestad.no", "ralingen.no", "rana.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesy.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "risor.no", "risr.no", "rissa.no", "roan.no", "rodoy.no", "rdy.no", "rollag.no", "romsa.no", "romskog.no", "rmskog.no", "roros.no", "rros.no", "rost.no", "rst.no", "royken.no", "ryken.no", "royrvik.no", "ryrvik.no", "ruovat.no", "rygge.no", "salangen.no", "salat.no", "slat.no", "slt.no", "saltdal.no", "samnanger.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandy.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "siellak.no", "sigdal.no", "siljan.no", "sirdal.no", "skanit.no", "sknit.no", "skanland.no", "sknland.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skierva.no", "skierv.no", "skiptvet.no", "skjak.no", "skjk.no", "skjervoy.no", "skjervy.no", "skodje.no", "smola.no", "smla.no", "snaase.no", "snase.no", "snasa.no", "snsa.no", "snillfjord.no", "snoasa.no", "sogndal.no", "sogne.no", "sgne.no", "sokndal.no", "sola.no", "solund.no", "somna.no", "smna.no", "sondre-land.no", "sndre-land.no", "songdalen.no", "sor-aurdal.no", "sr-aurdal.no", "sor-fron.no", "sr-fron.no", "sor-odal.no", "sr-odal.no", "sor-varanger.no", "sr-varanger.no", "sorfold.no", "srfold.no", "sorreisa.no", "srreisa.no", "sortland.no", "sorum.no", "srum.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjrdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "tana.no", "bo.telemark.no", "b.telemark.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "tjome.no", "tjme.no", "tokke.no", "tolga.no", "tonsberg.no", "tnsberg.no", "torsken.no", "trna.no", "trana.no", "tranoy.no", "trany.no", "troandin.no", "trogstad.no", "trgstad.no", "tromsa.no", "tromso.no", "troms.no", "trondheim.no", "trysil.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "tysnes.no", "tysvr.no", "tysvar.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "unjarga.no", "unjrga.no", "utsira.no", "vaapste.no", "vadso.no", "vads.no", "vry.no", "vaga.no", "vg.no", "vagan.no", "vgan.no", "vagsoy.no", "vgsy.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vard.no", "varggat.no", "vrggt.no", "varoy.no", "vefsn.no", "vega.no", "vegarshei.no", "vegrshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "sande.vestfold.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvgy.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "voagat.no", "volda.no", "voss.no", "*.np", "nr", "biz.nr", "com.nr", "edu.nr", "gov.nr", "info.nr", "net.nr", "org.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "mori.nz", "mil.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "abo.pa", "ac.pa", "com.pa", "edu.pa", "gob.pa", "ing.pa", "med.pa", "net.pa", "nom.pa", "org.pa", "sld.pa", "pe", "com.pe", "edu.pe", "gob.pe", "mil.pe", "net.pe", "nom.pe", "org.pe", "pf", "com.pf", "edu.pf", "org.pf", "*.pg", "ph", "com.ph", "edu.ph", "gov.ph", "i.ph", "mil.ph", "net.ph", "ngo.ph", "org.ph", "pk", "ac.pk", "biz.pk", "com.pk", "edu.pk", "fam.pk", "gkp.pk", "gob.pk", "gog.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "gov.pk", "net.pk", "org.pk", "web.pk", "pl", "com.pl", "net.pl", "org.pl", "agro.pl", "aid.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "media.pl", "miasta.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "griw.gov.pl", "ic.gov.pl", "is.gov.pl", "kmpsp.gov.pl", "konsulat.gov.pl", "kppsp.gov.pl", "kwp.gov.pl", "kwpsp.gov.pl", "mup.gov.pl", "mw.gov.pl", "oia.gov.pl", "oirm.gov.pl", "oke.gov.pl", "oow.gov.pl", "oschr.gov.pl", "oum.gov.pl", "pa.gov.pl", "pinb.gov.pl", "piw.gov.pl", "po.gov.pl", "pr.gov.pl", "psp.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "sdn.gov.pl", "sko.gov.pl", "so.gov.pl", "sr.gov.pl", "starostwo.gov.pl", "ug.gov.pl", "ugim.gov.pl", "um.gov.pl", "umig.gov.pl", "upow.gov.pl", "uppo.gov.pl", "us.gov.pl", "uw.gov.pl", "uzs.gov.pl", "wif.gov.pl", "wiih.gov.pl", "winb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wiw.gov.pl", "wkz.gov.pl", "wsa.gov.pl", "wskr.gov.pl", "wsse.gov.pl", "wuoz.gov.pl", "wzmiuw.gov.pl", "zp.gov.pl", "zpisdn.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kazimierz-dolny.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorskie.pl", "pomorze.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "skoczow.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "co.pn", "edu.pn", "gov.pn", "net.pn", "org.pn", "post", "pr", "biz.pr", "com.pr", "edu.pr", "gov.pr", "info.pr", "isla.pr", "name.pr", "net.pr", "org.pr", "pro.pr", "ac.pr", "est.pr", "prof.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "com.ps", "edu.ps", "gov.ps", "net.ps", "org.ps", "plo.ps", "sec.ps", "pt", "com.pt", "edu.pt", "gov.pt", "int.pt", "net.pt", "nome.pt", "org.pt", "publ.pt", "pw", "belau.pw", "co.pw", "ed.pw", "go.pw", "or.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "edu.sa", "gov.sa", "med.sa", "net.sa", "org.sa", "pub.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "edu.sc", "gov.sc", "net.sc", "org.sc", "sd", "com.sd", "edu.sd", "gov.sd", "info.sd", "med.sd", "net.sd", "org.sd", "tv.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "edu.sg", "gov.sg", "net.sg", "org.sg", "sh", "com.sh", "gov.sh", "mil.sh", "net.sh", "org.sh", "si", "sj", "sk", "sl", "com.sl", "edu.sl", "gov.sl", "net.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "co.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "com.sy", "edu.sy", "gov.sy", "mil.sy", "net.sy", "org.sy", "sz", "ac.sz", "co.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "co.tm", "com.tm", "edu.tm", "gov.tm", "mil.tm", "net.tm", "nom.tm", "org.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "edu.to", "gov.to", "mil.to", "net.to", "org.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "k12.tr", "kep.tr", "mil.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "biz.tt", "co.tt", "com.tt", "edu.tt", "gov.tt", "info.tt", "mil.tt", "name.tt", "net.tt", "org.tt", "pro.tt", "tv", "tw", "club.tw", "com.tw", "ebiz.tw", "edu.tw", "game.tw", "gov.tw", "idv.tw", "mil.tw", "net.tw", "org.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "kropyvnytskyi.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "luhansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "uzhhorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zakarpattia.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "ac.ug", "co.ug", "com.ug", "go.ug", "ne.ug", "or.ug", "org.ug", "sc.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "va.us", "vi.us", "vt.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.va.us", "k12.vi.us", "k12.vt.us", "k12.wa.us", "k12.wi.us", "cc.ak.us", "lib.ak.us", "cc.al.us", "lib.al.us", "cc.ar.us", "lib.ar.us", "cc.as.us", "lib.as.us", "cc.az.us", "lib.az.us", "cc.ca.us", "lib.ca.us", "cc.co.us", "lib.co.us", "cc.ct.us", "lib.ct.us", "cc.dc.us", "lib.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.va.us", "cc.vi.us", "cc.vt.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "k12.wy.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.va.us", "lib.vi.us", "lib.vt.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "pvt.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "edu.vc", "gov.vc", "mil.vc", "net.vc", "org.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "ac.vn", "ai.vn", "biz.vn", "com.vn", "edu.vn", "gov.vn", "health.vn", "id.vn", "info.vn", "int.vn", "io.vn", "name.vn", "net.vn", "org.vn", "pro.vn", "angiang.vn", "bacgiang.vn", "backan.vn", "baclieu.vn", "bacninh.vn", "baria-vungtau.vn", "bentre.vn", "binhdinh.vn", "binhduong.vn", "binhphuoc.vn", "binhthuan.vn", "camau.vn", "cantho.vn", "caobang.vn", "daklak.vn", "daknong.vn", "danang.vn", "dienbien.vn", "dongnai.vn", "dongthap.vn", "gialai.vn", "hagiang.vn", "haiduong.vn", "haiphong.vn", "hanam.vn", "hanoi.vn", "hatinh.vn", "haugiang.vn", "hoabinh.vn", "hungyen.vn", "khanhhoa.vn", "kiengiang.vn", "kontum.vn", "laichau.vn", "lamdong.vn", "langson.vn", "laocai.vn", "longan.vn", "namdinh.vn", "nghean.vn", "ninhbinh.vn", "ninhthuan.vn", "phutho.vn", "phuyen.vn", "quangbinh.vn", "quangnam.vn", "quangngai.vn", "quangninh.vn", "quangtri.vn", "soctrang.vn", "sonla.vn", "tayninh.vn", "thaibinh.vn", "thainguyen.vn", "thanhhoa.vn", "thanhphohochiminh.vn", "thuathienhue.vn", "tiengiang.vn", "travinh.vn", "tuyenquang.vn", "vinhlong.vn", "vinhphuc.vn", "yenbai.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "edu.ws", "gov.ws", "net.ws", "org.ws", "yt", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ".", ".", ".", ".", ".", ".", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ".", ".", ".", ".", ".", ".", "", "", "", "", "", "", "", "", "", "", "", "", ".", ".", ".", ".", ".", ".", "", "", "", "", "", "", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "mil.ye", "net.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "aws", "axa", "azure", "baby", "baidu", "banamex", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merck", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "nab", "nagoya", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volvo", "vote", "voting", "voto", "voyage", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xihuan", "xin", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "vermgensberater", "vermgensberatung", "", "", "", "", "", "", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "co.krd", "edu.krd", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "lib.de.us", "12chars.dev", "12chars.it", "12chars.pro", "cc.ua", "inf.ua", "ltd.ua", "611.to", "a2hosted.com", "cpserver.com", "aaa.vodka", "*.on-acorn.io", "activetrail.biz", "adaptable.app", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "aem.live", "hlx.live", "adobeaemcloud.net", "aem.page", "hlx.page", "hlx3.page", "adobeio-static.net", "adobeioruntime.net", "africa.com", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "akadns.net", "akamai.net", "akamai-staging.net", "akamaiedge.net", "akamaiedge-staging.net", "akamaihd.net", "akamaihd-staging.net", "akamaiorigin.net", "akamaiorigin-staging.net", "akamaized.net", "akamaized-staging.net", "edgekey.net", "edgekey-staging.net", "edgesuite.net", "edgesuite-staging.net", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "myamaze.net", "execute-api.cn-north-1.amazonaws.com.cn", "execute-api.cn-northwest-1.amazonaws.com.cn", "execute-api.af-south-1.amazonaws.com", "execute-api.ap-east-1.amazonaws.com", "execute-api.ap-northeast-1.amazonaws.com", "execute-api.ap-northeast-2.amazonaws.com", "execute-api.ap-northeast-3.amazonaws.com", "execute-api.ap-south-1.amazonaws.com", "execute-api.ap-south-2.amazonaws.com", "execute-api.ap-southeast-1.amazonaws.com", "execute-api.ap-southeast-2.amazonaws.com", "execute-api.ap-southeast-3.amazonaws.com", "execute-api.ap-southeast-4.amazonaws.com", "execute-api.ap-southeast-5.amazonaws.com", "execute-api.ca-central-1.amazonaws.com", "execute-api.ca-west-1.amazonaws.com", "execute-api.eu-central-1.amazonaws.com", "execute-api.eu-central-2.amazonaws.com", "execute-api.eu-north-1.amazonaws.com", "execute-api.eu-south-1.amazonaws.com", "execute-api.eu-south-2.amazonaws.com", "execute-api.eu-west-1.amazonaws.com", "execute-api.eu-west-2.amazonaws.com", "execute-api.eu-west-3.amazonaws.com", "execute-api.il-central-1.amazonaws.com", "execute-api.me-central-1.amazonaws.com", "execute-api.me-south-1.amazonaws.com", "execute-api.sa-east-1.amazonaws.com", "execute-api.us-east-1.amazonaws.com", "execute-api.us-east-2.amazonaws.com", "execute-api.us-gov-east-1.amazonaws.com", "execute-api.us-gov-west-1.amazonaws.com", "execute-api.us-west-1.amazonaws.com", "execute-api.us-west-2.amazonaws.com", "cloudfront.net", "auth.af-south-1.amazoncognito.com", "auth.ap-east-1.amazoncognito.com", "auth.ap-northeast-1.amazoncognito.com", "auth.ap-northeast-2.amazoncognito.com", "auth.ap-northeast-3.amazoncognito.com", "auth.ap-south-1.amazoncognito.com", "auth.ap-south-2.amazoncognito.com", "auth.ap-southeast-1.amazoncognito.com", "auth.ap-southeast-2.amazoncognito.com", "auth.ap-southeast-3.amazoncognito.com", "auth.ap-southeast-4.amazoncognito.com", "auth.ca-central-1.amazoncognito.com", "auth.ca-west-1.amazoncognito.com", "auth.eu-central-1.amazoncognito.com", "auth.eu-central-2.amazoncognito.com", "auth.eu-north-1.amazoncognito.com", "auth.eu-south-1.amazoncognito.com", "auth.eu-south-2.amazoncognito.com", "auth.eu-west-1.amazoncognito.com", "auth.eu-west-2.amazoncognito.com", "auth.eu-west-3.amazoncognito.com", "auth.il-central-1.amazoncognito.com", "auth.me-central-1.amazoncognito.com", "auth.me-south-1.amazoncognito.com", "auth.sa-east-1.amazoncognito.com", "auth.us-east-1.amazoncognito.com", "auth-fips.us-east-1.amazoncognito.com", "auth.us-east-2.amazoncognito.com", "auth-fips.us-east-2.amazoncognito.com", "auth-fips.us-gov-west-1.amazoncognito.com", "auth.us-west-1.amazoncognito.com", "auth-fips.us-west-1.amazoncognito.com", "auth.us-west-2.amazoncognito.com", "auth-fips.us-west-2.amazoncognito.com", "*.compute.amazonaws.com.cn", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "us-east-1.amazonaws.com", "emrappui-prod.cn-north-1.amazonaws.com.cn", "emrnotebooks-prod.cn-north-1.amazonaws.com.cn", "emrstudio-prod.cn-north-1.amazonaws.com.cn", "emrappui-prod.cn-northwest-1.amazonaws.com.cn", "emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn", "emrstudio-prod.cn-northwest-1.amazonaws.com.cn", "emrappui-prod.af-south-1.amazonaws.com", "emrnotebooks-prod.af-south-1.amazonaws.com", "emrstudio-prod.af-south-1.amazonaws.com", "emrappui-prod.ap-east-1.amazonaws.com", "emrnotebooks-prod.ap-east-1.amazonaws.com", "emrstudio-prod.ap-east-1.amazonaws.com", "emrappui-prod.ap-northeast-1.amazonaws.com", "emrnotebooks-prod.ap-northeast-1.amazonaws.com", "emrstudio-prod.ap-northeast-1.amazonaws.com", "emrappui-prod.ap-northeast-2.amazonaws.com", "emrnotebooks-prod.ap-northeast-2.amazonaws.com", "emrstudio-prod.ap-northeast-2.amazonaws.com", "emrappui-prod.ap-northeast-3.amazonaws.com", "emrnotebooks-prod.ap-northeast-3.amazonaws.com", "emrstudio-prod.ap-northeast-3.amazonaws.com", "emrappui-prod.ap-south-1.amazonaws.com", "emrnotebooks-prod.ap-south-1.amazonaws.com", "emrstudio-prod.ap-south-1.amazonaws.com", "emrappui-prod.ap-south-2.amazonaws.com", "emrnotebooks-prod.ap-south-2.amazonaws.com", "emrstudio-prod.ap-south-2.amazonaws.com", "emrappui-prod.ap-southeast-1.amazonaws.com", "emrnotebooks-prod.ap-southeast-1.amazonaws.com", "emrstudio-prod.ap-southeast-1.amazonaws.com", "emrappui-prod.ap-southeast-2.amazonaws.com", "emrnotebooks-prod.ap-southeast-2.amazonaws.com", "emrstudio-prod.ap-southeast-2.amazonaws.com", "emrappui-prod.ap-southeast-3.amazonaws.com", "emrnotebooks-prod.ap-southeast-3.amazonaws.com", "emrstudio-prod.ap-southeast-3.amazonaws.com", "emrappui-prod.ap-southeast-4.amazonaws.com", "emrnotebooks-prod.ap-southeast-4.amazonaws.com", "emrstudio-prod.ap-southeast-4.amazonaws.com", "emrappui-prod.ca-central-1.amazonaws.com", "emrnotebooks-prod.ca-central-1.amazonaws.com", "emrstudio-prod.ca-central-1.amazonaws.com", "emrappui-prod.ca-west-1.amazonaws.com", "emrnotebooks-prod.ca-west-1.amazonaws.com", "emrstudio-prod.ca-west-1.amazonaws.com", "emrappui-prod.eu-central-1.amazonaws.com", "emrnotebooks-prod.eu-central-1.amazonaws.com", "emrstudio-prod.eu-central-1.amazonaws.com", "emrappui-prod.eu-central-2.amazonaws.com", "emrnotebooks-prod.eu-central-2.amazonaws.com", "emrstudio-prod.eu-central-2.amazonaws.com", "emrappui-prod.eu-north-1.amazonaws.com", "emrnotebooks-prod.eu-north-1.amazonaws.com", "emrstudio-prod.eu-north-1.amazonaws.com", "emrappui-prod.eu-south-1.amazonaws.com", "emrnotebooks-prod.eu-south-1.amazonaws.com", "emrstudio-prod.eu-south-1.amazonaws.com", "emrappui-prod.eu-south-2.amazonaws.com", "emrnotebooks-prod.eu-south-2.amazonaws.com", "emrstudio-prod.eu-south-2.amazonaws.com", "emrappui-prod.eu-west-1.amazonaws.com", "emrnotebooks-prod.eu-west-1.amazonaws.com", "emrstudio-prod.eu-west-1.amazonaws.com", "emrappui-prod.eu-west-2.amazonaws.com", "emrnotebooks-prod.eu-west-2.amazonaws.com", "emrstudio-prod.eu-west-2.amazonaws.com", "emrappui-prod.eu-west-3.amazonaws.com", "emrnotebooks-prod.eu-west-3.amazonaws.com", "emrstudio-prod.eu-west-3.amazonaws.com", "emrappui-prod.il-central-1.amazonaws.com", "emrnotebooks-prod.il-central-1.amazonaws.com", "emrstudio-prod.il-central-1.amazonaws.com", "emrappui-prod.me-central-1.amazonaws.com", "emrnotebooks-prod.me-central-1.amazonaws.com", "emrstudio-prod.me-central-1.amazonaws.com", "emrappui-prod.me-south-1.amazonaws.com", "emrnotebooks-prod.me-south-1.amazonaws.com", "emrstudio-prod.me-south-1.amazonaws.com", "emrappui-prod.sa-east-1.amazonaws.com", "emrnotebooks-prod.sa-east-1.amazonaws.com", "emrstudio-prod.sa-east-1.amazonaws.com", "emrappui-prod.us-east-1.amazonaws.com", "emrnotebooks-prod.us-east-1.amazonaws.com", "emrstudio-prod.us-east-1.amazonaws.com", "emrappui-prod.us-east-2.amazonaws.com", "emrnotebooks-prod.us-east-2.amazonaws.com", "emrstudio-prod.us-east-2.amazonaws.com", "emrappui-prod.us-gov-east-1.amazonaws.com", "emrnotebooks-prod.us-gov-east-1.amazonaws.com", "emrstudio-prod.us-gov-east-1.amazonaws.com", "emrappui-prod.us-gov-west-1.amazonaws.com", "emrnotebooks-prod.us-gov-west-1.amazonaws.com", "emrstudio-prod.us-gov-west-1.amazonaws.com", "emrappui-prod.us-west-1.amazonaws.com", "emrnotebooks-prod.us-west-1.amazonaws.com", "emrstudio-prod.us-west-1.amazonaws.com", "emrappui-prod.us-west-2.amazonaws.com", "emrnotebooks-prod.us-west-2.amazonaws.com", "emrstudio-prod.us-west-2.amazonaws.com", "*.cn-north-1.airflow.amazonaws.com.cn", "*.cn-northwest-1.airflow.amazonaws.com.cn", "*.af-south-1.airflow.amazonaws.com", "*.ap-east-1.airflow.amazonaws.com", "*.ap-northeast-1.airflow.amazonaws.com", "*.ap-northeast-2.airflow.amazonaws.com", "*.ap-northeast-3.airflow.amazonaws.com", "*.ap-south-1.airflow.amazonaws.com", "*.ap-south-2.airflow.amazonaws.com", "*.ap-southeast-1.airflow.amazonaws.com", "*.ap-southeast-2.airflow.amazonaws.com", "*.ap-southeast-3.airflow.amazonaws.com", "*.ap-southeast-4.airflow.amazonaws.com", "*.ca-central-1.airflow.amazonaws.com", "*.ca-west-1.airflow.amazonaws.com", "*.eu-central-1.airflow.amazonaws.com", "*.eu-central-2.airflow.amazonaws.com", "*.eu-north-1.airflow.amazonaws.com", "*.eu-south-1.airflow.amazonaws.com", "*.eu-south-2.airflow.amazonaws.com", "*.eu-west-1.airflow.amazonaws.com", "*.eu-west-2.airflow.amazonaws.com", "*.eu-west-3.airflow.amazonaws.com", "*.il-central-1.airflow.amazonaws.com", "*.me-central-1.airflow.amazonaws.com", "*.me-south-1.airflow.amazonaws.com", "*.sa-east-1.airflow.amazonaws.com", "*.us-east-1.airflow.amazonaws.com", "*.us-east-2.airflow.amazonaws.com", "*.us-west-1.airflow.amazonaws.com", "*.us-west-2.airflow.amazonaws.com", "s3.dualstack.cn-north-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn", "s3-website.dualstack.cn-north-1.amazonaws.com.cn", "s3.cn-north-1.amazonaws.com.cn", "s3-accesspoint.cn-north-1.amazonaws.com.cn", "s3-deprecated.cn-north-1.amazonaws.com.cn", "s3-object-lambda.cn-north-1.amazonaws.com.cn", "s3-website.cn-north-1.amazonaws.com.cn", "s3.dualstack.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn", "s3.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.cn-northwest-1.amazonaws.com.cn", "s3-object-lambda.cn-northwest-1.amazonaws.com.cn", "s3-website.cn-northwest-1.amazonaws.com.cn", "s3.dualstack.af-south-1.amazonaws.com", "s3-accesspoint.dualstack.af-south-1.amazonaws.com", "s3-website.dualstack.af-south-1.amazonaws.com", "s3.af-south-1.amazonaws.com", "s3-accesspoint.af-south-1.amazonaws.com", "s3-object-lambda.af-south-1.amazonaws.com", "s3-website.af-south-1.amazonaws.com", "s3.dualstack.ap-east-1.amazonaws.com", "s3-accesspoint.dualstack.ap-east-1.amazonaws.com", "s3.ap-east-1.amazonaws.com", "s3-accesspoint.ap-east-1.amazonaws.com", "s3-object-lambda.ap-east-1.amazonaws.com", "s3-website.ap-east-1.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com", "s3-website.dualstack.ap-northeast-1.amazonaws.com", "s3.ap-northeast-1.amazonaws.com", "s3-accesspoint.ap-northeast-1.amazonaws.com", "s3-object-lambda.ap-northeast-1.amazonaws.com", "s3-website.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com", "s3-website.dualstack.ap-northeast-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3-accesspoint.ap-northeast-2.amazonaws.com", "s3-object-lambda.ap-northeast-2.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-northeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com", "s3-website.dualstack.ap-northeast-3.amazonaws.com", "s3.ap-northeast-3.amazonaws.com", "s3-accesspoint.ap-northeast-3.amazonaws.com", "s3-object-lambda.ap-northeast-3.amazonaws.com", "s3-website.ap-northeast-3.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3-accesspoint.dualstack.ap-south-1.amazonaws.com", "s3-website.dualstack.ap-south-1.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3-accesspoint.ap-south-1.amazonaws.com", "s3-object-lambda.ap-south-1.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3.dualstack.ap-south-2.amazonaws.com", "s3-accesspoint.dualstack.ap-south-2.amazonaws.com", "s3-website.dualstack.ap-south-2.amazonaws.com", "s3.ap-south-2.amazonaws.com", "s3-accesspoint.ap-south-2.amazonaws.com", "s3-object-lambda.ap-south-2.amazonaws.com", "s3-website.ap-south-2.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com", "s3-website.dualstack.ap-southeast-1.amazonaws.com", "s3.ap-southeast-1.amazonaws.com", "s3-accesspoint.ap-southeast-1.amazonaws.com", "s3-object-lambda.ap-southeast-1.amazonaws.com", "s3-website.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com", "s3-website.dualstack.ap-southeast-2.amazonaws.com", "s3.ap-southeast-2.amazonaws.com", "s3-accesspoint.ap-southeast-2.amazonaws.com", "s3-object-lambda.ap-southeast-2.amazonaws.com", "s3-website.ap-southeast-2.amazonaws.com", "s3.dualstack.ap-southeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com", "s3-website.dualstack.ap-southeast-3.amazonaws.com", "s3.ap-southeast-3.amazonaws.com", "s3-accesspoint.ap-southeast-3.amazonaws.com", "s3-object-lambda.ap-southeast-3.amazonaws.com", "s3-website.ap-southeast-3.amazonaws.com", "s3.dualstack.ap-southeast-4.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com", "s3-website.dualstack.ap-southeast-4.amazonaws.com", "s3.ap-southeast-4.amazonaws.com", "s3-accesspoint.ap-southeast-4.amazonaws.com", "s3-object-lambda.ap-southeast-4.amazonaws.com", "s3-website.ap-southeast-4.amazonaws.com", "s3.dualstack.ap-southeast-5.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com", "s3-website.dualstack.ap-southeast-5.amazonaws.com", "s3.ap-southeast-5.amazonaws.com", "s3-accesspoint.ap-southeast-5.amazonaws.com", "s3-deprecated.ap-southeast-5.amazonaws.com", "s3-object-lambda.ap-southeast-5.amazonaws.com", "s3-website.ap-southeast-5.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com", "s3-fips.dualstack.ca-central-1.amazonaws.com", "s3-website.dualstack.ca-central-1.amazonaws.com", "s3.ca-central-1.amazonaws.com", "s3-accesspoint.ca-central-1.amazonaws.com", "s3-accesspoint-fips.ca-central-1.amazonaws.com", "s3-fips.ca-central-1.amazonaws.com", "s3-object-lambda.ca-central-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com", "s3-fips.dualstack.ca-west-1.amazonaws.com", "s3-website.dualstack.ca-west-1.amazonaws.com", "s3.ca-west-1.amazonaws.com", "s3-accesspoint.ca-west-1.amazonaws.com", "s3-accesspoint-fips.ca-west-1.amazonaws.com", "s3-fips.ca-west-1.amazonaws.com", "s3-object-lambda.ca-west-1.amazonaws.com", "s3-website.ca-west-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3-accesspoint.dualstack.eu-central-1.amazonaws.com", "s3-website.dualstack.eu-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3-accesspoint.eu-central-1.amazonaws.com", "s3-object-lambda.eu-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3.dualstack.eu-central-2.amazonaws.com", "s3-accesspoint.dualstack.eu-central-2.amazonaws.com", "s3-website.dualstack.eu-central-2.amazonaws.com", "s3.eu-central-2.amazonaws.com", "s3-accesspoint.eu-central-2.amazonaws.com", "s3-object-lambda.eu-central-2.amazonaws.com", "s3-website.eu-central-2.amazonaws.com", "s3.dualstack.eu-north-1.amazonaws.com", "s3-accesspoint.dualstack.eu-north-1.amazonaws.com", "s3.eu-north-1.amazonaws.com", "s3-accesspoint.eu-north-1.amazonaws.com", "s3-object-lambda.eu-north-1.amazonaws.com", "s3-website.eu-north-1.amazonaws.com", "s3.dualstack.eu-south-1.amazonaws.com", "s3-accesspoint.dualstack.eu-south-1.amazonaws.com", "s3-website.dualstack.eu-south-1.amazonaws.com", "s3.eu-south-1.amazonaws.com", "s3-accesspoint.eu-south-1.amazonaws.com", "s3-object-lambda.eu-south-1.amazonaws.com", "s3-website.eu-south-1.amazonaws.com", "s3.dualstack.eu-south-2.amazonaws.com", "s3-accesspoint.dualstack.eu-south-2.amazonaws.com", "s3-website.dualstack.eu-south-2.amazonaws.com", "s3.eu-south-2.amazonaws.com", "s3-accesspoint.eu-south-2.amazonaws.com", "s3-object-lambda.eu-south-2.amazonaws.com", "s3-website.eu-south-2.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3-accesspoint.dualstack.eu-west-1.amazonaws.com", "s3-website.dualstack.eu-west-1.amazonaws.com", "s3.eu-west-1.amazonaws.com", "s3-accesspoint.eu-west-1.amazonaws.com", "s3-deprecated.eu-west-1.amazonaws.com", "s3-object-lambda.eu-west-1.amazonaws.com", "s3-website.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3-accesspoint.dualstack.eu-west-2.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3-accesspoint.eu-west-2.amazonaws.com", "s3-object-lambda.eu-west-2.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3-accesspoint.dualstack.eu-west-3.amazonaws.com", "s3-website.dualstack.eu-west-3.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3-accesspoint.eu-west-3.amazonaws.com", "s3-object-lambda.eu-west-3.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3.dualstack.il-central-1.amazonaws.com", "s3-accesspoint.dualstack.il-central-1.amazonaws.com", "s3-website.dualstack.il-central-1.amazonaws.com", "s3.il-central-1.amazonaws.com", "s3-accesspoint.il-central-1.amazonaws.com", "s3-object-lambda.il-central-1.amazonaws.com", "s3-website.il-central-1.amazonaws.com", "s3.dualstack.me-central-1.amazonaws.com", "s3-accesspoint.dualstack.me-central-1.amazonaws.com", "s3-website.dualstack.me-central-1.amazonaws.com", "s3.me-central-1.amazonaws.com", "s3-accesspoint.me-central-1.amazonaws.com", "s3-object-lambda.me-central-1.amazonaws.com", "s3-website.me-central-1.amazonaws.com", "s3.dualstack.me-south-1.amazonaws.com", "s3-accesspoint.dualstack.me-south-1.amazonaws.com", "s3.me-south-1.amazonaws.com", "s3-accesspoint.me-south-1.amazonaws.com", "s3-object-lambda.me-south-1.amazonaws.com", "s3-website.me-south-1.amazonaws.com", "s3.amazonaws.com", "s3-1.amazonaws.com", "s3-ap-east-1.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-northeast-3.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-north-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-east-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "mrap.accesspoint.s3-global.amazonaws.com", "s3-me-south-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-gov-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-gov-west-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3-accesspoint.dualstack.sa-east-1.amazonaws.com", "s3-website.dualstack.sa-east-1.amazonaws.com", "s3.sa-east-1.amazonaws.com", "s3-accesspoint.sa-east-1.amazonaws.com", "s3-object-lambda.sa-east-1.amazonaws.com", "s3-website.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com", "s3-fips.dualstack.us-east-1.amazonaws.com", "s3-website.dualstack.us-east-1.amazonaws.com", "s3.us-east-1.amazonaws.com", "s3-accesspoint.us-east-1.amazonaws.com", "s3-accesspoint-fips.us-east-1.amazonaws.com", "s3-deprecated.us-east-1.amazonaws.com", "s3-fips.us-east-1.amazonaws.com", "s3-object-lambda.us-east-1.amazonaws.com", "s3-website.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-accesspoint.dualstack.us-east-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com", "s3-fips.dualstack.us-east-2.amazonaws.com", "s3-website.dualstack.us-east-2.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3-accesspoint.us-east-2.amazonaws.com", "s3-accesspoint-fips.us-east-2.amazonaws.com", "s3-deprecated.us-east-2.amazonaws.com", "s3-fips.us-east-2.amazonaws.com", "s3-object-lambda.us-east-2.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "s3.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com", "s3-fips.dualstack.us-gov-east-1.amazonaws.com", "s3.us-gov-east-1.amazonaws.com", "s3-accesspoint.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.us-gov-east-1.amazonaws.com", "s3-fips.us-gov-east-1.amazonaws.com", "s3-object-lambda.us-gov-east-1.amazonaws.com", "s3-website.us-gov-east-1.amazonaws.com", "s3.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com", "s3-fips.dualstack.us-gov-west-1.amazonaws.com", "s3.us-gov-west-1.amazonaws.com", "s3-accesspoint.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.us-gov-west-1.amazonaws.com", "s3-fips.us-gov-west-1.amazonaws.com", "s3-object-lambda.us-gov-west-1.amazonaws.com", "s3-website.us-gov-west-1.amazonaws.com", "s3.dualstack.us-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com", "s3-fips.dualstack.us-west-1.amazonaws.com", "s3-website.dualstack.us-west-1.amazonaws.com", "s3.us-west-1.amazonaws.com", "s3-accesspoint.us-west-1.amazonaws.com", "s3-accesspoint-fips.us-west-1.amazonaws.com", "s3-fips.us-west-1.amazonaws.com", "s3-object-lambda.us-west-1.amazonaws.com", "s3-website.us-west-1.amazonaws.com", "s3.dualstack.us-west-2.amazonaws.com", "s3-accesspoint.dualstack.us-west-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com", "s3-fips.dualstack.us-west-2.amazonaws.com", "s3-website.dualstack.us-west-2.amazonaws.com", "s3.us-west-2.amazonaws.com", "s3-accesspoint.us-west-2.amazonaws.com", "s3-accesspoint-fips.us-west-2.amazonaws.com", "s3-deprecated.us-west-2.amazonaws.com", "s3-fips.us-west-2.amazonaws.com", "s3-object-lambda.us-west-2.amazonaws.com", "s3-website.us-west-2.amazonaws.com", "labeling.ap-northeast-1.sagemaker.aws", "labeling.ap-northeast-2.sagemaker.aws", "labeling.ap-south-1.sagemaker.aws", "labeling.ap-southeast-1.sagemaker.aws", "labeling.ap-southeast-2.sagemaker.aws", "labeling.ca-central-1.sagemaker.aws", "labeling.eu-central-1.sagemaker.aws", "labeling.eu-west-1.sagemaker.aws", "labeling.eu-west-2.sagemaker.aws", "labeling.us-east-1.sagemaker.aws", "labeling.us-east-2.sagemaker.aws", "labeling.us-west-2.sagemaker.aws", "notebook.af-south-1.sagemaker.aws", "notebook.ap-east-1.sagemaker.aws", "notebook.ap-northeast-1.sagemaker.aws", "notebook.ap-northeast-2.sagemaker.aws", "notebook.ap-northeast-3.sagemaker.aws", "notebook.ap-south-1.sagemaker.aws", "notebook.ap-south-2.sagemaker.aws", "notebook.ap-southeast-1.sagemaker.aws", "notebook.ap-southeast-2.sagemaker.aws", "notebook.ap-southeast-3.sagemaker.aws", "notebook.ap-southeast-4.sagemaker.aws", "notebook.ca-central-1.sagemaker.aws", "notebook-fips.ca-central-1.sagemaker.aws", "notebook.ca-west-1.sagemaker.aws", "notebook-fips.ca-west-1.sagemaker.aws", "notebook.eu-central-1.sagemaker.aws", "notebook.eu-central-2.sagemaker.aws", "notebook.eu-north-1.sagemaker.aws", "notebook.eu-south-1.sagemaker.aws", "notebook.eu-south-2.sagemaker.aws", "notebook.eu-west-1.sagemaker.aws", "notebook.eu-west-2.sagemaker.aws", "notebook.eu-west-3.sagemaker.aws", "notebook.il-central-1.sagemaker.aws", "notebook.me-central-1.sagemaker.aws", "notebook.me-south-1.sagemaker.aws", "notebook.sa-east-1.sagemaker.aws", "notebook.us-east-1.sagemaker.aws", "notebook-fips.us-east-1.sagemaker.aws", "notebook.us-east-2.sagemaker.aws", "notebook-fips.us-east-2.sagemaker.aws", "notebook.us-gov-east-1.sagemaker.aws", "notebook-fips.us-gov-east-1.sagemaker.aws", "notebook.us-gov-west-1.sagemaker.aws", "notebook-fips.us-gov-west-1.sagemaker.aws", "notebook.us-west-1.sagemaker.aws", "notebook-fips.us-west-1.sagemaker.aws", "notebook.us-west-2.sagemaker.aws", "notebook-fips.us-west-2.sagemaker.aws", "notebook.cn-north-1.sagemaker.com.cn", "notebook.cn-northwest-1.sagemaker.com.cn", "studio.af-south-1.sagemaker.aws", "studio.ap-east-1.sagemaker.aws", "studio.ap-northeast-1.sagemaker.aws", "studio.ap-northeast-2.sagemaker.aws", "studio.ap-northeast-3.sagemaker.aws", "studio.ap-south-1.sagemaker.aws", "studio.ap-southeast-1.sagemaker.aws", "studio.ap-southeast-2.sagemaker.aws", "studio.ap-southeast-3.sagemaker.aws", "studio.ca-central-1.sagemaker.aws", "studio.eu-central-1.sagemaker.aws", "studio.eu-north-1.sagemaker.aws", "studio.eu-south-1.sagemaker.aws", "studio.eu-south-2.sagemaker.aws", "studio.eu-west-1.sagemaker.aws", "studio.eu-west-2.sagemaker.aws", "studio.eu-west-3.sagemaker.aws", "studio.il-central-1.sagemaker.aws", "studio.me-central-1.sagemaker.aws", "studio.me-south-1.sagemaker.aws", "studio.sa-east-1.sagemaker.aws", "studio.us-east-1.sagemaker.aws", "studio.us-east-2.sagemaker.aws", "studio.us-gov-east-1.sagemaker.aws", "studio-fips.us-gov-east-1.sagemaker.aws", "studio.us-gov-west-1.sagemaker.aws", "studio-fips.us-gov-west-1.sagemaker.aws", "studio.us-west-1.sagemaker.aws", "studio.us-west-2.sagemaker.aws", "studio.cn-north-1.sagemaker.com.cn", "studio.cn-northwest-1.sagemaker.com.cn", "*.experiments.sagemaker.aws", "analytics-gateway.ap-northeast-1.amazonaws.com", "analytics-gateway.ap-northeast-2.amazonaws.com", "analytics-gateway.ap-south-1.amazonaws.com", "analytics-gateway.ap-southeast-1.amazonaws.com", "analytics-gateway.ap-southeast-2.amazonaws.com", "analytics-gateway.eu-central-1.amazonaws.com", "analytics-gateway.eu-west-1.amazonaws.com", "analytics-gateway.us-east-1.amazonaws.com", "analytics-gateway.us-east-2.amazonaws.com", "analytics-gateway.us-west-2.amazonaws.com", "amplifyapp.com", "*.awsapprunner.com", "webview-assets.aws-cloud9.af-south-1.amazonaws.com", "vfs.cloud9.af-south-1.amazonaws.com", "webview-assets.cloud9.af-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-east-1.amazonaws.com", "vfs.cloud9.ap-east-1.amazonaws.com", "webview-assets.cloud9.ap-east-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com", "vfs.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com", "vfs.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com", "vfs.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.aws-cloud9.ap-south-1.amazonaws.com", "vfs.cloud9.ap-south-1.amazonaws.com", "webview-assets.cloud9.ap-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com", "vfs.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com", "vfs.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.aws-cloud9.ca-central-1.amazonaws.com", "vfs.cloud9.ca-central-1.amazonaws.com", "webview-assets.cloud9.ca-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-central-1.amazonaws.com", "vfs.cloud9.eu-central-1.amazonaws.com", "webview-assets.cloud9.eu-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-north-1.amazonaws.com", "vfs.cloud9.eu-north-1.amazonaws.com", "webview-assets.cloud9.eu-north-1.amazonaws.com", "webview-assets.aws-cloud9.eu-south-1.amazonaws.com", "vfs.cloud9.eu-south-1.amazonaws.com", "webview-assets.cloud9.eu-south-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-1.amazonaws.com", "vfs.cloud9.eu-west-1.amazonaws.com", "webview-assets.cloud9.eu-west-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-2.amazonaws.com", "vfs.cloud9.eu-west-2.amazonaws.com", "webview-assets.cloud9.eu-west-2.amazonaws.com", "webview-assets.aws-cloud9.eu-west-3.amazonaws.com", "vfs.cloud9.eu-west-3.amazonaws.com", "webview-assets.cloud9.eu-west-3.amazonaws.com", "webview-assets.aws-cloud9.il-central-1.amazonaws.com", "vfs.cloud9.il-central-1.amazonaws.com", "webview-assets.aws-cloud9.me-south-1.amazonaws.com", "vfs.cloud9.me-south-1.amazonaws.com", "webview-assets.cloud9.me-south-1.amazonaws.com", "webview-assets.aws-cloud9.sa-east-1.amazonaws.com", "vfs.cloud9.sa-east-1.amazonaws.com", "webview-assets.cloud9.sa-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-1.amazonaws.com", "vfs.cloud9.us-east-1.amazonaws.com", "webview-assets.cloud9.us-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-2.amazonaws.com", "vfs.cloud9.us-east-2.amazonaws.com", "webview-assets.cloud9.us-east-2.amazonaws.com", "webview-assets.aws-cloud9.us-west-1.amazonaws.com", "vfs.cloud9.us-west-1.amazonaws.com", "webview-assets.cloud9.us-west-1.amazonaws.com", "webview-assets.aws-cloud9.us-west-2.amazonaws.com", "vfs.cloud9.us-west-2.amazonaws.com", "webview-assets.cloud9.us-west-2.amazonaws.com", "awsapps.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "af-south-1.elasticbeanstalk.com", "ap-east-1.elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ap-southeast-3.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-north-1.elasticbeanstalk.com", "eu-south-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "il-central-1.elasticbeanstalk.com", "me-south-1.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-east-1.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com.cn", "*.elb.amazonaws.com", "awsglobalaccelerator.com", "*.private.repost.aws", "eero.online", "eero-stage.online", "apigee.io", "panel.dev", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "f5.si", "arvanedge.ir", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.link", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "balena-devices.com", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "beagleboard.io", "*.beget.app", "pages.gay", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "*.s.brave.io", "shop.brendly.hr", "shop.brendly.rs", "browsersafetymark.io", "radio.am", "radio.fm", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "canva-apps.cn", "*.my.canvasite.cn", "canva-apps.com", "*.my.canva.site", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "api.gov.uk", "cdn77-storage.com", "rsc.contentproxy9.cz", "r.cdn77.net", "cdn77-ssl.net", "c.cdn77.org", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "za.bz", "br.com", "cn.com", "de.com", "eu.com", "jpn.com", "mex.com", "ru.com", "sa.com", "uk.com", "us.com", "za.com", "com.de", "gb.net", "hu.net", "jp.net", "se.net", "uk.net", "ae.org", "com.se", "cx.ua", "discourse.group", "discourse.team", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "cleverapps.cc", "*.services.clever-cloud.com", "cleverapps.io", "cleverapps.tech", "clickrising.net", "cloudns.asia", "cloudns.be", "cloud-ip.biz", "cloudns.biz", "cloudns.cc", "cloudns.ch", "cloudns.cl", "cloudns.club", "dnsabr.com", "ip-ddns.com", "cloudns.cx", "cloudns.eu", "cloudns.in", "cloudns.info", "ddns-ip.net", "dns-cloud.net", "dns-dynamic.net", "cloudns.nz", "cloudns.org", "ip-dynamic.org", "cloudns.ph", "cloudns.pro", "cloudns.pw", "cloudns.us", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "*.cloudera.site", "cf-ipfs.com", "cloudflare-ipfs.com", "trycloudflare.com", "pages.dev", "r2.dev", "workers.dev", "cloudflare.net", "cdn.cloudflare.net", "cdn.cloudflareanycast.net", "cdn.cloudflarecn.net", "cdn.cloudflareglobal.net", "cust.cloudscale.ch", "objects.lpg.cloudscale.ch", "objects.rma.cloudscale.ch", "wnext.app", "cnpy.gdn", "*.otap.co", "co.ca", "co.com", "codeberg.page", "csb.app", "preview.csb.app", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ctfcloud.net", "convex.site", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dnsupdater.de", "dynamisches-dns.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "craft.me", "realm.cz", "on.crisp.email", "*.cryptonomic.net", "curv.dev", "cfolks.pl", "cyon.link", "cyon.site", "platform0.app", "fnwk.site", "folionetwork.site", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "builtwithdark.com", "darklang.io", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyn-ip24.de", "dyndns1.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "debian.net", "definima.io", "definima.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "dfirma.pl", "dkonto.pl", "you2.pl", "ondigitalocean.app", "*.digitaloceanspaces.com", "us.kg", "rss.my.id", "diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "durumis.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns.biz", "for-better.biz", "for-more.biz", "for-some.biz", "for-the.biz", "selfip.biz", "webhop.biz", "ftpaccess.cc", "game-server.cc", "myphotos.cc", "scrapping.cc", "blogdns.com", "cechire.com", "dnsalias.com", "dnsdojo.com", "doesntexist.com", "dontexist.com", "doomdns.com", "dyn-o-saur.com", "dynalias.com", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "from-ak.com", "from-al.com", "from-ar.com", "from-ca.com", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-ma.com", "from-md.com", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "getmyip.com", "gotdns.com", "hobby-site.com", "homelinux.com", "homeunix.com", "iamallama.com", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bulls-fan.com", "is-a-caterer.com", "is-a-chef.com", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-certified.com", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-not-certified.com", "is-slick.com", "is-uberleet.com", "is-with-theband.com", "isa-geek.com", "isa-hockeynut.com", "issmarterthanyou.com", "likes-pie.com", "likescandy.com", "neat-url.com", "saves-the-whales.com", "selfip.com", "sells-for-less.com", "sells-for-u.com", "servebbs.com", "simple-url.com", "space-to-rent.com", "teaches-yoga.com", "writesthisblog.com", "ath.cx", "fuettertdasnetz.de", "isteingeek.de", "istmein.de", "lebtimnetz.de", "leitungsen.de", "traeumtgerade.de", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "dyndns.info", "for-our.info", "groks-the.info", "groks-this.info", "here-for-more.info", "knowsitall.info", "selfip.info", "webhop.info", "forgot.her.name", "forgot.his.name", "at-band-camp.net", "blogdns.net", "broke-it.net", "buyshouses.net", "dnsalias.net", "dnsdojo.net", "does-it.net", "dontexist.net", "dynalias.net", "dynathome.net", "endofinternet.net", "from-az.net", "from-co.net", "from-la.net", "from-ny.net", "gets-it.net", "ham-radio-op.net", "homeftp.net", "homeip.net", "homelinux.net", "homeunix.net", "in-the-band.net", "is-a-chef.net", "is-a-geek.net", "isa-geek.net", "kicks-ass.net", "office-on-the.net", "podzone.net", "scrapper-site.net", "selfip.net", "sells-it.net", "servebbs.net", "serveftp.net", "thruhere.net", "webhop.net", "merseine.nu", "mine.nu", "shacknet.nu", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "dnsalias.org", "dnsdojo.org", "doesntexist.org", "dontexist.org", "doomdns.org", "dvrdns.org", "dynalias.org", "dyndns.org", "go.dyndns.org", "home.dyndns.org", "endofinternet.org", "endoftheinternet.org", "from-me.org", "game-host.org", "gotdns.org", "hobby-site.org", "homedns.org", "homeftp.org", "homelinux.org", "homeunix.org", "is-a-bruinsfan.org", "is-a-candidate.org", "is-a-celticsfan.org", "is-a-chef.org", "is-a-geek.org", "is-a-knight.org", "is-a-linux-user.org", "is-a-patsfan.org", "is-a-soxfan.org", "is-found.org", "is-lost.org", "is-saved.org", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "isa-geek.org", "kicks-ass.org", "misconfused.org", "podzone.org", "readmyblog.org", "selfip.org", "sellsyourhome.org", "servebbs.org", "serveftp.org", "servegame.org", "stuff-4-sale.org", "webhop.org", "better-than.tv", "dyndns.tv", "on-the-web.tv", "worse-than.tv", "is-by.us", "land-4-sale.us", "stuff-4-sale.us", "dyndns.ws", "mypets.ws", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "dynv6.net", "e4.cz", "easypanel.app", "easypanel.host", "*.ewp.live", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "at.emf.camp", "rt.ht", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "pl.eu.org", "pt.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "relay.evervault.app", "relay.evervault.dev", "expo.app", "staging.expo.app", "onfabrica.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-edge.com", "fastly-terrarium.com", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastlylb.net", "map.fastlylb.net", "*.user.fm", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "conn.uk", "copro.uk", "hosp.uk", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "fh-muenster.io", "filegear.me", "firebaseapp.com", "fldrv.com", "flutterflow.app", "fly.dev", "shw.io", "edgeapp.net", "forgeblocks.com", "id.forgerock.io", "framer.ai", "framer.app", "framercanvas.com", "framer.media", "framer.photos", "framer.website", "framer.wiki", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "*.frusky.de", "wien.funkfeuer.at", "daemon.asia", "dix.asia", "mydns.bz", "0am.jp", "0g0.jp", "0j0.jp", "0t0.jp", "mydns.jp", "pgw.jp", "wjg.jp", "keyword-on.net", "live-on.net", "server-on.net", "mydns.tw", "mydns.vc", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "aliases121.com", "campaign.gov.uk", "service.gov.uk", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "localcert.net", "localhostcert.net", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "graphic.design", "goip.de", "blogspot.ae", "blogspot.al", "blogspot.am", "*.hosted.app", "*.run.app", "web.app", "blogspot.com.ar", "blogspot.co.at", "blogspot.com.au", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.com.br", "blogspot.com.by", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.com.co", "*.0emm.com", "appspot.com", "*.r.appspot.com", "blogspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "withgoogle.com", "withyoutube.com", "blogspot.cv", "blogspot.com.cy", "blogspot.cz", "blogspot.de", "*.gateway.dev", "blogspot.dk", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.fi", "blogspot.fr", "cloud.goog", "translate.goog", "*.usercontent.goog", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.co.id", "blogspot.ie", "blogspot.co.il", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.co.ke", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.com.mt", "blogspot.mx", "blogspot.my", "cloudfunctions.net", "blogspot.com.ng", "blogspot.nl", "blogspot.no", "blogspot.co.nz", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.com.tr", "blogspot.tw", "blogspot.ug", "blogspot.co.uk", "blogspot.com.uy", "blogspot.vn", "blogspot.co.za", "goupile.fr", "pymnt.uk", "cloudapps.digital", "london.cloudapps.digital", "gov.nl", "grafana-dev.net", "grayjayleagues.com", "gnstigbestellen.de", "gnstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "hkkinen.fi", "hrsn.dev", "hashbang.sh", "hasura.app", "hasura-app.io", "hatenablog.com", "hatenadiary.com", "hateblo.jp", "hatenablog.jp", "hatenadiary.jp", "hatenadiary.org", "pages.it.hs-heilbronn.de", "pages-research.it.hs-heilbronn.de", "heiyu.space", "helioho.st", "heliohost.us", "hepforge.org", "herokuapp.com", "herokussl.com", "heyflow.page", "heyflow.site", "ravendb.cloud", "ravendb.community", "development.run", "ravendb.run", "homesklep.pl", "*.kin.one", "*.id.pub", "*.kin.pub", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "biz.ng", "co.biz.ng", "dl.biz.ng", "go.biz.ng", "lg.biz.ng", "on.biz.ng", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "plc.ng", "ie.ua", "hostyhosting.io", "hf.space", "static.hf.space", "hypernode.io", "iobb.net", "co.cz", "*.moonscale.io", "moonscale.net", "gr.com", "iki.fi", "ibxos.it", "iliadboxos.it", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-vpn.de", "in-dsl.net", "in-vpn.net", "in-dsl.org", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "apps-1and1.com", "live-website.com", "apps-1and1.net", "websitebuilder.online", "app-ionos.space", "iopsys.se", "*.dweb.link", "ipifony.net", "ir.md", "is-a-good.dev", "is-a.dev", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "dopaas.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "paas.massivegrid.com", "jed.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "jc.neen.it", "jcloud.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "webadorsite.com", "jouwweb.site", "*.cns.joyent.com", "*.triton.zone", "js.org", "kaas.gg", "khplay.nl", "kapsi.fi", "ezproxy.kuleuven.be", "kuleuven.cloud", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "webthings.io", "krellian.net", "oya.to", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "libp2p.direct", "runcontainers.dev", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "linkyard-cloud.ch", "linkyard.cloud", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "filegear-sg.me", "ggff.net", "*.user.localcert.dev", "lodz.pl", "pabianice.pl", "plock.pl", "sieradz.pl", "skierniewice.pl", "zgierz.pl", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "lohmus.me", "servers.run", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.club", "barsycenter.com", "barsyonline.com", "barsy.de", "barsy.dev", "barsy.eu", "barsy.gr", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsyonline.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.rs", "barsy.shop", "barsyonline.shop", "barsy.site", "barsy.store", "barsy.support", "barsy.uk", "barsy.co.uk", "barsyonline.co.uk", "*.magentosite.cloud", "hb.cldmail.ru", "matlab.cloud", "modelscape.com", "mwcloudnonprod.com", "polyspace.com", "mayfirst.info", "mayfirst.org", "mazeplay.com", "mcdir.me", "mcdir.ru", "vps.mcdir.ru", "mcpre.ru", "mediatech.by", "mediatech.dev", "hra.health", "medusajs.app", "miniserver.com", "memset.net", "messerli.app", "atmeta.com", "apps.fbsbx.com", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azure-api.net", "azure-mobile.net", "azureedge.net", "azurefd.net", "azurestaticapps.net", "1.azurestaticapps.net", "2.azurestaticapps.net", "3.azurestaticapps.net", "4.azurestaticapps.net", "5.azurestaticapps.net", "6.azurestaticapps.net", "7.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "azurewebsites.net", "cloudapp.net", "trafficmanager.net", "blob.core.windows.net", "servicebus.windows.net", "routingthecloud.com", "sn.mynetname.net", "routingthecloud.net", "routingthecloud.org", "csx.cc", "mydbserver.com", "webspaceconfig.de", "mittwald.info", "mittwaldserver.info", "typo3server.info", "project.space", "modx.dev", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "caracal.mythic-beasts.com", "customer.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "cloud.nospamproxy.com", "netfy.app", "netlify.app", "4u.com", "nfshost.com", "ipfs.nftstorage.link", "ngo.us", "ngrok.app", "ngrok-free.app", "ngrok.dev", "ngrok-free.dev", "ngrok.io", "ap.ngrok.io", "au.ngrok.io", "eu.ngrok.io", "in.ngrok.io", "jp.ngrok.io", "sa.ngrok.io", "us.ngrok.io", "ngrok.pizza", "ngrok.pro", "torun.pl", "nh-serv.co.uk", "nimsite.uk", "mmafan.biz", "myftp.biz", "no-ip.biz", "no-ip.ca", "fantasyleague.cc", "gotdns.ch", "3utilities.com", "blogsyte.com", "ciscofreak.com", "damnserver.com", "ddnsking.com", "ditchyourip.com", "dnsiskinky.com", "dynns.com", "geekgalaxy.com", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "myactivedirectory.com", "mysecuritycamera.com", "myvnc.com", "net-freaks.com", "onthewifi.com", "point2this.com", "quicksytes.com", "securitytactics.com", "servebeer.com", "servecounterstrike.com", "serveexchange.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "servehumour.com", "serveirc.com", "servemp3.com", "servep2p.com", "servepics.com", "servequake.com", "servesarcasm.com", "stufftoread.com", "unusualperson.com", "workisboring.com", "dvrcam.info", "ilovecollege.info", "no-ip.info", "brasilia.me", "ddns.me", "dnsfor.me", "hopto.me", "loginto.me", "noip.me", "webhop.me", "bounceme.net", "ddns.net", "eating-organic.net", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.net", "nhlfan.net", "no-ip.net", "pgafan.net", "privatizehealthinsurance.net", "redirectme.net", "serveblog.net", "serveminecraft.net", "sytes.net", "cable-modem.org", "collegefan.org", "couchpotatofries.org", "hopto.org", "mlbfan.org", "myftp.org", "mysecuritycamera.org", "nflfan.org", "no-ip.org", "read-books.org", "ufcfan.org", "zapto.org", "no-ip.co.uk", "golffan.us", "noip.us", "pointto.us", "stage.nodeart.io", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "notion.site", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "myiphost.com", "forumz.info", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "nsupdate.info", "nerdpol.ovh", "nyc.mn", "prvcy.page", "obl.ong", "observablehq.cloud", "static.observableusercontent.com", "omg.lol", "cloudycluster.net", "omniwe.site", "123webseite.at", "123website.be", "simplesite.com.br", "123website.ch", "simplesite.com", "123webseite.de", "123hjemmeside.dk", "123miweb.es", "123kotisivu.fi", "123siteweb.fr", "simplesite.gr", "123homepage.it", "123website.lu", "123website.nl", "123hjemmeside.no", "service.one", "simplesite.pl", "123paginaweb.pt", "123minsida.se", "is-a-fullstack.dev", "is-cool.dev", "is-not-a.dev", "localplayer.dev", "is-local.org", "opensocial.site", "opencraft.hosting", "16-b.it", "32-b.it", "64-b.it", "orsites.com", "operaunite.com", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "*.oraclecloudapps.com", "*.oraclegovcloudapps.com", "*.oraclegovcloudapps.uk", "tech.orange", "can.re", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.hosting.ovh.net", "*.webpaas.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagexl.com", "gotpantheon.com", "pantheonsite.io", "*.paywhirl.com", "*.xmit.co", "xmit.dev", "madethis.site", "srv.us", "gh.srv.us", "gl.srv.us", "lk3.ru", "mypep.link", "perspecta.cloud", "on-web.fr", "*.upsun.app", "upsunapp.com", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pley.games", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qa2.com", "qcx.io", "*.sys.qcx.io", "myqnapcloud.cn", "alpha-myqnapcloud.com", "dev-myqnapcloud.com", "mycloudnas.com", "mynascloud.com", "myqnapcloud.com", "qoto.io", "qualifioapp.com", "ladesk.com", "qbuser.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "cloudsite.builders", "myradweb.net", "servername.us", "web.in", "in.net", "myrdbx.io", "site.rb-hosting.io", "*.on-rancher.cloud", "*.on-k3s.io", "*.on-rio.io", "ravpage.co.il", "readthedocs-hosted.com", "readthedocs.io", "rhcloud.com", "instances.spawn.cc", "onrender.com", "app.render.com", "replit.app", "id.replit.app", "firewalledreplit.co", "id.firewalledreplit.co", "repl.co", "id.repl.co", "replit.dev", "archer.replit.dev", "bones.replit.dev", "canary.replit.dev", "global.replit.dev", "hacker.replit.dev", "id.replit.dev", "janeway.replit.dev", "kim.replit.dev", "kira.replit.dev", "kirk.replit.dev", "odo.replit.dev", "paris.replit.dev", "picard.replit.dev", "pike.replit.dev", "prerelease.replit.dev", "reed.replit.dev", "riker.replit.dev", "sisko.replit.dev", "spock.replit.dev", "staging.replit.dev", "sulu.replit.dev", "tarpit.replit.dev", "teams.replit.dev", "tucker.replit.dev", "wesley.replit.dev", "worf.replit.dev", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "adimo.co.uk", "itcouldbewor.se", "aus.basketball", "nz.basketball", "git-pages.rit.edu", "rocky.page", "rub.de", "ruhr-uni-bochum.de", "io.noc.ruhr-uni-bochum.de", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "ras.ru", "nyat.app", "180r.com", "dojin.com", "sakuratan.com", "sakuraweb.com", "x0.com", "2-d.jp", "bona.jp", "crap.jp", "daynight.jp", "eek.jp", "flop.jp", "halfmoon.jp", "jeez.jp", "matrix.jp", "mimoza.jp", "ivory.ne.jp", "mail-box.ne.jp", "mints.ne.jp", "mokuren.ne.jp", "opal.ne.jp", "sakura.ne.jp", "sumomo.ne.jp", "topaz.ne.jp", "netgamers.jp", "nyanta.jp", "o0o0.jp", "rdy.jp", "rgr.jp", "rulez.jp", "s3.isk01.sakurastorage.jp", "s3.isk02.sakurastorage.jp", "saloon.jp", "sblo.jp", "skr.jp", "tank.jp", "uh-oh.jp", "undo.jp", "rs.webaccel.jp", "user.webaccel.jp", "websozai.jp", "xii.jp", "squares.net", "jpn.org", "kirara.st", "x0.to", "from.tv", "sakura.tv", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "*.001.test.code-builder-stg.platform.salesforce.com", "*.d.crm.dev", "*.w.crm.dev", "*.wa.crm.dev", "*.wb.crm.dev", "*.wc.crm.dev", "*.wd.crm.dev", "*.we.crm.dev", "*.wf.crm.dev", "sandcats.io", "logoip.com", "logoip.de", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "cockpit.fr-par.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "cockpit.nl-ams.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "cockpit.pl-waw.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "client.scrypted.io", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "minisite.ms", "senseering.net", "servebolt.cloud", "biz.ua", "co.ua", "pp.ua", "as.sh.cn", "sheezy.games", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.shop", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "small-web.org", "aeroport.fr", "avocat.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "vp4.me", "*.snowflake.app", "*.privatelink.snowflake.app", "streamlit.app", "streamlitapp.com", "try-snowplow.com", "mafelo.net", "playstation-cloud.com", "srht.site", "apps.lair.io", "*.stolos.io", "spacekit.io", "ind.mom", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "w-corp-staticblitz.com", "w-credentialless-staticblitz.com", "w-staticblitz.com", "stackhero-network.com", "runs.onstackit.cloud", "stackit.gg", "stackit.rocks", "stackit.run", "stackit.zone", "musician.io", "novecore.site", "api.stdlib.com", "feedback.ac", "forms.ac", "assessments.cx", "calculators.cx", "funnels.cx", "paynow.cx", "quizzes.cx", "researched.cx", "tests.cx", "surveys.so", "storebase.store", "storipress.app", "storj.farm", "strapiapp.com", "media.strapiapp.com", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "streak-link.com", "streaklinks.com", "streakusercontent.com", "soc.srcf.net", "user.srcf.net", "utwente.io", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "direct.quickconnect.to", "vpnplus.to", "mytabit.com", "mytabit.co.il", "tabitorder.co.il", "taifun-dns.de", "ts.net", "*.c.ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "taveusercontent.com", "p.tawk.email", "p.tawkto.email", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "reservd.dev.thingdust.io", "cust.disrec.thingdust.io", "reservd.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "site.transip.me", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "diskstation.eu", "diskstation.org", "typedream.app", "pro.typeform.com", "*.uberspace.de", "uber.space", "hk.com", "inc.hk", "ltd.hk", "hk.org", "it.com", "unison-services.cloud", "virtual-user.de", "virtualuser.de", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "rs.ba", "bielsko.pl", "upli.io", "urown.cloud", "dnsupdate.info", "us.org", "v.ua", "express.val.run", "web.val.run", "vercel.app", "v0.build", "vercel.dev", "vusercontent.net", "now.sh", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "*.vultrobjects.com", "wafflecell.com", "webflow.io", "webflowtest.io", "*.webhare.dev", "bookonline.app", "hotelwithflight.com", "reserve-online.com", "reserve-online.net", "cprapid.com", "pleskns.com", "wp2.host", "pdns.page", "plesk.page", "wpsquared.site", "*.wadl.top", "remotewd.com", "box.ca", "pages.wiardweb.com", "toolforge.org", "wmcloud.org", "wmflabs.org", "wdh.app", "panel.gg", "daemon.panel.gg", "wixsite.com", "wixstudio.com", "editorx.io", "wixstudio.io", "wix.run", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "yombo.me", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "zap.cloud", "zeabur.app", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"];
  var Z = Y.reduce((e, s) => {
    const c = s.replace(/^(\*\.|\!)/, ""), o = A.toASCII(c), t = s.charAt(0);
    if (e.has(o))
      throw new Error(`Multiple rules found for ${s} (${o})`);
    return e.set(o, { rule: s, suffix: c, punySuffix: o, wildcard: t === "*", exception: t === "!" }), e;
  }, new Map);
  var aa = (e) => {
    const c = A.toASCII(e).split(".");
    for (let o = 0;o < c.length; o++) {
      const t = c.slice(o).join("."), d = Z.get(t);
      if (d)
        return d;
    }
    return null;
  };
  var H = { DOMAIN_TOO_SHORT: "Domain name too short.", DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.", LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.", LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.", LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.", LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.", LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes." };
  var oa = (e) => {
    const s = A.toASCII(e);
    if (s.length < 1)
      return "DOMAIN_TOO_SHORT";
    if (s.length > 255)
      return "DOMAIN_TOO_LONG";
    const c = s.split(".");
    let o;
    for (let t = 0;t < c.length; ++t) {
      if (o = c[t], !o.length)
        return "LABEL_TOO_SHORT";
      if (o.length > 63)
        return "LABEL_TOO_LONG";
      if (o.charAt(0) === "-")
        return "LABEL_STARTS_WITH_DASH";
      if (o.charAt(o.length - 1) === "-")
        return "LABEL_ENDS_WITH_DASH";
      if (!/^[a-z0-9\-_]+$/.test(o))
        return "LABEL_INVALID_CHARS";
    }
  };
  var _ = (e) => {
    if (typeof e != "string")
      throw new TypeError("Domain name must be a string.");
    let s = e.slice(0).toLowerCase();
    s.charAt(s.length - 1) === "." && (s = s.slice(0, s.length - 1));
    const c = oa(s);
    if (c)
      return { input: e, error: { message: H[c], code: c } };
    const o = { input: e, tld: null, sld: null, domain: null, subdomain: null, listed: false }, t = s.split(".");
    if (t[t.length - 1] === "local")
      return o;
    const d = () => (/xn--/.test(s) && (o.domain && (o.domain = A.toASCII(o.domain)), o.subdomain && (o.subdomain = A.toASCII(o.subdomain))), o), z = aa(s);
    if (!z)
      return t.length < 2 ? o : (o.tld = t.pop(), o.sld = t.pop(), o.domain = [o.sld, o.tld].join("."), t.length && (o.subdomain = t.pop()), d());
    o.listed = true;
    const y = z.suffix.split("."), g = t.slice(0, t.length - y.length);
    return z.exception && g.push(y.shift()), o.tld = y.join("."), !g.length || (z.wildcard && (y.unshift(g.pop()), o.tld = y.join(".")), !g.length) || (o.sld = g.pop(), o.domain = [o.sld, o.tld].join("."), g.length && (o.subdomain = g.join("."))), d();
  };
  var N = (e) => e && _(e).domain || null;
  var R = (e) => {
    const s = _(e);
    return !!(s.domain && s.listed);
  };
  var sa = { parse: _, get: N, isValid: R };
  exports.default = sa;
  exports.errorCodes = H;
  exports.get = N;
  exports.isValid = R;
  exports.parse = _;
});

// node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS((exports) => {
  /*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var psl = require_psl();
  function getPublicSuffix(domain) {
    return psl.get(domain);
  }
  exports.getPublicSuffix = getPublicSuffix;
});

// node_modules/tough-cookie/lib/store.js
var require_store = __commonJS((exports) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  function Store() {}
  exports.Store = Store;
  Store.prototype.synchronous = false;
  Store.prototype.findCookie = function(domain, path, key, cb) {
    throw new Error("findCookie is not implemented");
  };
  Store.prototype.findCookies = function(domain, path, cb) {
    throw new Error("findCookies is not implemented");
  };
  Store.prototype.putCookie = function(cookie, cb) {
    throw new Error("putCookie is not implemented");
  };
  Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
    throw new Error("updateCookie is not implemented");
  };
  Store.prototype.removeCookie = function(domain, path, key, cb) {
    throw new Error("removeCookie is not implemented");
  };
  Store.prototype.removeCookies = function(domain, path, cb) {
    throw new Error("removeCookies is not implemented");
  };
  Store.prototype.removeAllCookies = function(cb) {
    throw new Error("removeAllCookies is not implemented");
  };
  Store.prototype.getAllCookies = function(cb) {
    throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
  };
});

// node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS((exports) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var pubsuffix = require_pubsuffix_psl();
  function permuteDomain(domain) {
    var pubSuf = pubsuffix.getPublicSuffix(domain);
    if (!pubSuf) {
      return null;
    }
    if (pubSuf == domain) {
      return [domain];
    }
    var prefix = domain.slice(0, -(pubSuf.length + 1));
    var parts = prefix.split(".").reverse();
    var cur = pubSuf;
    var permutations = [cur];
    while (parts.length) {
      cur = parts.shift() + "." + cur;
      permutations.push(cur);
    }
    return permutations;
  }
  exports.permuteDomain = permuteDomain;
});

// node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS((exports) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
      return true;
    }
    var idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
      if (cookiePath.substr(-1) === "/") {
        return true;
      }
      if (reqPath.substr(cookiePath.length, 1) === "/") {
        return true;
      }
    }
    return false;
  }
  exports.pathMatch = pathMatch;
});

// node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS((exports) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var Store = require_store().Store;
  var permuteDomain = require_permuteDomain().permuteDomain;
  var pathMatch = require_pathMatch().pathMatch;
  var util = __require("util");
  function MemoryCookieStore() {
    Store.call(this);
    this.idx = {};
  }
  util.inherits(MemoryCookieStore, Store);
  exports.MemoryCookieStore = MemoryCookieStore;
  MemoryCookieStore.prototype.idx = null;
  MemoryCookieStore.prototype.synchronous = true;
  MemoryCookieStore.prototype.inspect = function() {
    return "{ idx: " + util.inspect(this.idx, false, 2) + " }";
  };
  if (util.inspect.custom) {
    MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;
  }
  MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
    if (!this.idx[domain]) {
      return cb(null, undefined);
    }
    if (!this.idx[domain][path]) {
      return cb(null, undefined);
    }
    return cb(null, this.idx[domain][path][key] || null);
  };
  MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
    var results = [];
    if (!domain) {
      return cb(null, []);
    }
    var pathMatcher;
    if (!path) {
      pathMatcher = function matchAll(domainIndex) {
        for (var curPath in domainIndex) {
          var pathIndex = domainIndex[curPath];
          for (var key in pathIndex) {
            results.push(pathIndex[key]);
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        Object.keys(domainIndex).forEach(function(cookiePath) {
          if (pathMatch(path, cookiePath)) {
            var pathIndex = domainIndex[cookiePath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        });
      };
    }
    var domains = permuteDomain(domain) || [domain];
    var idx = this.idx;
    domains.forEach(function(curDomain) {
      var domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });
    cb(null, results);
  };
  MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
    if (!this.idx[cookie.domain]) {
      this.idx[cookie.domain] = {};
    }
    if (!this.idx[cookie.domain][cookie.path]) {
      this.idx[cookie.domain][cookie.path] = {};
    }
    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
    cb(null);
  };
  MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
    this.putCookie(newCookie, cb);
  };
  MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
    if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
      delete this.idx[domain][path][key];
    }
    cb(null);
  };
  MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
    if (this.idx[domain]) {
      if (path) {
        delete this.idx[domain][path];
      } else {
        delete this.idx[domain];
      }
    }
    return cb(null);
  };
  MemoryCookieStore.prototype.removeAllCookies = function(cb) {
    this.idx = {};
    return cb(null);
  };
  MemoryCookieStore.prototype.getAllCookies = function(cb) {
    var cookies = [];
    var idx = this.idx;
    var domains = Object.keys(idx);
    domains.forEach(function(domain) {
      var paths = Object.keys(idx[domain]);
      paths.forEach(function(path) {
        var keys = Object.keys(idx[domain][path]);
        keys.forEach(function(key) {
          if (key !== null) {
            cookies.push(idx[domain][path][key]);
          }
        });
      });
    });
    cookies.sort(function(a, b) {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });
    cb(null, cookies);
  };
});

// node_modules/tough-cookie/lib/version.js
var require_version = __commonJS((exports, module) => {
  module.exports = "2.5.0";
});

// node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS((exports) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var net = __require("net");
  var urlParse = __require("url").parse;
  var util = __require("util");
  var pubsuffix = require_pubsuffix_psl();
  var Store = require_store().Store;
  var MemoryCookieStore = require_memstore().MemoryCookieStore;
  var pathMatch = require_pathMatch().pathMatch;
  var VERSION = require_version();
  var punycode;
  try {
    punycode = __require("punycode");
  } catch (e) {
    console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
  }
  var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
  var CONTROL_CHARS = /[\x00-\x1F]/;
  var TERMINATORS = [`
`, "\r", "\x00"];
  var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
  var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
  var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
  };
  var NUM_TO_MONTH = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var NUM_TO_DAY = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  var MAX_TIME = 2147483647000;
  var MIN_TIME = 0;
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    var count = 0;
    while (count < token.length) {
      var c = token.charCodeAt(count);
      if (c <= 47 || c >= 58) {
        break;
      }
      count++;
    }
    if (count < minDigits || count > maxDigits) {
      return null;
    }
    if (!trailingOK && count != token.length) {
      return null;
    }
    return parseInt(token.substr(0, count), 10);
  }
  function parseTime(token) {
    var parts = token.split(":");
    var result = [0, 0, 0];
    if (parts.length !== 3) {
      return null;
    }
    for (var i = 0;i < 3; i++) {
      var trailingOK = i == 2;
      var num = parseDigits(parts[i], 1, 2, trailingOK);
      if (num === null) {
        return null;
      }
      result[i] = num;
    }
    return result;
  }
  function parseMonth(token) {
    token = String(token).substr(0, 3).toLowerCase();
    var num = MONTH_TO_NUM[token];
    return num >= 0 ? num : null;
  }
  function parseDate(str) {
    if (!str) {
      return;
    }
    var tokens = str.split(DATE_DELIM);
    if (!tokens) {
      return;
    }
    var hour = null;
    var minute = null;
    var second = null;
    var dayOfMonth = null;
    var month = null;
    var year = null;
    for (var i = 0;i < tokens.length; i++) {
      var token = tokens[i].trim();
      if (!token.length) {
        continue;
      }
      var result;
      if (second === null) {
        result = parseTime(token);
        if (result) {
          hour = result[0];
          minute = result[1];
          second = result[2];
          continue;
        }
      }
      if (dayOfMonth === null) {
        result = parseDigits(token, 1, 2, true);
        if (result !== null) {
          dayOfMonth = result;
          continue;
        }
      }
      if (month === null) {
        result = parseMonth(token);
        if (result !== null) {
          month = result;
          continue;
        }
      }
      if (year === null) {
        result = parseDigits(token, 2, 4, true);
        if (result !== null) {
          year = result;
          if (year >= 70 && year <= 99) {
            year += 1900;
          } else if (year >= 0 && year <= 69) {
            year += 2000;
          }
        }
      }
    }
    if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
      return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
  function formatDate(date) {
    var d = date.getUTCDate();
    d = d >= 10 ? d : "0" + d;
    var h = date.getUTCHours();
    h = h >= 10 ? h : "0" + h;
    var m = date.getUTCMinutes();
    m = m >= 10 ? m : "0" + m;
    var s = date.getUTCSeconds();
    s = s >= 10 ? s : "0" + s;
    return NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
  }
  function canonicalDomain(str) {
    if (str == null) {
      return null;
    }
    str = str.trim().replace(/^\./, "");
    if (punycode && /[^\u0001-\u007f]/.test(str)) {
      str = punycode.toASCII(str);
    }
    return str.toLowerCase();
  }
  function domainMatch(str, domStr, canonicalize) {
    if (str == null || domStr == null) {
      return null;
    }
    if (canonicalize !== false) {
      str = canonicalDomain(str);
      domStr = canonicalDomain(domStr);
    }
    if (str == domStr) {
      return true;
    }
    if (net.isIP(str)) {
      return false;
    }
    var idx = str.indexOf(domStr);
    if (idx <= 0) {
      return false;
    }
    if (str.length !== domStr.length + idx) {
      return false;
    }
    if (str.substr(idx - 1, 1) !== ".") {
      return false;
    }
    return true;
  }
  function defaultPath(path) {
    if (!path || path.substr(0, 1) !== "/") {
      return "/";
    }
    if (path === "/") {
      return path;
    }
    var rightSlash = path.lastIndexOf("/");
    if (rightSlash === 0) {
      return "/";
    }
    return path.slice(0, rightSlash);
  }
  function trimTerminator(str) {
    for (var t = 0;t < TERMINATORS.length; t++) {
      var terminatorIdx = str.indexOf(TERMINATORS[t]);
      if (terminatorIdx !== -1) {
        str = str.substr(0, terminatorIdx);
      }
    }
    return str;
  }
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    var firstEq = cookiePair.indexOf("=");
    if (looseMode) {
      if (firstEq === 0) {
        cookiePair = cookiePair.substr(1);
        firstEq = cookiePair.indexOf("=");
      }
    } else {
      if (firstEq <= 0) {
        return;
      }
    }
    var cookieName, cookieValue;
    if (firstEq <= 0) {
      cookieName = "";
      cookieValue = cookiePair.trim();
    } else {
      cookieName = cookiePair.substr(0, firstEq).trim();
      cookieValue = cookiePair.substr(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
      return;
    }
    var c = new Cookie;
    c.key = cookieName;
    c.value = cookieValue;
    return c;
  }
  function parse(str, options) {
    if (!options || typeof options !== "object") {
      options = {};
    }
    str = str.trim();
    var firstSemi = str.indexOf(";");
    var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
    var c = parseCookiePair(cookiePair, !!options.loose);
    if (!c) {
      return;
    }
    if (firstSemi === -1) {
      return c;
    }
    var unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
      return c;
    }
    var cookie_avs = unparsed.split(";");
    while (cookie_avs.length) {
      var av = cookie_avs.shift().trim();
      if (av.length === 0) {
        continue;
      }
      var av_sep = av.indexOf("=");
      var av_key, av_value;
      if (av_sep === -1) {
        av_key = av;
        av_value = null;
      } else {
        av_key = av.substr(0, av_sep);
        av_value = av.substr(av_sep + 1);
      }
      av_key = av_key.trim().toLowerCase();
      if (av_value) {
        av_value = av_value.trim();
      }
      switch (av_key) {
        case "expires":
          if (av_value) {
            var exp = parseDate(av_value);
            if (exp) {
              c.expires = exp;
            }
          }
          break;
        case "max-age":
          if (av_value) {
            if (/^-?[0-9]+$/.test(av_value)) {
              var delta = parseInt(av_value, 10);
              c.setMaxAge(delta);
            }
          }
          break;
        case "domain":
          if (av_value) {
            var domain = av_value.trim().replace(/^\./, "");
            if (domain) {
              c.domain = domain.toLowerCase();
            }
          }
          break;
        case "path":
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
        case "secure":
          c.secure = true;
          break;
        case "httponly":
          c.httpOnly = true;
          break;
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  function jsonParse(str) {
    var obj2;
    try {
      obj2 = JSON.parse(str);
    } catch (e) {
      return e;
    }
    return obj2;
  }
  function fromJSON(str) {
    if (!str) {
      return null;
    }
    var obj2;
    if (typeof str === "string") {
      obj2 = jsonParse(str);
      if (obj2 instanceof Error) {
        return null;
      }
    } else {
      obj2 = str;
    }
    var c = new Cookie;
    for (var i = 0;i < Cookie.serializableProperties.length; i++) {
      var prop = Cookie.serializableProperties[i];
      if (obj2[prop] === undefined || obj2[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (obj2[prop] === null) {
          c[prop] = null;
        } else {
          c[prop] = obj2[prop] == "Infinity" ? "Infinity" : new Date(obj2[prop]);
        }
      } else {
        c[prop] = obj2[prop];
      }
    }
    return c;
  }
  function cookieCompare(a, b) {
    var cmp = 0;
    var aPathLen = a.path ? a.path.length : 0;
    var bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
      return cmp;
    }
    var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
    var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = a.creationIndex - b.creationIndex;
    return cmp;
  }
  function permutePath(path) {
    if (path === "/") {
      return ["/"];
    }
    if (path.lastIndexOf("/") === path.length - 1) {
      path = path.substr(0, path.length - 1);
    }
    var permutations = [path];
    while (path.length > 1) {
      var lindex = path.lastIndexOf("/");
      if (lindex === 0) {
        break;
      }
      path = path.substr(0, lindex);
      permutations.push(path);
    }
    permutations.push("/");
    return permutations;
  }
  function getCookieContext(url) {
    if (url instanceof Object) {
      return url;
    }
    try {
      url = decodeURI(url);
    } catch (err) {}
    return urlParse(url);
  }
  function Cookie(options) {
    options = options || {};
    Object.keys(options).forEach(function(prop) {
      if (Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && prop.substr(0, 1) !== "_") {
        this[prop] = options[prop];
      }
    }, this);
    this.creation = this.creation || new Date;
    Object.defineProperty(this, "creationIndex", {
      configurable: false,
      enumerable: false,
      writable: true,
      value: ++Cookie.cookiesCreated
    });
  }
  Cookie.cookiesCreated = 0;
  Cookie.parse = parse;
  Cookie.fromJSON = fromJSON;
  Cookie.prototype.key = "";
  Cookie.prototype.value = "";
  Cookie.prototype.expires = "Infinity";
  Cookie.prototype.maxAge = null;
  Cookie.prototype.domain = null;
  Cookie.prototype.path = null;
  Cookie.prototype.secure = false;
  Cookie.prototype.httpOnly = false;
  Cookie.prototype.extensions = null;
  Cookie.prototype.hostOnly = null;
  Cookie.prototype.pathIsDefault = null;
  Cookie.prototype.creation = null;
  Cookie.prototype.lastAccessed = null;
  Object.defineProperty(Cookie.prototype, "creationIndex", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: 0
  });
  Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop) {
    return !(Cookie.prototype[prop] instanceof Function || prop === "creationIndex" || prop.substr(0, 1) === "_");
  });
  Cookie.prototype.inspect = function inspect() {
    var now = Date.now();
    return 'Cookie="' + this.toString() + "; hostOnly=" + (this.hostOnly != null ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
  };
  if (util.inspect.custom) {
    Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
  }
  Cookie.prototype.toJSON = function() {
    var obj2 = {};
    var props = Cookie.serializableProperties;
    for (var i = 0;i < props.length; i++) {
      var prop = props[i];
      if (this[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (this[prop] === null) {
          obj2[prop] = null;
        } else {
          obj2[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
        }
      } else if (prop === "maxAge") {
        if (this[prop] !== null) {
          obj2[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
        }
      } else {
        if (this[prop] !== Cookie.prototype[prop]) {
          obj2[prop] = this[prop];
        }
      }
    }
    return obj2;
  };
  Cookie.prototype.clone = function() {
    return fromJSON(this.toJSON());
  };
  Cookie.prototype.validate = function validate() {
    if (!COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
      return false;
    }
    if (this.maxAge != null && this.maxAge <= 0) {
      return false;
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }
    var cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false;
      }
      var suffix = pubsuffix.getPublicSuffix(cdomain);
      if (suffix == null) {
        return false;
      }
    }
    return true;
  };
  Cookie.prototype.setExpires = function setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = parseDate(exp) || "Infinity";
    }
  };
  Cookie.prototype.setMaxAge = function setMaxAge(age) {
    if (age === Infinity || age === -Infinity) {
      this.maxAge = age.toString();
    } else {
      this.maxAge = age;
    }
  };
  Cookie.prototype.cookieString = function cookieString() {
    var val = this.value;
    if (val == null) {
      val = "";
    }
    if (this.key === "") {
      return val;
    }
    return this.key + "=" + val;
  };
  Cookie.prototype.toString = function toString() {
    var str = this.cookieString();
    if (this.expires != Infinity) {
      if (this.expires instanceof Date) {
        str += "; Expires=" + formatDate(this.expires);
      } else {
        str += "; Expires=" + this.expires;
      }
    }
    if (this.maxAge != null && this.maxAge != Infinity) {
      str += "; Max-Age=" + this.maxAge;
    }
    if (this.domain && !this.hostOnly) {
      str += "; Domain=" + this.domain;
    }
    if (this.path) {
      str += "; Path=" + this.path;
    }
    if (this.secure) {
      str += "; Secure";
    }
    if (this.httpOnly) {
      str += "; HttpOnly";
    }
    if (this.extensions) {
      this.extensions.forEach(function(ext) {
        str += "; " + ext;
      });
    }
    return str;
  };
  Cookie.prototype.TTL = function TTL(now) {
    if (this.maxAge != null) {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
    }
    var expires = this.expires;
    if (expires != Infinity) {
      if (!(expires instanceof Date)) {
        expires = parseDate(expires) || Infinity;
      }
      if (expires == Infinity) {
        return Infinity;
      }
      return expires.getTime() - (now || Date.now());
    }
    return Infinity;
  };
  Cookie.prototype.expiryTime = function expiryTime(now) {
    if (this.maxAge != null) {
      var relativeTo = now || this.creation || new Date;
      var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;
      return relativeTo.getTime() + age;
    }
    if (this.expires == Infinity) {
      return Infinity;
    }
    return this.expires.getTime();
  };
  Cookie.prototype.expiryDate = function expiryDate(now) {
    var millisec = this.expiryTime(now);
    if (millisec == Infinity) {
      return new Date(MAX_TIME);
    } else if (millisec == -Infinity) {
      return new Date(MIN_TIME);
    } else {
      return new Date(millisec);
    }
  };
  Cookie.prototype.isPersistent = function isPersistent() {
    return this.maxAge != null || this.expires != Infinity;
  };
  Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
    if (this.domain == null) {
      return null;
    }
    return canonicalDomain(this.domain);
  };
  function CookieJar(store, options) {
    if (typeof options === "boolean") {
      options = { rejectPublicSuffixes: options };
    } else if (options == null) {
      options = {};
    }
    if (options.rejectPublicSuffixes != null) {
      this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    }
    if (options.looseMode != null) {
      this.enableLooseMode = options.looseMode;
    }
    if (!store) {
      store = new MemoryCookieStore;
    }
    this.store = store;
  }
  CookieJar.prototype.store = null;
  CookieJar.prototype.rejectPublicSuffixes = true;
  CookieJar.prototype.enableLooseMode = false;
  var CAN_BE_SYNC = [];
  CAN_BE_SYNC.push("setCookie");
  CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
    var err;
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var loose = this.enableLooseMode;
    if (options.loose != null) {
      loose = options.loose;
    }
    if (!(cookie instanceof Cookie)) {
      cookie = Cookie.parse(cookie, { loose });
    }
    if (!cookie) {
      err = new Error("Cookie failed to parse");
      return cb(options.ignoreError ? null : err);
    }
    var now = options.now || new Date;
    if (this.rejectPublicSuffixes && cookie.domain) {
      var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
      if (suffix == null) {
        err = new Error("Cookie has domain set to a public suffix");
        return cb(options.ignoreError ? null : err);
      }
    }
    if (cookie.domain) {
      if (!domainMatch(host, cookie.cdomain(), false)) {
        err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host);
        return cb(options.ignoreError ? null : err);
      }
      if (cookie.hostOnly == null) {
        cookie.hostOnly = false;
      }
    } else {
      cookie.hostOnly = true;
      cookie.domain = host;
    }
    if (!cookie.path || cookie.path[0] !== "/") {
      cookie.path = defaultPath(context.pathname);
      cookie.pathIsDefault = true;
    }
    if (options.http === false && cookie.httpOnly) {
      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return cb(options.ignoreError ? null : err);
    }
    var store = this.store;
    if (!store.updateCookie) {
      store.updateCookie = function(oldCookie, newCookie, cb2) {
        this.putCookie(newCookie, cb2);
      };
    }
    function withCookie(err2, oldCookie) {
      if (err2) {
        return cb(err2);
      }
      var next = function(err3) {
        if (err3) {
          return cb(err3);
        } else {
          cb(null, cookie);
        }
      };
      if (oldCookie) {
        if (options.http === false && oldCookie.httpOnly) {
          err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err2);
        }
        cookie.creation = oldCookie.creation;
        cookie.creationIndex = oldCookie.creationIndex;
        cookie.lastAccessed = now;
        store.updateCookie(oldCookie, cookie, next);
      } else {
        cookie.creation = cookie.lastAccessed = now;
        store.putCookie(cookie, next);
      }
    }
    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
  };
  CAN_BE_SYNC.push("getCookies");
  CookieJar.prototype.getCookies = function(url, options, cb) {
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var path = context.pathname || "/";
    var secure = options.secure;
    if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
      secure = true;
    }
    var http = options.http;
    if (http == null) {
      http = true;
    }
    var now = options.now || Date.now();
    var expireCheck = options.expire !== false;
    var allPaths = !!options.allPaths;
    var store = this.store;
    function matchingCookie(c) {
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!domainMatch(host, c.domain, false)) {
          return false;
        }
      }
      if (!allPaths && !pathMatch(path, c.path)) {
        return false;
      }
      if (c.secure && !secure) {
        return false;
      }
      if (c.httpOnly && !http) {
        return false;
      }
      if (expireCheck && c.expiryTime() <= now) {
        store.removeCookie(c.domain, c.path, c.key, function() {});
        return false;
      }
      return true;
    }
    store.findCookies(host, allPaths ? null : path, function(err, cookies) {
      if (err) {
        return cb(err);
      }
      cookies = cookies.filter(matchingCookie);
      if (options.sort !== false) {
        cookies = cookies.sort(cookieCompare);
      }
      var now2 = new Date;
      cookies.forEach(function(c) {
        c.lastAccessed = now2;
      });
      cb(null, cookies);
    });
  };
  CAN_BE_SYNC.push("getCookieString");
  CookieJar.prototype.getCookieString = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next = function(err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies.sort(cookieCompare).map(function(c) {
          return c.cookieString();
        }).join("; "));
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push("getSetCookieStrings");
  CookieJar.prototype.getSetCookieStrings = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next = function(err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies.map(function(c) {
          return c.toString();
        }));
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push("serialize");
  CookieJar.prototype.serialize = function(cb) {
    var type = this.store.constructor.name;
    if (type === "Object") {
      type = null;
    }
    var serialized = {
      version: "tough-cookie@" + VERSION,
      storeType: type,
      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
      cookies: []
    };
    if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
      return cb(new Error("store does not support getAllCookies and cannot be serialized"));
    }
    this.store.getAllCookies(function(err, cookies) {
      if (err) {
        return cb(err);
      }
      serialized.cookies = cookies.map(function(cookie) {
        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
        delete cookie.creationIndex;
        return cookie;
      });
      return cb(null, serialized);
    });
  };
  CookieJar.prototype.toJSON = function() {
    return this.serializeSync();
  };
  CAN_BE_SYNC.push("_importCookies");
  CookieJar.prototype._importCookies = function(serialized, cb) {
    var jar = this;
    var cookies = serialized.cookies;
    if (!cookies || !Array.isArray(cookies)) {
      return cb(new Error("serialized jar has no cookies array"));
    }
    cookies = cookies.slice();
    function putNext(err) {
      if (err) {
        return cb(err);
      }
      if (!cookies.length) {
        return cb(err, jar);
      }
      var cookie;
      try {
        cookie = fromJSON(cookies.shift());
      } catch (e) {
        return cb(e);
      }
      if (cookie === null) {
        return putNext(null);
      }
      jar.store.putCookie(cookie, putNext);
    }
    putNext();
  };
  CookieJar.deserialize = function(strOrObj, store, cb) {
    if (arguments.length !== 3) {
      cb = store;
      store = null;
    }
    var serialized;
    if (typeof strOrObj === "string") {
      serialized = jsonParse(strOrObj);
      if (serialized instanceof Error) {
        return cb(serialized);
      }
    } else {
      serialized = strOrObj;
    }
    var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    jar._importCookies(serialized, function(err) {
      if (err) {
        return cb(err);
      }
      cb(null, jar);
    });
  };
  CookieJar.deserializeSync = function(strOrObj, store) {
    var serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    if (!jar.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    jar._importCookiesSync(serialized);
    return jar;
  };
  CookieJar.fromJSON = CookieJar.deserializeSync;
  CookieJar.prototype.clone = function(newStore, cb) {
    if (arguments.length === 1) {
      cb = newStore;
      newStore = null;
    }
    this.serialize(function(err, serialized) {
      if (err) {
        return cb(err);
      }
      CookieJar.deserialize(serialized, newStore, cb);
    });
  };
  CAN_BE_SYNC.push("removeAllCookies");
  CookieJar.prototype.removeAllCookies = function(cb) {
    var store = this.store;
    if (store.removeAllCookies instanceof Function && store.removeAllCookies !== Store.prototype.removeAllCookies) {
      return store.removeAllCookies(cb);
    }
    store.getAllCookies(function(err, cookies) {
      if (err) {
        return cb(err);
      }
      if (cookies.length === 0) {
        return cb(null);
      }
      var completedCount = 0;
      var removeErrors = [];
      function removeCookieCb(removeErr) {
        if (removeErr) {
          removeErrors.push(removeErr);
        }
        completedCount++;
        if (completedCount === cookies.length) {
          return cb(removeErrors.length ? removeErrors[0] : null);
        }
      }
      cookies.forEach(function(cookie) {
        store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
      });
    });
  };
  CookieJar.prototype._cloneSync = syncWrap("clone");
  CookieJar.prototype.cloneSync = function(newStore) {
    if (!newStore.synchronous) {
      throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
    }
    return this._cloneSync(newStore);
  };
  function syncWrap(method) {
    return function() {
      if (!this.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      var args = Array.prototype.slice.call(arguments);
      var syncErr, syncResult;
      args.push(function syncCb(err, result) {
        syncErr = err;
        syncResult = result;
      });
      this[method].apply(this, args);
      if (syncErr) {
        throw syncErr;
      }
      return syncResult;
    };
  }
  CAN_BE_SYNC.forEach(function(method) {
    CookieJar.prototype[method + "Sync"] = syncWrap(method);
  });
  exports.version = VERSION;
  exports.CookieJar = CookieJar;
  exports.Cookie = Cookie;
  exports.Store = Store;
  exports.MemoryCookieStore = MemoryCookieStore;
  exports.parseDate = parseDate;
  exports.formatDate = formatDate;
  exports.parse = parse;
  exports.fromJSON = fromJSON;
  exports.domainMatch = domainMatch;
  exports.defaultPath = defaultPath;
  exports.pathMatch = pathMatch;
  exports.getPublicSuffix = pubsuffix.getPublicSuffix;
  exports.cookieCompare = cookieCompare;
  exports.permuteDomain = require_permuteDomain().permuteDomain;
  exports.permutePath = permutePath;
  exports.canonicalDomain = canonicalDomain;
});

// node_modules/postman-request/lib/cookies.js
var require_cookies = __commonJS((exports) => {
  var tough = require_cookie();
  var Cookie = tough.Cookie;
  var CookieJar = tough.CookieJar;
  exports.parse = function(str) {
    if (str && str.uri) {
      str = str.uri;
    }
    if (typeof str !== "string") {
      throw new Error("The cookie function only accepts STRING as param");
    }
    return Cookie.parse(str, { loose: true });
  };
  function RequestJar(store) {
    var self2 = this;
    self2._jar = new CookieJar(store, { looseMode: true });
  }
  RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
    var self2 = this;
    return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
  };
  RequestJar.prototype.getCookieString = function(uri) {
    var self2 = this;
    return self2._jar.getCookieStringSync(uri);
  };
  RequestJar.prototype.getCookies = function(uri) {
    var self2 = this;
    return self2._jar.getCookiesSync(uri);
  };
  exports.jar = function(store) {
    return new RequestJar(store);
  };
});

// node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS((exports, module) => {
  /*!
   *  Copyright 2010 LearnBoost <dev@learnboost.com>
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var crypto = __require("crypto");
  var parse = __require("url").parse;
  var keys = [
    "acl",
    "location",
    "logging",
    "notification",
    "partNumber",
    "policy",
    "requestPayment",
    "torrent",
    "uploadId",
    "uploads",
    "versionId",
    "versioning",
    "versions",
    "website"
  ];
  function authorization(options) {
    return "AWS " + options.key + ":" + sign(options);
  }
  module.exports = authorization;
  module.exports.authorization = authorization;
  function hmacSha1(options) {
    return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
  }
  module.exports.hmacSha1 = hmacSha1;
  function sign(options) {
    options.message = stringToSign(options);
    return hmacSha1(options);
  }
  module.exports.sign = sign;
  function signQuery(options) {
    options.message = queryStringToSign(options);
    return hmacSha1(options);
  }
  module.exports.signQuery = signQuery;
  function stringToSign(options) {
    var headers = options.amazonHeaders || "";
    if (headers)
      headers += `
`;
    var r = [
      options.verb,
      options.md5,
      options.contentType,
      options.date ? options.date.toUTCString() : "",
      headers + options.resource
    ];
    return r.join(`
`);
  }
  module.exports.stringToSign = stringToSign;
  function queryStringToSign(options) {
    return `GET


` + options.date + `
` + options.resource;
  }
  module.exports.queryStringToSign = queryStringToSign;
  function canonicalizeHeaders(headers) {
    var buf = [], fields = Object.keys(headers);
    for (var i = 0, len = fields.length;i < len; ++i) {
      var field = fields[i], val = headers[field], field = field.toLowerCase();
      if (field.indexOf("x-amz") !== 0)
        continue;
      buf.push(field + ":" + val);
    }
    return buf.sort().join(`
`);
  }
  module.exports.canonicalizeHeaders = canonicalizeHeaders;
  function canonicalizeResource(resource) {
    var url = parse(resource, true), path = url.pathname, buf = [];
    Object.keys(url.query).forEach(function(key) {
      if (!~keys.indexOf(key))
        return;
      var val = url.query[key] == "" ? "" : "=" + encodeURIComponent(url.query[key]);
      buf.push(key + val);
    });
    return path + (buf.length ? "?" + buf.sort().join("&") : "");
  }
  module.exports.canonicalizeResource = canonicalizeResource;
});

// node_modules/aws4/lru.js
var require_lru = __commonJS((exports, module) => {
  module.exports = function(size) {
    return new LruCache(size);
  };
  function LruCache(size) {
    this.capacity = size | 0;
    this.map = Object.create(null);
    this.list = new DoublyLinkedList;
  }
  LruCache.prototype.get = function(key) {
    var node = this.map[key];
    if (node == null)
      return;
    this.used(node);
    return node.val;
  };
  LruCache.prototype.set = function(key, val) {
    var node = this.map[key];
    if (node != null) {
      node.val = val;
    } else {
      if (!this.capacity)
        this.prune();
      if (!this.capacity)
        return false;
      node = new DoublyLinkedNode(key, val);
      this.map[key] = node;
      this.capacity--;
    }
    this.used(node);
    return true;
  };
  LruCache.prototype.used = function(node) {
    this.list.moveToFront(node);
  };
  LruCache.prototype.prune = function() {
    var node = this.list.pop();
    if (node != null) {
      delete this.map[node.key];
      this.capacity++;
    }
  };
  function DoublyLinkedList() {
    this.firstNode = null;
    this.lastNode = null;
  }
  DoublyLinkedList.prototype.moveToFront = function(node) {
    if (this.firstNode == node)
      return;
    this.remove(node);
    if (this.firstNode == null) {
      this.firstNode = node;
      this.lastNode = node;
      node.prev = null;
      node.next = null;
    } else {
      node.prev = null;
      node.next = this.firstNode;
      node.next.prev = node;
      this.firstNode = node;
    }
  };
  DoublyLinkedList.prototype.pop = function() {
    var lastNode = this.lastNode;
    if (lastNode != null) {
      this.remove(lastNode);
    }
    return lastNode;
  };
  DoublyLinkedList.prototype.remove = function(node) {
    if (this.firstNode == node) {
      this.firstNode = node.next;
    } else if (node.prev != null) {
      node.prev.next = node.next;
    }
    if (this.lastNode == node) {
      this.lastNode = node.prev;
    } else if (node.next != null) {
      node.next.prev = node.prev;
    }
  };
  function DoublyLinkedNode(key, val) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
});

// node_modules/aws4/aws4.js
var require_aws4 = __commonJS((exports) => {
  var aws4 = exports;
  var url = __require("url");
  var querystring = __require("querystring");
  var crypto = __require("crypto");
  var lru = require_lru();
  var credentialsCache = lru(1000);
  function hmac(key, string, encoding) {
    return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
  }
  function hash(string, encoding) {
    return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
  }
  function encodeRfc3986(urlEncodedString) {
    return urlEncodedString.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeRfc3986Full(str) {
    return encodeRfc3986(encodeURIComponent(str));
  }
  var HEADERS_TO_IGNORE = {
    authorization: true,
    connection: true,
    "x-amzn-trace-id": true,
    "user-agent": true,
    expect: true,
    "presigned-expires": true,
    range: true
  };
  function RequestSigner(request, credentials) {
    if (typeof request === "string")
      request = url.parse(request);
    var headers = request.headers = Object.assign({}, request.headers || {}), hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);
    this.request = request;
    this.credentials = credentials || this.defaultCredentials();
    this.service = request.service || hostParts[0] || "";
    this.region = request.region || hostParts[1] || "us-east-1";
    if (this.service === "email")
      this.service = "ses";
    if (!request.method && request.body)
      request.method = "POST";
    if (!headers.Host && !headers.host) {
      headers.Host = request.hostname || request.host || this.createHost();
      if (request.port)
        headers.Host += ":" + request.port;
    }
    if (!request.hostname && !request.host)
      request.hostname = headers.Host || headers.host;
    this.isCodeCommitGit = this.service === "codecommit" && request.method === "GIT";
    this.extraHeadersToIgnore = request.extraHeadersToIgnore || Object.create(null);
    this.extraHeadersToInclude = request.extraHeadersToInclude || Object.create(null);
  }
  RequestSigner.prototype.matchHost = function(host) {
    var match = (host || "").match(/([^\.]{1,63})\.(?:([^\.]{0,63})\.)?amazonaws\.com(\.cn)?$/);
    var hostParts = (match || []).slice(1, 3);
    if (hostParts[1] === "es" || hostParts[1] === "aoss")
      hostParts = hostParts.reverse();
    if (hostParts[1] == "s3") {
      hostParts[0] = "s3";
      hostParts[1] = "us-east-1";
    } else {
      for (var i = 0;i < 2; i++) {
        if (/^s3-/.test(hostParts[i])) {
          hostParts[1] = hostParts[i].slice(3);
          hostParts[0] = "s3";
          break;
        }
      }
    }
    return hostParts;
  };
  RequestSigner.prototype.isSingleRegion = function() {
    if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
      return true;
    return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
  };
  RequestSigner.prototype.createHost = function() {
    var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
    return subdomain + region + ".amazonaws.com";
  };
  RequestSigner.prototype.prepareRequest = function() {
    this.parsePath();
    var request = this.request, headers = request.headers, query;
    if (request.signQuery) {
      this.parsedPath.query = query = this.parsedPath.query || {};
      if (this.credentials.sessionToken)
        query["X-Amz-Security-Token"] = this.credentials.sessionToken;
      if (this.service === "s3" && !query["X-Amz-Expires"])
        query["X-Amz-Expires"] = 86400;
      if (query["X-Amz-Date"])
        this.datetime = query["X-Amz-Date"];
      else
        query["X-Amz-Date"] = this.getDateTime();
      query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
      query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
      query["X-Amz-SignedHeaders"] = this.signedHeaders();
    } else {
      if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
        if (request.body && !headers["Content-Type"] && !headers["content-type"])
          headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
        if (request.body && !headers["Content-Length"] && !headers["content-length"])
          headers["Content-Length"] = Buffer.byteLength(request.body);
        if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
          headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
          headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
        if (headers["X-Amz-Date"] || headers["x-amz-date"])
          this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
        else
          headers["X-Amz-Date"] = this.getDateTime();
      }
      delete headers.Authorization;
      delete headers.authorization;
    }
  };
  RequestSigner.prototype.sign = function() {
    if (!this.parsedPath)
      this.prepareRequest();
    if (this.request.signQuery) {
      this.parsedPath.query["X-Amz-Signature"] = this.signature();
    } else {
      this.request.headers.Authorization = this.authHeader();
    }
    this.request.path = this.formatPath();
    return this.request;
  };
  RequestSigner.prototype.getDateTime = function() {
    if (!this.datetime) {
      var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date);
      this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
      if (this.isCodeCommitGit)
        this.datetime = this.datetime.slice(0, -1);
    }
    return this.datetime;
  };
  RequestSigner.prototype.getDate = function() {
    return this.getDateTime().substr(0, 8);
  };
  RequestSigner.prototype.authHeader = function() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
      "SignedHeaders=" + this.signedHeaders(),
      "Signature=" + this.signature()
    ].join(", ");
  };
  RequestSigner.prototype.signature = function() {
    var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
    if (!kCredentials) {
      kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
      kRegion = hmac(kDate, this.region);
      kService = hmac(kRegion, this.service);
      kCredentials = hmac(kService, "aws4_request");
      credentialsCache.set(cacheKey, kCredentials);
    }
    return hmac(kCredentials, this.stringToSign(), "hex");
  };
  RequestSigner.prototype.stringToSign = function() {
    return [
      "AWS4-HMAC-SHA256",
      this.getDateTime(),
      this.credentialString(),
      hash(this.canonicalString(), "hex")
    ].join(`
`);
  };
  RequestSigner.prototype.canonicalString = function() {
    if (!this.parsedPath)
      this.prepareRequest();
    var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
    if (this.service === "s3" && this.request.signQuery) {
      bodyHash = "UNSIGNED-PAYLOAD";
    } else if (this.isCodeCommitGit) {
      bodyHash = "";
    } else {
      bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
    }
    if (query) {
      var reducedQuery = Object.keys(query).reduce(function(obj2, key) {
        if (!key)
          return obj2;
        obj2[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
        return obj2;
      }, {});
      var encodedQueryPieces = [];
      Object.keys(reducedQuery).sort().forEach(function(key) {
        if (!Array.isArray(reducedQuery[key])) {
          encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
        } else {
          reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val) {
            encodedQueryPieces.push(key + "=" + val);
          });
        }
      });
      queryStr = encodedQueryPieces.join("&");
    }
    if (pathStr !== "/") {
      if (normalizePath)
        pathStr = pathStr.replace(/\/{2,}/g, "/");
      pathStr = pathStr.split("/").reduce(function(path, piece) {
        if (normalizePath && piece === "..") {
          path.pop();
        } else if (!normalizePath || piece !== ".") {
          if (decodePath)
            piece = decodeURIComponent(piece.replace(/\+/g, " "));
          path.push(encodeRfc3986Full(piece));
        }
        return path;
      }, []).join("/");
      if (pathStr[0] !== "/")
        pathStr = "/" + pathStr;
      if (decodeSlashesInPath)
        pathStr = pathStr.replace(/%2F/g, "/");
    }
    return [
      this.request.method || "GET",
      pathStr,
      queryStr,
      this.canonicalHeaders() + `
`,
      this.signedHeaders(),
      bodyHash
    ].join(`
`);
  };
  RequestSigner.prototype.filterHeaders = function() {
    var headers = this.request.headers, extraHeadersToInclude = this.extraHeadersToInclude, extraHeadersToIgnore = this.extraHeadersToIgnore;
    this.filteredHeaders = Object.keys(headers).map(function(key) {
      return [key.toLowerCase(), headers[key]];
    }).filter(function(entry) {
      return extraHeadersToInclude[entry[0]] || HEADERS_TO_IGNORE[entry[0]] == null && !extraHeadersToIgnore[entry[0]];
    }).sort(function(a, b) {
      return a[0] < b[0] ? -1 : 1;
    });
  };
  RequestSigner.prototype.canonicalHeaders = function() {
    if (!this.filteredHeaders)
      this.filterHeaders();
    return this.filteredHeaders.map(function(entry) {
      return entry[0] + ":" + entry[1].toString().trim().replace(/\s+/g, " ");
    }).join(`
`);
  };
  RequestSigner.prototype.signedHeaders = function() {
    if (!this.filteredHeaders)
      this.filterHeaders();
    return this.filteredHeaders.map(function(entry) {
      return entry[0];
    }).join(";");
  };
  RequestSigner.prototype.credentialString = function() {
    return [
      this.getDate(),
      this.region,
      this.service,
      "aws4_request"
    ].join("/");
  };
  RequestSigner.prototype.defaultCredentials = function() {
    var env = process.env;
    return {
      accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
      secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
      sessionToken: env.AWS_SESSION_TOKEN
    };
  };
  RequestSigner.prototype.parsePath = function() {
    var path = this.request.path || "/";
    if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
      path = encodeURI(decodeURI(path));
    }
    var queryIx = path.indexOf("?"), query = null;
    if (queryIx >= 0) {
      query = querystring.parse(path.slice(queryIx + 1));
      path = path.slice(0, queryIx);
    }
    this.parsedPath = {
      path,
      query
    };
  };
  RequestSigner.prototype.formatPath = function() {
    var path = this.parsedPath.path, query = this.parsedPath.query;
    if (!query)
      return path;
    if (query[""] != null)
      delete query[""];
    return path + "?" + encodeRfc3986(querystring.stringify(query));
  };
  aws4.RequestSigner = RequestSigner;
  aws4.sign = function(request, credentials) {
    return new RequestSigner(request, credentials).sign();
  };
});

// node_modules/uuid/lib/rng.js
var require_rng = __commonJS((exports, module) => {
  var crypto = __require("crypto");
  module.exports = function nodeRNG() {
    return crypto.randomBytes(16);
  };
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports, module) => {
  var byteToHex = [];
  for (i = 0;i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  var i;
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  module.exports = bytesToUuid;
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS((exports, module) => {
  var rng = require_rng();
  var bytesToUuid = require_bytesToUuid();
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0;ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  module.exports = v4;
});

// node_modules/assert-plus/assert.js
var require_assert = __commonJS((exports, module) => {
  var assert = __require("assert");
  var Stream = __require("stream").Stream;
  var util = __require("util");
  var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
      message: util.format("%s (%s) is required", name, expected),
      actual: actual === undefined ? typeof arg : actual(arg),
      expected,
      operator: oper || "===",
      stackStartFunction: _toss.caller
    });
  }
  function _getClass(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1);
  }
  function noop() {}
  var types = {
    bool: {
      check: function(arg) {
        return typeof arg === "boolean";
      }
    },
    func: {
      check: function(arg) {
        return typeof arg === "function";
      }
    },
    string: {
      check: function(arg) {
        return typeof arg === "string";
      }
    },
    object: {
      check: function(arg) {
        return typeof arg === "object" && arg !== null;
      }
    },
    number: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg);
      }
    },
    finite: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
      }
    },
    buffer: {
      check: function(arg) {
        return Buffer.isBuffer(arg);
      },
      operator: "Buffer.isBuffer"
    },
    array: {
      check: function(arg) {
        return Array.isArray(arg);
      },
      operator: "Array.isArray"
    },
    stream: {
      check: function(arg) {
        return arg instanceof Stream;
      },
      operator: "instanceof",
      actual: _getClass
    },
    date: {
      check: function(arg) {
        return arg instanceof Date;
      },
      operator: "instanceof",
      actual: _getClass
    },
    regexp: {
      check: function(arg) {
        return arg instanceof RegExp;
      },
      operator: "instanceof",
      actual: _getClass
    },
    uuid: {
      check: function(arg) {
        return typeof arg === "string" && UUID_REGEXP.test(arg);
      },
      operator: "isUUID"
    }
  };
  function _setExports(ndebug) {
    var keys = Object.keys(types);
    var out;
    if (process.env.NODE_NDEBUG) {
      out = noop;
    } else {
      out = function(arg, msg) {
        if (!arg) {
          _toss(msg, "true", arg);
        }
      };
    }
    keys.forEach(function(k) {
      if (ndebug) {
        out[k] = noop;
        return;
      }
      var type = types[k];
      out[k] = function(arg, msg) {
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optional" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      out[name] = function(arg, msg) {
        if (arg === undefined || arg === null) {
          return;
        }
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "arrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0;i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optionalArrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (arg === undefined || arg === null) {
          return;
        }
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0;i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    Object.keys(assert).forEach(function(k) {
      if (k === "AssertionError") {
        out[k] = assert[k];
        return;
      }
      if (ndebug) {
        out[k] = noop;
        return;
      }
      out[k] = assert[k];
    });
    out._setExports = _setExports;
    return out;
  }
  module.exports = _setExports(process.env.NODE_NDEBUG);
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {}
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/sshpk/lib/algs.js
var require_algs = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var algInfo = {
    dsa: {
      parts: ["p", "q", "g", "y"],
      sizePart: "p"
    },
    rsa: {
      parts: ["e", "n"],
      sizePart: "n"
    },
    ecdsa: {
      parts: ["curve", "Q"],
      sizePart: "Q"
    },
    ed25519: {
      parts: ["A"],
      sizePart: "A"
    }
  };
  algInfo["curve25519"] = algInfo["ed25519"];
  var algPrivInfo = {
    dsa: {
      parts: ["p", "q", "g", "y", "x"]
    },
    rsa: {
      parts: ["n", "e", "d", "iqmp", "p", "q"]
    },
    ecdsa: {
      parts: ["curve", "Q", "d"]
    },
    ed25519: {
      parts: ["A", "k"]
    }
  };
  algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
  var hashAlgs = {
    md5: true,
    sha1: true,
    sha256: true,
    sha384: true,
    sha512: true
  };
  var curves = {
    nistp256: {
      size: 256,
      pkcs8oid: "1.2.840.10045.3.1.7",
      p: Buffer2.from(("00" + "ffffffff 00000001 00000000 00000000" + "00000000 ffffffff ffffffff ffffffff").replace(/ /g, ""), "hex"),
      a: Buffer2.from(("00" + "FFFFFFFF 00000001 00000000 00000000" + "00000000 FFFFFFFF FFFFFFFF FFFFFFFC").replace(/ /g, ""), "hex"),
      b: Buffer2.from(("5ac635d8 aa3a93e7 b3ebbd55 769886bc" + "651d06b0 cc53b0f6 3bce3c3e 27d2604b").replace(/ /g, ""), "hex"),
      s: Buffer2.from(("00" + "c49d3608 86e70493 6a6678e1 139d26b7" + "819f7e90").replace(/ /g, ""), "hex"),
      n: Buffer2.from(("00" + "ffffffff 00000000 ffffffff ffffffff" + "bce6faad a7179e84 f3b9cac2 fc632551").replace(/ /g, ""), "hex"),
      G: Buffer2.from(("04" + "6b17d1f2 e12c4247 f8bce6e5 63a440f2" + "77037d81 2deb33a0 f4a13945 d898c296" + "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16" + "2bce3357 6b315ece cbb64068 37bf51f5").replace(/ /g, ""), "hex")
    },
    nistp384: {
      size: 384,
      pkcs8oid: "1.3.132.0.34",
      p: Buffer2.from(("00" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff fffffffe" + "ffffffff 00000000 00000000 ffffffff").replace(/ /g, ""), "hex"),
      a: Buffer2.from(("00" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE" + "FFFFFFFF 00000000 00000000 FFFFFFFC").replace(/ /g, ""), "hex"),
      b: Buffer2.from(("b3312fa7 e23ee7e4 988e056b e3f82d19" + "181d9c6e fe814112 0314088f 5013875a" + "c656398d 8a2ed19d 2a85c8ed d3ec2aef").replace(/ /g, ""), "hex"),
      s: Buffer2.from(("00" + "a335926a a319a27a 1d00896a 6773a482" + "7acdac73").replace(/ /g, ""), "hex"),
      n: Buffer2.from(("00" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff c7634d81 f4372ddf" + "581a0db2 48b0a77a ecec196a ccc52973").replace(/ /g, ""), "hex"),
      G: Buffer2.from(("04" + "aa87ca22 be8b0537 8eb1c71e f320ad74" + "6e1d3b62 8ba79b98 59f741e0 82542a38" + "5502f25d bf55296c 3a545e38 72760ab7" + "3617de4a 96262c6f 5d9e98bf 9292dc29" + "f8f41dbd 289a147c e9da3113 b5f0b8c0" + "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f").replace(/ /g, ""), "hex")
    },
    nistp521: {
      size: 521,
      pkcs8oid: "1.3.132.0.35",
      p: Buffer2.from(("01ffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff ffffffff" + "ffff").replace(/ /g, ""), "hex"),
      a: Buffer2.from(("01FF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC").replace(/ /g, ""), "hex"),
      b: Buffer2.from(("51" + "953eb961 8e1c9a1f 929a21a0 b68540ee" + "a2da725b 99b315f3 b8b48991 8ef109e1" + "56193951 ec7e937b 1652c0bd 3bb1bf07" + "3573df88 3d2c34f1 ef451fd4 6b503f00").replace(/ /g, ""), "hex"),
      s: Buffer2.from(("00" + "d09e8800 291cb853 96cc6717 393284aa" + "a0da64ba").replace(/ /g, ""), "hex"),
      n: Buffer2.from(("01ff" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff fffffffa" + "51868783 bf2f966b 7fcc0148 f709a5d0" + "3bb5c9b8 899c47ae bb6fb71e 91386409").replace(/ /g, ""), "hex"),
      G: Buffer2.from(("04" + "00c6 858e06b7 0404e9cd 9e3ecb66 2395b442" + "9c648139 053fb521 f828af60 6b4d3dba" + "a14b5e77 efe75928 fe1dc127 a2ffa8de" + "3348b3c1 856a429b f97e7e31 c2e5bd66" + "0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9" + "98f54449 579b4468 17afbd17 273e662c" + "97ee7299 5ef42640 c550b901 3fad0761" + "353c7086 a272c240 88be9476 9fd16650").replace(/ /g, ""), "hex")
    }
  };
  module.exports = {
    info: algInfo,
    privInfo: algPrivInfo,
    hashAlgs,
    curves
  };
});

// node_modules/sshpk/lib/errors.js
var require_errors = __commonJS((exports, module) => {
  var assert = require_assert();
  var util = __require("util");
  function FingerprintFormatError(fp, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, FingerprintFormatError);
    this.name = "FingerprintFormatError";
    this.fingerprint = fp;
    this.format = format;
    this.message = "Fingerprint format is not supported, or is invalid: ";
    if (fp !== undefined)
      this.message += " fingerprint = " + fp;
    if (format !== undefined)
      this.message += " format = " + format;
  }
  util.inherits(FingerprintFormatError, Error);
  function InvalidAlgorithmError(alg) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, InvalidAlgorithmError);
    this.name = "InvalidAlgorithmError";
    this.algorithm = alg;
    this.message = 'Algorithm "' + alg + '" is not supported';
  }
  util.inherits(InvalidAlgorithmError, Error);
  function KeyParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyParseError);
    this.name = "KeyParseError";
    this.format = format;
    this.keyName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format + " format key: " + innerErr.message;
  }
  util.inherits(KeyParseError, Error);
  function SignatureParseError(type, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, SignatureParseError);
    this.name = "SignatureParseError";
    this.type = type;
    this.format = format;
    this.innerErr = innerErr;
    this.message = "Failed to parse the given data as a " + type + " signature in " + format + " format: " + innerErr.message;
  }
  util.inherits(SignatureParseError, Error);
  function CertificateParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, CertificateParseError);
    this.name = "CertificateParseError";
    this.format = format;
    this.certName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format + " format certificate: " + innerErr.message;
  }
  util.inherits(CertificateParseError, Error);
  function KeyEncryptedError(name, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyEncryptedError);
    this.name = "KeyEncryptedError";
    this.format = format;
    this.keyName = name;
    this.message = "The " + format + " format key " + name + " is " + "encrypted (password-protected), and no passphrase was " + "provided in `options`";
  }
  util.inherits(KeyEncryptedError, Error);
  module.exports = {
    FingerprintFormatError,
    InvalidAlgorithmError,
    KeyParseError,
    SignatureParseError,
    KeyEncryptedError,
    CertificateParseError
  };
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS((exports, module) => {
  module.exports = {
    newInvalidAsn1Error: function(msg) {
      var e = new Error;
      e.name = "InvalidAsn1Error";
      e.message = msg || "";
      return e;
    }
  };
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS((exports, module) => {
  module.exports = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128
  };
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS((exports, module) => {
  var assert = __require("assert");
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types();
  var errors = require_errors2();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  function Reader(data) {
    if (!data || !Buffer2.isBuffer(data))
      throw new TypeError("data must be a node Buffer");
    this._buf = data;
    this._size = data.length;
    this._len = 0;
    this._offset = 0;
  }
  Object.defineProperty(Reader.prototype, "length", {
    enumerable: true,
    get: function() {
      return this._len;
    }
  });
  Object.defineProperty(Reader.prototype, "offset", {
    enumerable: true,
    get: function() {
      return this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "remain", {
    get: function() {
      return this._size - this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "buffer", {
    get: function() {
      return this._buf.slice(this._offset);
    }
  });
  Reader.prototype.readByte = function(peek) {
    if (this._size - this._offset < 1)
      return null;
    var b = this._buf[this._offset] & 255;
    if (!peek)
      this._offset += 1;
    return b;
  };
  Reader.prototype.peek = function() {
    return this.readByte(true);
  };
  Reader.prototype.readLength = function(offset) {
    if (offset === undefined)
      offset = this._offset;
    if (offset >= this._size)
      return null;
    var lenB = this._buf[offset++] & 255;
    if (lenB === null)
      return null;
    if ((lenB & 128) === 128) {
      lenB &= 127;
      if (lenB === 0)
        throw newInvalidAsn1Error("Indefinite length not supported");
      if (lenB > 4)
        throw newInvalidAsn1Error("encoding too long");
      if (this._size - offset < lenB)
        return null;
      this._len = 0;
      for (var i = 0;i < lenB; i++)
        this._len = (this._len << 8) + (this._buf[offset++] & 255);
    } else {
      this._len = lenB;
    }
    return offset;
  };
  Reader.prototype.readSequence = function(tag) {
    var seq = this.peek();
    if (seq === null)
      return null;
    if (tag !== undefined && tag !== seq)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    this._offset = o;
    return seq;
  };
  Reader.prototype.readInt = function() {
    return this._readTag(ASN1.Integer);
  };
  Reader.prototype.readBoolean = function() {
    return this._readTag(ASN1.Boolean) === 0 ? false : true;
  };
  Reader.prototype.readEnumeration = function() {
    return this._readTag(ASN1.Enumeration);
  };
  Reader.prototype.readString = function(tag, retbuf) {
    if (!tag)
      tag = ASN1.OctetString;
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    if (this.length === 0)
      return retbuf ? Buffer2.alloc(0) : "";
    var str = this._buf.slice(this._offset, this._offset + this.length);
    this._offset += this.length;
    return retbuf ? str : str.toString("utf8");
  };
  Reader.prototype.readOID = function(tag) {
    if (!tag)
      tag = ASN1.OID;
    var b = this.readString(tag, true);
    if (b === null)
      return null;
    var values = [];
    var value = 0;
    for (var i = 0;i < b.length; i++) {
      var byte = b[i] & 255;
      value <<= 7;
      value += byte & 127;
      if ((byte & 128) === 0) {
        values.push(value);
        value = 0;
      }
    }
    value = values.shift();
    values.unshift(value % 40);
    values.unshift(value / 40 >> 0);
    return values.join(".");
  };
  Reader.prototype._readTag = function(tag) {
    assert.ok(tag !== undefined);
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > 4)
      throw newInvalidAsn1Error("Integer too long: " + this.length);
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    var fb = this._buf[this._offset];
    var value = 0;
    for (var i = 0;i < this.length; i++) {
      value <<= 8;
      value |= this._buf[this._offset++] & 255;
    }
    if ((fb & 128) === 128 && i !== 4)
      value -= 1 << i * 8;
    return value >> 0;
  };
  module.exports = Reader;
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS((exports, module) => {
  var assert = __require("assert");
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types();
  var errors = require_errors2();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  var DEFAULT_OPTS = {
    size: 1024,
    growthFactor: 8
  };
  function merge(from, to) {
    assert.ok(from);
    assert.equal(typeof from, "object");
    assert.ok(to);
    assert.equal(typeof to, "object");
    var keys = Object.getOwnPropertyNames(from);
    keys.forEach(function(key) {
      if (to[key])
        return;
      var value = Object.getOwnPropertyDescriptor(from, key);
      Object.defineProperty(to, key, value);
    });
    return to;
  }
  function Writer(options) {
    options = merge(DEFAULT_OPTS, options || {});
    this._buf = Buffer2.alloc(options.size || 1024);
    this._size = this._buf.length;
    this._offset = 0;
    this._options = options;
    this._seq = [];
  }
  Object.defineProperty(Writer.prototype, "buffer", {
    get: function() {
      if (this._seq.length)
        throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
      return this._buf.slice(0, this._offset);
    }
  });
  Writer.prototype.writeByte = function(b) {
    if (typeof b !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(1);
    this._buf[this._offset++] = b;
  };
  Writer.prototype.writeInt = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Integer;
    var sz = 4;
    while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
      sz--;
      i <<= 8;
    }
    if (sz > 4)
      throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
    this._ensure(2 + sz);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = sz;
    while (sz-- > 0) {
      this._buf[this._offset++] = (i & 4278190080) >>> 24;
      i <<= 8;
    }
  };
  Writer.prototype.writeNull = function() {
    this.writeByte(ASN1.Null);
    this.writeByte(0);
  };
  Writer.prototype.writeEnumeration = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Enumeration;
    return this.writeInt(i, tag);
  };
  Writer.prototype.writeBoolean = function(b, tag) {
    if (typeof b !== "boolean")
      throw new TypeError("argument must be a Boolean");
    if (typeof tag !== "number")
      tag = ASN1.Boolean;
    this._ensure(3);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = 1;
    this._buf[this._offset++] = b ? 255 : 0;
  };
  Writer.prototype.writeString = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string (was: " + typeof s + ")");
    if (typeof tag !== "number")
      tag = ASN1.OctetString;
    var len = Buffer2.byteLength(s);
    this.writeByte(tag);
    this.writeLength(len);
    if (len) {
      this._ensure(len);
      this._buf.write(s, this._offset);
      this._offset += len;
    }
  };
  Writer.prototype.writeBuffer = function(buf, tag) {
    if (typeof tag !== "number")
      throw new TypeError("tag must be a number");
    if (!Buffer2.isBuffer(buf))
      throw new TypeError("argument must be a buffer");
    this.writeByte(tag);
    this.writeLength(buf.length);
    this._ensure(buf.length);
    buf.copy(this._buf, this._offset, 0, buf.length);
    this._offset += buf.length;
  };
  Writer.prototype.writeStringArray = function(strings) {
    if (!strings instanceof Array)
      throw new TypeError("argument must be an Array[String]");
    var self2 = this;
    strings.forEach(function(s) {
      self2.writeString(s);
    });
  };
  Writer.prototype.writeOID = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string");
    if (typeof tag !== "number")
      tag = ASN1.OID;
    if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
      throw new Error("argument is not a valid OID string");
    function encodeOctet(bytes2, octet) {
      if (octet < 128) {
        bytes2.push(octet);
      } else if (octet < 16384) {
        bytes2.push(octet >>> 7 | 128);
        bytes2.push(octet & 127);
      } else if (octet < 2097152) {
        bytes2.push(octet >>> 14 | 128);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else if (octet < 268435456) {
        bytes2.push(octet >>> 21 | 128);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else {
        bytes2.push((octet >>> 28 | 128) & 255);
        bytes2.push((octet >>> 21 | 128) & 255);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      }
    }
    var tmp = s.split(".");
    var bytes = [];
    bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
    tmp.slice(2).forEach(function(b) {
      encodeOctet(bytes, parseInt(b, 10));
    });
    var self2 = this;
    this._ensure(2 + bytes.length);
    this.writeByte(tag);
    this.writeLength(bytes.length);
    bytes.forEach(function(b) {
      self2.writeByte(b);
    });
  };
  Writer.prototype.writeLength = function(len) {
    if (typeof len !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(4);
    if (len <= 127) {
      this._buf[this._offset++] = len;
    } else if (len <= 255) {
      this._buf[this._offset++] = 129;
      this._buf[this._offset++] = len;
    } else if (len <= 65535) {
      this._buf[this._offset++] = 130;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else if (len <= 16777215) {
      this._buf[this._offset++] = 131;
      this._buf[this._offset++] = len >> 16;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else {
      throw newInvalidAsn1Error("Length too long (> 4 bytes)");
    }
  };
  Writer.prototype.startSequence = function(tag) {
    if (typeof tag !== "number")
      tag = ASN1.Sequence | ASN1.Constructor;
    this.writeByte(tag);
    this._seq.push(this._offset);
    this._ensure(3);
    this._offset += 3;
  };
  Writer.prototype.endSequence = function() {
    var seq = this._seq.pop();
    var start = seq + 3;
    var len = this._offset - start;
    if (len <= 127) {
      this._shift(start, len, -2);
      this._buf[seq] = len;
    } else if (len <= 255) {
      this._shift(start, len, -1);
      this._buf[seq] = 129;
      this._buf[seq + 1] = len;
    } else if (len <= 65535) {
      this._buf[seq] = 130;
      this._buf[seq + 1] = len >> 8;
      this._buf[seq + 2] = len;
    } else if (len <= 16777215) {
      this._shift(start, len, 1);
      this._buf[seq] = 131;
      this._buf[seq + 1] = len >> 16;
      this._buf[seq + 2] = len >> 8;
      this._buf[seq + 3] = len;
    } else {
      throw newInvalidAsn1Error("Sequence too long");
    }
  };
  Writer.prototype._shift = function(start, len, shift) {
    assert.ok(start !== undefined);
    assert.ok(len !== undefined);
    assert.ok(shift);
    this._buf.copy(this._buf, start + shift, start, start + len);
    this._offset += shift;
  };
  Writer.prototype._ensure = function(len) {
    assert.ok(len);
    if (this._size - this._offset < len) {
      var sz = this._size * this._options.growthFactor;
      if (sz - this._offset < len)
        sz += len;
      var buf = Buffer2.alloc(sz);
      this._buf.copy(buf, 0, 0, this._offset);
      this._buf = buf;
      this._size = sz;
    }
  };
  module.exports = Writer;
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS((exports, module) => {
  var errors = require_errors2();
  var types = require_types();
  var Reader = require_reader();
  var Writer = require_writer();
  module.exports = {
    Reader,
    Writer
  };
  for (t in types) {
    if (types.hasOwnProperty(t))
      module.exports[t] = types[t];
  }
  var t;
  for (e in errors) {
    if (errors.hasOwnProperty(e))
      module.exports[e] = errors[e];
  }
  var e;
});

// node_modules/asn1/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Ber = require_ber();
  module.exports = {
    Ber,
    BerReader: Ber.Reader,
    BerWriter: Ber.Writer
  };
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS((exports, module) => {
  (function() {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l2 = this[i] & 32767;
        var h = this[i++] >> 15;
        var m = xh * l2 + h * xl;
        l2 = xl * l2 + ((m & 32767) << 15) + w[j] + (c & 1073741823);
        c = (l2 >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l2 & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l2 = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l2 + h * xl;
        l2 = xl * l2 + ((m & 16383) << 14) + w[j] + c;
        c = (l2 >> 28) + (m >> 14) + xh * h;
        w[j++] = l2 & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array;
    var rr, vv;
    rr = 48;
    for (vv = 0;vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = 97;
    for (vv = 10;vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = 65;
    for (vv = 10;vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1;i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & (1 << p) - 1) << k - p;
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t2;
      if ((t2 = x >>> 16) != 0) {
        x = t2;
        r += 16;
      }
      if ((t2 = x >> 8) != 0) {
        x = t2;
        r += 8;
      }
      if ((t2 = x >> 4) != 0) {
        x = t2;
        r += 4;
      }
      if ((t2 = x >> 2) != 0) {
        x = t2;
        r += 2;
      }
      if ((t2 = x >> 1) != 0) {
        x = t2;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1;i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1;i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n;i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1;i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1;i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1;i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0)
        r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = this.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0;i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0;i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q2, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
      y.dlShiftTo(j, t2);
      if (r.compareTo(t2) >= 0) {
        r[r.t++] = 1;
        r.subTo(t2, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t2);
      t2.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t2);
          r.subTo(t2, r);
          while (r[i] < --qd)
            r.subTo(t2, r);
        }
      }
      if (q2 != null) {
        r.drShiftTo(ys, q2);
        if (ts != ms)
          BigInteger.ZERO.subTo(q2, q2);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0;i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z2.mulTo(r2, g, r);
        else {
          var t2 = r;
          r = r2;
          r2 = t2;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven())
        z2 = new Classic(m);
      else
        z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
      this.divRemTo(d, y, z2);
      while (y.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0;i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array, t2 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t2 > 0)
          x[0] &= (1 << t2) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array;
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & (1 << p) - 1) << 8 - p;
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f2, m = Math.min(a.t, this.t);
      for (i = 0;i < m; ++i)
        r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f2 = a.s & this.DM;
        for (i = m;i < this.t; ++i)
          r[i] = op(this[i], f2);
        r.t = this.t;
      } else {
        f2 = this.s & this.DM;
        for (i = m;i < a.t; ++i)
          r[i] = op(f2, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0;i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0;i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0;i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q2 = nbi(), r = nbi();
      this.divRemTo(a, q2, r);
      return new Array(q2, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {}
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp);
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t;i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n);i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0);i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z2;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z2 = new Classic(m);
      else if (m.isEven())
        z2 = new Barrett(m);
      else
        z2 = new Montgomery(m);
      var g = new Array, n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z2.sqrTo(r, r2);
          else {
            t2 = r;
            r = r2;
            r2 = t2;
          }
          z2.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t2 = r;
          r = r2;
          r2 = t2;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t2 = x;
        x = y;
        y = t2;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1;i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0;i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t2 = t2 + 1 >> 1;
      if (t2 > lowprimes.length)
        t2 = lowprimes.length;
      var a = nbi();
      for (var i = 0;i < t2; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= x >> 8 & 255;
      rng_pool[rng_pptr++] ^= x >> 16 & 255;
      rng_pool[rng_pptr++] ^= x >> 24 & 255;
      if (rng_pptr >= rng_psize)
        rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array;
      rng_pptr = 0;
      var t;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t = 0;t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z = window.crypto.random(32);
          for (t = 0;t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0;rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0;i < ba.length; ++i)
        ba[i] = rng_get_byte();
    }
    function SecureRandom2() {}
    SecureRandom2.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array;
    }
    function ARC4init(key) {
      var i, j, t2;
      for (i = 0;i < 256; ++i)
        this.S[i] = i;
      j = 0;
      for (i = 0;i < 256; ++i) {
        j = j + this.S[i] + key[i % key.length] & 255;
        t2 = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t2;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t2;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t2 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t2;
      return this.S[t2 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour;
    }
    var rng_psize = 256;
    BigInteger.SecureRandom = SecureRandom2;
    BigInteger.BigInteger = BigInteger;
    if (typeof exports !== "undefined") {
      exports = module.exports = BigInteger;
    } else {
      this.BigInteger = BigInteger;
      this.SecureRandom = SecureRandom2;
    }
  }).call(exports);
});

// node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS((exports, module) => {
  var BigInteger = require_jsbn().BigInteger;
  var Barrett = BigInteger.prototype.Barrett;
  function ECFieldElementFp(q2, x) {
    this.x = x;
    this.q = q2;
  }
  function feFpEquals(other) {
    if (other == this)
      return true;
    return this.q.equals(other.q) && this.x.equals(other.x);
  }
  function feFpToBigInteger() {
    return this.x;
  }
  function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
  }
  function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
  }
  function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
  }
  function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
  }
  function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
  }
  function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
  }
  ECFieldElementFp.prototype.equals = feFpEquals;
  ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
  ECFieldElementFp.prototype.negate = feFpNegate;
  ECFieldElementFp.prototype.add = feFpAdd;
  ECFieldElementFp.prototype.subtract = feFpSubtract;
  ECFieldElementFp.prototype.multiply = feFpMultiply;
  ECFieldElementFp.prototype.square = feFpSquare;
  ECFieldElementFp.prototype.divide = feFpDivide;
  function ECPointFp(curve, x, y, z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    if (z == null) {
      this.z = BigInteger.ONE;
    } else {
      this.z = z;
    }
    this.zinv = null;
  }
  function pointFpGetX() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpGetY() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpEquals(other) {
    if (other == this)
      return true;
    if (this.isInfinity())
      return other.isInfinity();
    if (other.isInfinity())
      return this.isInfinity();
    var u, v;
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if (!u.equals(BigInteger.ZERO))
      return false;
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
  }
  function pointFpIsInfinity() {
    if (this.x == null && this.y == null)
      return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
  }
  function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
  }
  function pointFpAdd(b) {
    if (this.isInfinity())
      return b;
    if (b.isInfinity())
      return this;
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
    if (BigInteger.ZERO.equals(v)) {
      if (BigInteger.ZERO.equals(u)) {
        return this.twice();
      }
      return this.curve.getInfinity();
    }
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();
    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpTwice() {
    if (this.isInfinity())
      return this;
    if (this.y.toBigInteger().signum() == 0)
      return this.curve.getInfinity();
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();
    var w = x1.square().multiply(THREE);
    if (!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpMultiply(k) {
    if (this.isInfinity())
      return this;
    if (k.signum() == 0)
      return this.curve.getInfinity();
    var e = k;
    var h = e.multiply(new BigInteger("3"));
    var neg = this.negate();
    var R = this;
    var i;
    for (i = h.bitLength() - 2;i > 0; --i) {
      R = R.twice();
      var hBit = h.testBit(i);
      var eBit = e.testBit(i);
      if (hBit != eBit) {
        R = R.add(hBit ? this : neg);
      }
    }
    return R;
  }
  function pointFpMultiplyTwo(j, x, k) {
    var i;
    if (j.bitLength() > k.bitLength())
      i = j.bitLength() - 1;
    else
      i = k.bitLength() - 1;
    var R = this.curve.getInfinity();
    var both = this.add(x);
    while (i >= 0) {
      R = R.twice();
      if (j.testBit(i)) {
        if (k.testBit(i)) {
          R = R.add(both);
        } else {
          R = R.add(this);
        }
      } else {
        if (k.testBit(i)) {
          R = R.add(x);
        }
      }
      --i;
    }
    return R;
  }
  ECPointFp.prototype.getX = pointFpGetX;
  ECPointFp.prototype.getY = pointFpGetY;
  ECPointFp.prototype.equals = pointFpEquals;
  ECPointFp.prototype.isInfinity = pointFpIsInfinity;
  ECPointFp.prototype.negate = pointFpNegate;
  ECPointFp.prototype.add = pointFpAdd;
  ECPointFp.prototype.twice = pointFpTwice;
  ECPointFp.prototype.multiply = pointFpMultiply;
  ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
  function ECCurveFp(q2, a, b) {
    this.q = q2;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
  }
  function curveFpGetQ() {
    return this.q;
  }
  function curveFpGetA() {
    return this.a;
  }
  function curveFpGetB() {
    return this.b;
  }
  function curveFpEquals(other) {
    if (other == this)
      return true;
    return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
  }
  function curveFpGetInfinity() {
    return this.infinity;
  }
  function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
  }
  function curveReduce(x) {
    this.reducer.reduce(x);
  }
  function curveFpEncodePointHex(p) {
    if (p.isInfinity())
      return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var yHex = p.getY().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0)
      oLen++;
    while (xHex.length < oLen) {
      xHex = "0" + xHex;
    }
    while (yHex.length < oLen) {
      yHex = "0" + yHex;
    }
    return "04" + xHex + yHex;
  }
  ECCurveFp.prototype.getQ = curveFpGetQ;
  ECCurveFp.prototype.getA = curveFpGetA;
  ECCurveFp.prototype.getB = curveFpGetB;
  ECCurveFp.prototype.equals = curveFpEquals;
  ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
  ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
  ECCurveFp.prototype.reduce = curveReduce;
  ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
  ECCurveFp.prototype.decodePointHex = function(s) {
    var yIsEven;
    switch (parseInt(s.substr(0, 2), 16)) {
      case 0:
        return this.infinity;
      case 2:
        yIsEven = false;
      case 3:
        if (yIsEven == undefined)
          yIsEven = true;
        var len = s.length - 2;
        var xHex = s.substr(2, len);
        var x = this.fromBigInteger(new BigInteger(xHex, 16));
        var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
        var beta = alpha.sqrt();
        if (beta == null)
          throw "Invalid point compression";
        var betaValue = beta.toBigInteger();
        if (betaValue.testBit(0) != yIsEven) {
          beta = this.fromBigInteger(this.getQ().subtract(betaValue));
        }
        return new ECPointFp(this, x, beta);
      case 4:
      case 6:
      case 7:
        var len = (s.length - 2) / 2;
        var xHex = s.substr(2, len);
        var yHex = s.substr(len + 2, len);
        return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
      default:
        return null;
    }
  };
  ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
    if (p.isInfinity())
      return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0)
      oLen++;
    while (xHex.length < oLen)
      xHex = "0" + xHex;
    var yPrefix;
    if (p.getY().toBigInteger().isEven())
      yPrefix = "02";
    else
      yPrefix = "03";
    return yPrefix + xHex;
  };
  ECFieldElementFp.prototype.getR = function() {
    if (this.r != null)
      return this.r;
    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128) {
      var firstWord = this.q.shiftRight(bitLength - 64);
      if (firstWord.intValue() == -1) {
        this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
      }
    }
    return this.r;
  };
  ECFieldElementFp.prototype.modMult = function(x1, x2) {
    return this.modReduce(x1.multiply(x2));
  };
  ECFieldElementFp.prototype.modReduce = function(x) {
    if (this.getR() != null) {
      var qLen = q.bitLength();
      while (x.bitLength() > qLen + 1) {
        var u = x.shiftRight(qLen);
        var v = x.subtract(u.shiftLeft(qLen));
        if (!this.getR().equals(BigInteger.ONE)) {
          u = u.multiply(this.getR());
        }
        x = u.add(v);
      }
      while (x.compareTo(q) >= 0) {
        x = x.subtract(q);
      }
    } else {
      x = x.mod(q);
    }
    return x;
  };
  ECFieldElementFp.prototype.sqrt = function() {
    if (!this.q.testBit(0))
      throw "unsupported";
    if (this.q.testBit(1)) {
      var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
      return z.square().equals(this) ? z : null;
    }
    var qMinusOne = this.q.subtract(BigInteger.ONE);
    var legendreExponent = qMinusOne.shiftRight(1);
    if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
      return null;
    }
    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger.ONE);
    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));
    var U, V;
    do {
      var P;
      do {
        P = new BigInteger(this.q.bitLength(), new SecureRandom);
      } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
      var result = this.lucasSequence(P, Q, k);
      U = result[0];
      V = result[1];
      if (this.modMult(V, V).equals(fourQ)) {
        if (V.testBit(0)) {
          V = V.add(q);
        }
        V = V.shiftRight(1);
        return new ECFieldElementFp(q, V);
      }
    } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
    return null;
  };
  ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
    var n = k.bitLength();
    var s = k.getLowestSetBit();
    var Uh = BigInteger.ONE;
    var Vl = BigInteger.TWO;
    var Vh = P;
    var Ql = BigInteger.ONE;
    var Qh = BigInteger.ONE;
    for (var j = n - 1;j >= s + 1; --j) {
      Ql = this.modMult(Ql, Qh);
      if (k.testBit(j)) {
        Qh = this.modMult(Ql, Q);
        Uh = this.modMult(Uh, Vh);
        Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
      } else {
        Qh = Ql;
        Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
        Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      }
    }
    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);
    for (var j = 1;j <= s; ++j) {
      Uh = this.modMult(Uh, Vl);
      Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      Ql = this.modMult(Ql, Ql);
    }
    return [Uh, Vl];
  };
  var exports = {
    ECCurveFp,
    ECPointFp,
    ECFieldElementFp
  };
  module.exports = exports;
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports, module) => {
  (function(nacl) {
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0;i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h, l2) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l2 >> 24 & 255;
      x[i + 5] = l2 >> 16 & 255;
      x[i + 6] = l2 >> 8 & 255;
      x[i + 7] = l2 & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0;i < n; i++)
        d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z[i] = 0;
      for (i = 0;i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < 64; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < b; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z[i] = 0;
      for (i = 0;i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < 64; i++)
          c[cpos + i] = x[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < b; i++)
          c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f2, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (;i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2;i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1;i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0;i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0;i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i = 1;i < 8; i++) {
        f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
        this.h[i] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0;i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0;i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0;i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0;i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0;i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0;i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q2, b) {
      var t, c = ~(b - 1);
      for (var i = 0;i < 16; i++) {
        t = c & (p[i] ^ q2[i]);
        p[i] ^= t;
        q2[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0;i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0;j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1;i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0;i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0;i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0;a < 16; a++)
        c[a] = i[a];
      for (a = 253;a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0;a < 16; a++)
        c[a] = i[a];
      for (a = 250;a >= 0; a--) {
        S(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q2, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f2 = gf();
      for (i = 0;i < 31; i++)
        z[i] = n[i];
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0;i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254;i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f2, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f2);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f2);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0;i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l2, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0;i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0;i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l2 = al7;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l2 = K[i * 2 + 1];
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l2 = wl[i % 16];
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l2 = tl;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l2 = bl3;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l2 = tl;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0;j < 16; j++) {
              h = wh[j];
              l2 = wl[j];
              a = l2 & 65535;
              b = l2 >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l2 = wl[(j + 9) % 16];
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l2 = al0;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l2 = hl[0];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l2 = al1;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l2 = hl[1];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l2 = al2;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l2 = hl[2];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l2 = al3;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l2 = hl[3];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l2 = al4;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l2 = hl[4];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l2 = al5;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l2 = hl[5];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l2 = al6;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l2 = hl[6];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l2 = al7;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l2 = hl[7];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0;i < n; i++)
        x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0;i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q2) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q2[1], q2[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q2[0], q2[1]);
      M(b, b, t);
      M(c, p[3], q2[3]);
      M(c, c, D2);
      M(d, p[2], q2[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f2, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f2);
      M(p[1], h, g);
      M(p[2], g, f2);
      M(p[3], e, h);
    }
    function cswap(p, q2, b) {
      var i;
      for (i = 0;i < 4; i++) {
        sel25519(p[i], q2[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q2, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255;i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q2, b);
        add(q2, p);
        add(p, p);
        cswap(p, q2, b);
      }
    }
    function scalarbase(p, s) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      M(q2[3], X, Y);
      scalarmult(p, q2, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0;i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63;i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12;j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0;j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0;j < 32; j++)
        x[j] -= carry * L[j];
      for (i = 0;i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0;i < 64; i++)
        x[i] = r[i];
      for (i = 0;i < 64; i++)
        r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0;i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0;i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32;i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0;i < 64; i++)
        x[i] = 0;
      for (i = 0;i < 32; i++)
        x[i] = r[i];
      for (i = 0;i < 32; i++) {
        for (j = 0;j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i = 0;i < n; i++)
        m[i] = sm[i];
      for (i = 0;i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q2, h);
      scalarbase(q2, sm.subarray(32));
      add(p, q2);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0;i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0;i < n; i++)
        m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      var t, i;
      for (i = 0;i < arguments.length; i++) {
        if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
          throw new TypeError("unexpected type " + t + ", use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0;i < arr.length; i++)
        arr[i] = 0;
    }
    if (!nacl.util) {
      nacl.util = {};
      nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
        throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
      };
    }
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0;i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0;i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return false;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
        return false;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p);
      return q2;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      if (arguments.length !== 2)
        throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0;i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0;i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0;i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0;i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0;i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0;i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0)
        return false;
      if (x.length !== y.length)
        return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto && crypto.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0;i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0;i < n; i++)
            x[i] = v[i];
          cleanup(v);
        });
      } else if (true) {
        crypto = __require("crypto");
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto.randomBytes(n);
            for (i = 0;i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module !== "undefined" && exports ? exports : self.nacl = self.nacl || {});
});

// node_modules/sshpk/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  module.exports = {
    bufferSplit,
    addRSAMissing,
    calculateDSAPublic,
    calculateED25519Public,
    calculateX25519Public,
    mpNormalize,
    mpDenormalize,
    ecNormalize,
    countZeros,
    assertCompatible,
    isCompatible,
    opensslKeyDeriv,
    opensshCipherInfo,
    publicFromPrivateECDSA,
    zeroPadToLength,
    writeBitString,
    readBitString,
    pbkdf2
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var PrivateKey = require_private_key();
  var Key = require_key();
  var crypto = __require("crypto");
  var algs = require_algs();
  var asn1 = require_lib();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  var nacl = require_nacl_fast();
  var MAX_CLASS_DEPTH = 3;
  function isCompatible(obj2, klass, needVer) {
    if (obj2 === null || typeof obj2 !== "object")
      return false;
    if (needVer === undefined)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj2 instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return true;
    var proto = Object.getPrototypeOf(obj2);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      if (!proto || ++depth > MAX_CLASS_DEPTH)
        return false;
    }
    if (proto.constructor.name !== klass.name)
      return false;
    var ver = proto._sshpkApiVersion;
    if (ver === undefined)
      ver = klass._oldVersionDetect(obj2);
    if (ver[0] != needVer[0] || ver[1] < needVer[1])
      return false;
    return true;
  }
  function assertCompatible(obj2, klass, needVer, name) {
    if (name === undefined)
      name = "object";
    assert.ok(obj2, name + " must not be null");
    assert.object(obj2, name + " must be an object");
    if (needVer === undefined)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj2 instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return;
    var proto = Object.getPrototypeOf(obj2);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      assert.ok(proto && ++depth <= MAX_CLASS_DEPTH, name + " must be a " + klass.name + " instance");
    }
    assert.strictEqual(proto.constructor.name, klass.name, name + " must be a " + klass.name + " instance");
    var ver = proto._sshpkApiVersion;
    if (ver === undefined)
      ver = klass._oldVersionDetect(obj2);
    assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1], name + " must be compatible with " + klass.name + " klass " + "version " + needVer[0] + "." + needVer[1]);
  }
  var CIPHER_LEN = {
    "des-ede3-cbc": { key: 24, iv: 8 },
    "aes-128-cbc": { key: 16, iv: 16 },
    "aes-256-cbc": { key: 32, iv: 16 }
  };
  var PKCS5_SALT_LEN = 8;
  function opensslKeyDeriv(cipher, salt, passphrase, count) {
    assert.buffer(salt, "salt");
    assert.buffer(passphrase, "passphrase");
    assert.number(count, "iteration count");
    var clen = CIPHER_LEN[cipher];
    assert.object(clen, "supported cipher");
    salt = salt.slice(0, PKCS5_SALT_LEN);
    var D, D_prev, bufs;
    var material = Buffer2.alloc(0);
    while (material.length < clen.key + clen.iv) {
      bufs = [];
      if (D_prev)
        bufs.push(D_prev);
      bufs.push(passphrase);
      bufs.push(salt);
      D = Buffer2.concat(bufs);
      for (var j = 0;j < count; ++j)
        D = crypto.createHash("md5").update(D).digest();
      material = Buffer2.concat([material, D]);
      D_prev = D;
    }
    return {
      key: material.slice(0, clen.key),
      iv: material.slice(clen.key, clen.key + clen.iv)
    };
  }
  function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
    var hkey = Buffer2.alloc(salt.length + 4);
    salt.copy(hkey);
    var gen = 0, ts = [];
    var i = 1;
    while (gen < size) {
      var t = T(i++);
      gen += t.length;
      ts.push(t);
    }
    return Buffer2.concat(ts).slice(0, size);
    function T(I) {
      hkey.writeUInt32BE(I, hkey.length - 4);
      var hmac = crypto.createHmac(hashAlg, passphrase);
      hmac.update(hkey);
      var Ti = hmac.digest();
      var Uc = Ti;
      var c = 1;
      while (c++ < iterations) {
        hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(Uc);
        Uc = hmac.digest();
        for (var x = 0;x < Ti.length; ++x)
          Ti[x] ^= Uc[x];
      }
      return Ti;
    }
  }
  function countZeros(buf) {
    var o = 0, obit = 8;
    while (o < buf.length) {
      var mask = 1 << obit;
      if ((buf[o] & mask) === mask)
        break;
      obit--;
      if (obit < 0) {
        o++;
        obit = 8;
      }
    }
    return o * 8 + (8 - obit) - 1;
  }
  function bufferSplit(buf, chr) {
    assert.buffer(buf);
    assert.string(chr);
    var parts = [];
    var lastPart = 0;
    var matches = 0;
    for (var i = 0;i < buf.length; ++i) {
      if (buf[i] === chr.charCodeAt(matches))
        ++matches;
      else if (buf[i] === chr.charCodeAt(0))
        matches = 1;
      else
        matches = 0;
      if (matches >= chr.length) {
        var newPart = i + 1;
        parts.push(buf.slice(lastPart, newPart - matches));
        lastPart = newPart;
        matches = 0;
      }
    }
    if (lastPart <= buf.length)
      parts.push(buf.slice(lastPart, buf.length));
    return parts;
  }
  function ecNormalize(buf, addZero) {
    assert.buffer(buf);
    if (buf[0] === 0 && buf[1] === 4) {
      if (addZero)
        return buf;
      return buf.slice(1);
    } else if (buf[0] === 4) {
      if (!addZero)
        return buf;
    } else {
      while (buf[0] === 0)
        buf = buf.slice(1);
      if (buf[0] === 2 || buf[0] === 3)
        throw new Error("Compressed elliptic curve points " + "are not supported");
      if (buf[0] !== 4)
        throw new Error("Not a valid elliptic curve point");
      if (!addZero)
        return buf;
    }
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    return b;
  }
  function readBitString(der, tag) {
    if (tag === undefined)
      tag = asn1.Ber.BitString;
    var buf = der.readString(tag, true);
    assert.strictEqual(buf[0], 0, "bit strings with unused bits are " + "not supported (0x" + buf[0].toString(16) + ")");
    return buf.slice(1);
  }
  function writeBitString(der, buf, tag) {
    if (tag === undefined)
      tag = asn1.Ber.BitString;
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    der.writeBuffer(b, tag);
  }
  function mpNormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
      buf = buf.slice(1);
    if ((buf[0] & 128) === 128) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function mpDenormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0)
      buf = buf.slice(1);
    return buf;
  }
  function zeroPadToLength(buf, len) {
    assert.buffer(buf);
    assert.number(len);
    while (buf.length > len) {
      assert.equal(buf[0], 0);
      buf = buf.slice(1);
    }
    while (buf.length < len) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function bigintToMpBuf(bigint) {
    var buf = Buffer2.from(bigint.toByteArray());
    buf = mpNormalize(buf);
    return buf;
  }
  function calculateDSAPublic(g, p, x) {
    assert.buffer(g);
    assert.buffer(p);
    assert.buffer(x);
    g = new jsbn(g);
    p = new jsbn(p);
    x = new jsbn(x);
    var y = g.modPow(x, p);
    var ybuf = bigintToMpBuf(y);
    return ybuf;
  }
  function calculateED25519Public(k) {
    assert.buffer(k);
    var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function calculateX25519Public(k) {
    assert.buffer(k);
    var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function addRSAMissing(key) {
    assert.object(key);
    assertCompatible(key, PrivateKey, [1, 1]);
    var d = new jsbn(key.part.d.data);
    var buf;
    if (!key.part.dmodp) {
      var p = new jsbn(key.part.p.data);
      var dmodp = d.mod(p.subtract(1));
      buf = bigintToMpBuf(dmodp);
      key.part.dmodp = { name: "dmodp", data: buf };
      key.parts.push(key.part.dmodp);
    }
    if (!key.part.dmodq) {
      var q2 = new jsbn(key.part.q.data);
      var dmodq = d.mod(q2.subtract(1));
      buf = bigintToMpBuf(dmodq);
      key.part.dmodq = { name: "dmodq", data: buf };
      key.parts.push(key.part.dmodq);
    }
  }
  function publicFromPrivateECDSA(curveName, priv) {
    assert.string(curveName, "curveName");
    assert.buffer(priv);
    var params = algs.curves[curveName];
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    var d = new jsbn(mpNormalize(priv));
    var pub = G.multiply(d);
    pub = Buffer2.from(curve.encodePointHex(pub), "hex");
    var parts = [];
    parts.push({ name: "curve", data: Buffer2.from(curveName) });
    parts.push({ name: "Q", data: pub });
    var key = new Key({ type: "ecdsa", curve, parts });
    return key;
  }
  function opensshCipherInfo(cipher) {
    var inf = {};
    switch (cipher) {
      case "3des-cbc":
        inf.keySize = 24;
        inf.blockSize = 8;
        inf.opensslName = "des-ede3-cbc";
        break;
      case "blowfish-cbc":
        inf.keySize = 16;
        inf.blockSize = 8;
        inf.opensslName = "bf-cbc";
        break;
      case "aes128-cbc":
      case "aes128-ctr":
      case "aes128-gcm@openssh.com":
        inf.keySize = 16;
        inf.blockSize = 16;
        inf.opensslName = "aes-128-" + cipher.slice(7, 10);
        break;
      case "aes192-cbc":
      case "aes192-ctr":
      case "aes192-gcm@openssh.com":
        inf.keySize = 24;
        inf.blockSize = 16;
        inf.opensslName = "aes-192-" + cipher.slice(7, 10);
        break;
      case "aes256-cbc":
      case "aes256-ctr":
      case "aes256-gcm@openssh.com":
        inf.keySize = 32;
        inf.blockSize = 16;
        inf.opensslName = "aes-256-" + cipher.slice(7, 10);
        break;
      default:
        throw new Error('Unsupported openssl cipher "' + cipher + '"');
    }
    return inf;
  }
});

// node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS((exports, module) => {
  module.exports = SSHBuffer;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  function SSHBuffer(opts) {
    assert.object(opts, "options");
    if (opts.buffer !== undefined)
      assert.buffer(opts.buffer, "options.buffer");
    this._size = opts.buffer ? opts.buffer.length : 1024;
    this._buffer = opts.buffer || Buffer2.alloc(this._size);
    this._offset = 0;
  }
  SSHBuffer.prototype.toBuffer = function() {
    return this._buffer.slice(0, this._offset);
  };
  SSHBuffer.prototype.atEnd = function() {
    return this._offset >= this._buffer.length;
  };
  SSHBuffer.prototype.remainder = function() {
    return this._buffer.slice(this._offset);
  };
  SSHBuffer.prototype.skip = function(n) {
    this._offset += n;
  };
  SSHBuffer.prototype.expand = function() {
    this._size *= 2;
    var buf = Buffer2.alloc(this._size);
    this._buffer.copy(buf, 0);
    this._buffer = buf;
  };
  SSHBuffer.prototype.readPart = function() {
    return { data: this.readBuffer() };
  };
  SSHBuffer.prototype.readBuffer = function() {
    var len = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    assert.ok(this._offset + len <= this._buffer.length, "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)");
    var buf = this._buffer.slice(this._offset, this._offset + len);
    this._offset += len;
    return buf;
  };
  SSHBuffer.prototype.readString = function() {
    return this.readBuffer().toString();
  };
  SSHBuffer.prototype.readCString = function() {
    var offset = this._offset;
    while (offset < this._buffer.length && this._buffer[offset] !== 0)
      offset++;
    assert.ok(offset < this._buffer.length, "c string does not terminate");
    var str = this._buffer.slice(this._offset, offset).toString();
    this._offset = offset + 1;
    return str;
  };
  SSHBuffer.prototype.readInt = function() {
    var v = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    return v;
  };
  SSHBuffer.prototype.readInt64 = function() {
    assert.ok(this._offset + 8 < this._buffer.length, "buffer not long enough to read Int64");
    var v = this._buffer.slice(this._offset, this._offset + 8);
    this._offset += 8;
    return v;
  };
  SSHBuffer.prototype.readChar = function() {
    var v = this._buffer[this._offset++];
    return v;
  };
  SSHBuffer.prototype.writeBuffer = function(buf) {
    while (this._offset + 4 + buf.length > this._size)
      this.expand();
    this._buffer.writeUInt32BE(buf.length, this._offset);
    this._offset += 4;
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
  SSHBuffer.prototype.writeString = function(str) {
    this.writeBuffer(Buffer2.from(str, "utf8"));
  };
  SSHBuffer.prototype.writeCString = function(str) {
    while (this._offset + 1 + str.length > this._size)
      this.expand();
    this._buffer.write(str, this._offset);
    this._offset += str.length;
    this._buffer[this._offset++] = 0;
  };
  SSHBuffer.prototype.writeInt = function(v) {
    while (this._offset + 4 > this._size)
      this.expand();
    this._buffer.writeUInt32BE(v, this._offset);
    this._offset += 4;
  };
  SSHBuffer.prototype.writeInt64 = function(v) {
    assert.buffer(v, "value");
    if (v.length > 8) {
      var lead = v.slice(0, v.length - 8);
      for (var i = 0;i < lead.length; ++i) {
        assert.strictEqual(lead[i], 0, "must fit in 64 bits of precision");
      }
      v = v.slice(v.length - 8, v.length);
    }
    while (this._offset + 8 > this._size)
      this.expand();
    v.copy(this._buffer, this._offset);
    this._offset += 8;
  };
  SSHBuffer.prototype.writeChar = function(v) {
    while (this._offset + 1 > this._size)
      this.expand();
    this._buffer[this._offset++] = v;
  };
  SSHBuffer.prototype.writePart = function(p) {
    this.writeBuffer(p.data);
  };
  SSHBuffer.prototype.write = function(buf) {
    while (this._offset + buf.length > this._size)
      this.expand();
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
});

// node_modules/sshpk/lib/signature.js
var require_signature = __commonJS((exports, module) => {
  module.exports = Signature;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = __require("crypto");
  var errs = require_errors();
  var utils = require_utils();
  var asn1 = require_lib();
  var SSHBuffer = require_ssh_buffer();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var SignatureParseError = errs.SignatureParseError;
  function Signature(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    var partLookup = {};
    for (var i = 0;i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.hashAlgorithm = opts.hashAlgo;
    this.curve = opts.curve;
    this.parts = opts.parts;
    this.part = partLookup;
  }
  Signature.prototype.toBuffer = function(format) {
    if (format === undefined)
      format = "asn1";
    assert.string(format, "format");
    var buf;
    var stype = "ssh-" + this.type;
    switch (this.type) {
      case "rsa":
        switch (this.hashAlgorithm) {
          case "sha256":
            stype = "rsa-sha2-256";
            break;
          case "sha512":
            stype = "rsa-sha2-512";
            break;
          case "sha1":
          case undefined:
            break;
          default:
            throw new Error("SSH signature " + "format does not support hash " + "algorithm " + this.hashAlgorithm);
        }
        if (format === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case "ed25519":
        if (format === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case "dsa":
      case "ecdsa":
        var r, s;
        if (format === "asn1") {
          var der = new asn1.BerWriter;
          der.startSequence();
          r = utils.mpNormalize(this.part.r.data);
          s = utils.mpNormalize(this.part.s.data);
          der.writeBuffer(r, asn1.Ber.Integer);
          der.writeBuffer(s, asn1.Ber.Integer);
          der.endSequence();
          return der.buffer;
        } else if (format === "ssh" && this.type === "dsa") {
          buf = new SSHBuffer({});
          buf.writeString("ssh-dss");
          r = this.part.r.data;
          if (r.length > 20 && r[0] === 0)
            r = r.slice(1);
          s = this.part.s.data;
          if (s.length > 20 && s[0] === 0)
            s = s.slice(1);
          if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
            throw new Error("OpenSSH only supports " + "DSA signatures with SHA1 hash");
          }
          buf.writeBuffer(Buffer2.concat([r, s]));
          return buf.toBuffer();
        } else if (format === "ssh" && this.type === "ecdsa") {
          var inner = new SSHBuffer({});
          r = this.part.r.data;
          inner.writeBuffer(r);
          inner.writePart(this.part.s);
          buf = new SSHBuffer({});
          var curve;
          if (r[0] === 0)
            r = r.slice(1);
          var sz = r.length * 8;
          if (sz === 256)
            curve = "nistp256";
          else if (sz === 384)
            curve = "nistp384";
          else if (sz === 528)
            curve = "nistp521";
          buf.writeString("ecdsa-sha2-" + curve);
          buf.writeBuffer(inner.toBuffer());
          return buf.toBuffer();
        }
        throw new Error("Invalid signature format");
      default:
        throw new Error("Invalid signature data");
    }
  };
  Signature.prototype.toString = function(format) {
    assert.optionalString(format, "format");
    return this.toBuffer(format).toString("base64");
  };
  Signature.parse = function(data, type, format) {
    if (typeof data === "string")
      data = Buffer2.from(data, "base64");
    assert.buffer(data, "data");
    assert.string(format, "format");
    assert.string(type, "type");
    var opts = {};
    opts.type = type.toLowerCase();
    opts.parts = [];
    try {
      assert.ok(data.length > 0, "signature must not be empty");
      switch (opts.type) {
        case "rsa":
          return parseOneNum(data, type, format, opts);
        case "ed25519":
          return parseOneNum(data, type, format, opts);
        case "dsa":
        case "ecdsa":
          if (format === "asn1")
            return parseDSAasn1(data, type, format, opts);
          else if (opts.type === "dsa")
            return parseDSA(data, type, format, opts);
          else
            return parseECDSA(data, type, format, opts);
        default:
          throw new InvalidAlgorithmError(type);
      }
    } catch (e) {
      if (e instanceof InvalidAlgorithmError)
        throw e;
      throw new SignatureParseError(type, format, e);
    }
  };
  function parseOneNum(data, type, format, opts) {
    if (format === "ssh") {
      try {
        var buf = new SSHBuffer({ buffer: data });
        var head = buf.readString();
      } catch (e) {}
      if (buf !== undefined) {
        var msg = "SSH signature does not match expected " + "type (expected " + type + ", got " + head + ")";
        switch (head) {
          case "ssh-rsa":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha1";
            break;
          case "rsa-sha2-256":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha256";
            break;
          case "rsa-sha2-512":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha512";
            break;
          case "ssh-ed25519":
            assert.strictEqual(type, "ed25519", msg);
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unknown SSH signature " + "type: " + head);
        }
        var sig = buf.readPart();
        assert.ok(buf.atEnd(), "extra trailing bytes");
        sig.name = "sig";
        opts.parts.push(sig);
        return new Signature(opts);
      }
    }
    opts.parts.push({ name: "sig", data });
    return new Signature(opts);
  }
  function parseDSAasn1(data, type, format, opts) {
    var der = new asn1.BerReader(data);
    der.readSequence();
    var r = der.readString(asn1.Ber.Integer, true);
    var s = der.readString(asn1.Ber.Integer, true);
    opts.parts.push({ name: "r", data: utils.mpNormalize(r) });
    opts.parts.push({ name: "s", data: utils.mpNormalize(s) });
    return new Signature(opts);
  }
  function parseDSA(data, type, format, opts) {
    if (data.length != 40) {
      var buf = new SSHBuffer({ buffer: data });
      var d = buf.readBuffer();
      if (d.toString("ascii") === "ssh-dss")
        d = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes");
      assert.strictEqual(d.length, 40, "invalid inner length");
      data = d;
    }
    opts.parts.push({ name: "r", data: data.slice(0, 20) });
    opts.parts.push({ name: "s", data: data.slice(20, 40) });
    return new Signature(opts);
  }
  function parseECDSA(data, type, format, opts) {
    var buf = new SSHBuffer({ buffer: data });
    var r, s;
    var inner = buf.readBuffer();
    var stype = inner.toString("ascii");
    if (stype.slice(0, 6) === "ecdsa-") {
      var parts = stype.split("-");
      assert.strictEqual(parts[0], "ecdsa");
      assert.strictEqual(parts[1], "sha2");
      opts.curve = parts[2];
      switch (opts.curve) {
        case "nistp256":
          opts.hashAlgo = "sha256";
          break;
        case "nistp384":
          opts.hashAlgo = "sha384";
          break;
        case "nistp521":
          opts.hashAlgo = "sha512";
          break;
        default:
          throw new Error("Unsupported ECDSA curve: " + opts.curve);
      }
      inner = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes on outer");
      buf = new SSHBuffer({ buffer: inner });
      r = buf.readPart();
    } else {
      r = { data: inner };
    }
    s = buf.readPart();
    assert.ok(buf.atEnd(), "extra trailing bytes");
    r.name = "r";
    s.name = "s";
    opts.parts.push(r);
    opts.parts.push(s);
    return new Signature(opts);
  }
  Signature.isSignature = function(obj2, ver) {
    return utils.isCompatible(obj2, Signature, ver);
  };
  Signature.prototype._sshpkApiVersion = [2, 1];
  Signature._oldVersionDetect = function(obj2) {
    assert.func(obj2.toBuffer);
    if (obj2.hasOwnProperty("hashAlgorithm"))
      return [2, 0];
    return [1, 0];
  };
});

// node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS((exports, module) => {
  var BigInteger = require_jsbn().BigInteger;
  var ECCurveFp = require_ec().ECCurveFp;
  function X9ECParameters(curve, g, n, h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
  }
  function x9getCurve() {
    return this.curve;
  }
  function x9getG() {
    return this.g;
  }
  function x9getN() {
    return this.n;
  }
  function x9getH() {
    return this.h;
  }
  X9ECParameters.prototype.getCurve = x9getCurve;
  X9ECParameters.prototype.getG = x9getG;
  X9ECParameters.prototype.getN = x9getN;
  X9ECParameters.prototype.getH = x9getH;
  function fromHex(s) {
    return new BigInteger(s, 16);
  }
  function secp128r1() {
    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "161FF7528B899B2D0C28607CA52C5B86" + "CF5AC8395BAFEB13C02DA292DDED7A83");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
    var a = BigInteger.ZERO;
    var b = fromHex("7");
    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB" + "938CF935318FDCED6BC28286531733C3F03C4FEE");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "4A96B5688EF573284664698968C38BB913CBFC82" + "23A628553168947D59DCC912042351377AC5FB32");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
    var a = BigInteger.ZERO;
    var b = fromHex("3");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D" + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012" + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp224r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21" + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp256r1() {
    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296" + "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
    return new X9ECParameters(curve, G, n, h);
  }
  module.exports = {
    secp128r1,
    secp160k1,
    secp160r1,
    secp192k1,
    secp192r1,
    secp224r1,
    secp256r1
  };
});

// node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS((exports) => {
  var crypto = __require("crypto");
  var BigInteger = require_jsbn().BigInteger;
  var ECPointFp = require_ec().ECPointFp;
  var Buffer2 = require_safer().Buffer;
  exports.ECCurves = require_sec();
  function unstupid(hex, len) {
    return hex.length >= len ? hex : unstupid("0" + hex, len);
  }
  exports.ECKey = function(curve, key, isPublic) {
    var priv;
    var c = curve();
    var n = c.getN();
    var bytes = Math.floor(n.bitLength() / 8);
    if (key) {
      if (isPublic) {
        var curve = c.getCurve();
        this.P = curve.decodePointHex(key.toString("hex"));
      } else {
        if (key.length != bytes)
          return false;
        priv = new BigInteger(key.toString("hex"), 16);
      }
    } else {
      var n1 = n.subtract(BigInteger.ONE);
      var r = new BigInteger(crypto.randomBytes(n.bitLength()));
      priv = r.mod(n1).add(BigInteger.ONE);
      this.P = c.getG().multiply(priv);
    }
    if (this.P) {
      this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
    }
    if (priv) {
      this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
      this.deriveSharedSecret = function(key2) {
        if (!key2 || !key2.P)
          return false;
        var S = key2.P.multiply(priv);
        return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
      };
    }
  };
});

// node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS((exports, module) => {
  module.exports = {
    DiffieHellman,
    generateECDSA,
    generateED25519
  };
  var assert = require_assert();
  var crypto = __require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var CRYPTO_HAVE_ECDH = crypto.createECDH !== undefined;
  var ecdh = require_ecc_jsbn();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  function DiffieHellman(key) {
    utils.assertCompatible(key, Key, [1, 4], "key");
    this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
    this._algo = key.type;
    this._curve = key.curve;
    this._key = key;
    if (key.type === "dsa") {
      if (!CRYPTO_HAVE_ECDH) {
        throw new Error("Due to bugs in the node 0.10 " + "crypto API, node 0.12.x or later is required " + "to use DH");
      }
      this._dh = crypto.createDiffieHellman(key.part.p.data, undefined, key.part.g.data, undefined);
      this._p = key.part.p;
      this._g = key.part.g;
      if (this._isPriv)
        this._dh.setPrivateKey(key.part.x.data);
      this._dh.setPublicKey(key.part.y.data);
    } else if (key.type === "ecdsa") {
      if (!CRYPTO_HAVE_ECDH) {
        this._ecParams = new X9ECParameters(this._curve);
        if (this._isPriv) {
          this._priv = new ECPrivate(this._ecParams, key.part.d.data);
        }
        return;
      }
      var curve = {
        nistp256: "prime256v1",
        nistp384: "secp384r1",
        nistp521: "secp521r1"
      }[key.curve];
      this._dh = crypto.createECDH(curve);
      if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
        CRYPTO_HAVE_ECDH = false;
        DiffieHellman.call(this, key);
        return;
      }
      if (this._isPriv)
        this._dh.setPrivateKey(key.part.d.data);
      this._dh.setPublicKey(key.part.Q.data);
    } else if (key.type === "curve25519") {
      if (this._isPriv) {
        utils.assertCompatible(key, PrivateKey, [1, 5], "key");
        this._priv = key.part.k.data;
      }
    } else {
      throw new Error("DH not supported for " + key.type + " keys");
    }
  }
  DiffieHellman.prototype.getPublicKey = function() {
    if (this._isPriv)
      return this._key.toPublic();
    return this._key;
  };
  DiffieHellman.prototype.getPrivateKey = function() {
    if (this._isPriv)
      return this._key;
    else
      return;
  };
  DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
  DiffieHellman.prototype._keyCheck = function(pk, isPub) {
    assert.object(pk, "key");
    if (!isPub)
      utils.assertCompatible(pk, PrivateKey, [1, 3], "key");
    utils.assertCompatible(pk, Key, [1, 4], "key");
    if (pk.type !== this._algo) {
      throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
    }
    if (pk.curve !== this._curve) {
      throw new Error("A key from the " + pk.curve + " curve " + "cannot be used with a " + this._curve + " Diffie-Hellman");
    }
    if (pk.type === "dsa") {
      assert.deepEqual(pk.part.p, this._p, "DSA key prime does not match");
      assert.deepEqual(pk.part.g, this._g, "DSA key generator does not match");
    }
  };
  DiffieHellman.prototype.setKey = function(pk) {
    this._keyCheck(pk);
    if (pk.type === "dsa") {
      this._dh.setPrivateKey(pk.part.x.data);
      this._dh.setPublicKey(pk.part.y.data);
    } else if (pk.type === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.setPrivateKey(pk.part.d.data);
        this._dh.setPublicKey(pk.part.Q.data);
      } else {
        this._priv = new ECPrivate(this._ecParams, pk.part.d.data);
      }
    } else if (pk.type === "curve25519") {
      var k = pk.part.k;
      if (!pk.part.k)
        k = pk.part.r;
      this._priv = k.data;
      if (this._priv[0] === 0)
        this._priv = this._priv.slice(1);
      this._priv = this._priv.slice(0, 32);
    }
    this._key = pk;
    this._isPriv = true;
  };
  DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
  DiffieHellman.prototype.computeSecret = function(otherpk) {
    this._keyCheck(otherpk, true);
    if (!this._isPriv)
      throw new Error("DH exchange has not been initialized with " + "a private key yet");
    var pub;
    if (this._algo === "dsa") {
      return this._dh.computeSecret(otherpk.part.y.data);
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        return this._dh.computeSecret(otherpk.part.Q.data);
      } else {
        pub = new ECPublic(this._ecParams, otherpk.part.Q.data);
        return this._priv.deriveSharedSecret(pub);
      }
    } else if (this._algo === "curve25519") {
      pub = otherpk.part.A.data;
      while (pub[0] === 0 && pub.length > 32)
        pub = pub.slice(1);
      var priv = this._priv;
      assert.strictEqual(pub.length, 32);
      assert.strictEqual(priv.length, 32);
      var secret = nacl.box.before(new Uint8Array(pub), new Uint8Array(priv));
      return Buffer2.from(secret);
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKey = function() {
    var parts = [];
    var priv, pub;
    if (this._algo === "dsa") {
      this._dh.generateKeys();
      parts.push({ name: "p", data: this._p.data });
      parts.push({ name: "q", data: this._key.part.q.data });
      parts.push({ name: "g", data: this._g.data });
      parts.push({ name: "y", data: this._dh.getPublicKey() });
      parts.push({ name: "x", data: this._dh.getPrivateKey() });
      this._key = new PrivateKey({
        type: "dsa",
        parts
      });
      this._isPriv = true;
      return this._key;
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({ name: "Q", data: this._dh.getPublicKey() });
        parts.push({ name: "d", data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      } else {
        var n = this._ecParams.getN();
        var r = new jsbn(crypto.randomBytes(n.bitLength()));
        var n1 = n.subtract(jsbn.ONE);
        priv = r.mod(n1).add(jsbn.ONE);
        pub = this._ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
        this._priv = new ECPrivate(this._ecParams, priv);
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({ name: "Q", data: pub });
        parts.push({ name: "d", data: priv });
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      }
    } else if (this._algo === "curve25519") {
      var pair = nacl.box.keyPair();
      priv = Buffer2.from(pair.secretKey);
      pub = Buffer2.from(pair.publicKey);
      priv = Buffer2.concat([priv, pub]);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      parts.push({ name: "A", data: pub });
      parts.push({ name: "k", data: priv });
      this._key = new PrivateKey({
        type: "curve25519",
        parts
      });
      this._isPriv = true;
      return this._key;
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
  function X9ECParameters(name) {
    var params = algs.curves[name];
    assert.object(params);
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var n = new jsbn(params.n);
    var h = jsbn.ONE;
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    this.curve = curve;
    this.g = G;
    this.n = n;
    this.h = h;
  }
  X9ECParameters.prototype.getCurve = function() {
    return this.curve;
  };
  X9ECParameters.prototype.getG = function() {
    return this.g;
  };
  X9ECParameters.prototype.getN = function() {
    return this.n;
  };
  X9ECParameters.prototype.getH = function() {
    return this.h;
  };
  function ECPublic(params, buffer) {
    this._params = params;
    if (buffer[0] === 0)
      buffer = buffer.slice(1);
    this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
  }
  function ECPrivate(params, buffer) {
    this._params = params;
    this._priv = new jsbn(utils.mpNormalize(buffer));
  }
  ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
    assert.ok(pubKey instanceof ECPublic);
    var S = pubKey._pub.multiply(this._priv);
    return Buffer2.from(S.getX().toBigInteger().toByteArray());
  };
  function generateED25519() {
    var pair = nacl.sign.keyPair();
    var priv = Buffer2.from(pair.secretKey);
    var pub = Buffer2.from(pair.publicKey);
    assert.strictEqual(priv.length, 64);
    assert.strictEqual(pub.length, 32);
    var parts = [];
    parts.push({ name: "A", data: pub });
    parts.push({ name: "k", data: priv.slice(0, 32) });
    var key = new PrivateKey({
      type: "ed25519",
      parts
    });
    return key;
  }
  function generateECDSA(curve) {
    var parts = [];
    var key;
    if (CRYPTO_HAVE_ECDH) {
      var osCurve = {
        nistp256: "prime256v1",
        nistp384: "secp384r1",
        nistp521: "secp521r1"
      }[curve];
      var dh = crypto.createECDH(osCurve);
      dh.generateKeys();
      parts.push({
        name: "curve",
        data: Buffer2.from(curve)
      });
      parts.push({ name: "Q", data: dh.getPublicKey() });
      parts.push({ name: "d", data: dh.getPrivateKey() });
      key = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key;
    } else {
      var ecParams = new X9ECParameters(curve);
      var n = ecParams.getN();
      var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
      var c = new jsbn(crypto.randomBytes(cByteLen));
      var n1 = n.subtract(jsbn.ONE);
      var priv = c.mod(n1).add(jsbn.ONE);
      var pub = ecParams.getG().multiply(priv);
      priv = Buffer2.from(priv.toByteArray());
      pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
      parts.push({ name: "curve", data: Buffer2.from(curve) });
      parts.push({ name: "Q", data: pub });
      parts.push({ name: "d", data: priv });
      key = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key;
    }
  }
});

// node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS((exports, module) => {
  module.exports = {
    Verifier,
    Signer
  };
  var nacl = require_nacl_fast();
  var stream = __require("stream");
  var util = __require("util");
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Signature = require_signature();
  function Verifier(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of " + "SHA-512 hashes");
    this.key = key;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util.inherits(Verifier, stream.Writable);
  Verifier.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Verifier.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Verifier.prototype.verify = function(signature, fmt) {
    var sig;
    if (Signature.isSignature(signature, [2, 0])) {
      if (signature.type !== "ed25519")
        return false;
      sig = signature.toBuffer("raw");
    } else if (typeof signature === "string") {
      sig = Buffer2.from(signature, "base64");
    } else if (Signature.isSignature(signature, [1, 0])) {
      throw new Error("signature was created by too old " + "a version of sshpk and cannot be verified");
    }
    assert.buffer(sig);
    return nacl.sign.detached.verify(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(sig), new Uint8Array(this.key.part.A.data));
  };
  function Signer(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of " + "SHA-512 hashes");
    this.key = key;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util.inherits(Signer, stream.Writable);
  Signer.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Signer.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Signer.prototype.sign = function() {
    var sig = nacl.sign.detached(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(Buffer2.concat([
      this.key.part.k.data,
      this.key.part.A.data
    ])));
    var sigBuf = Buffer2.from(sig);
    var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
    sigObj.hashAlgorithm = "sha512";
    return sigObj;
  };
});

// node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS((exports, module) => {
  module.exports = {
    read,
    readPkcs8,
    write,
    writePkcs8,
    pkcs8ToBuffer,
    readECDSACurve,
    writeECDSACurve
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  function read(buf, options) {
    return pem.read(buf, options, "pkcs8");
  }
  function write(key, options) {
    return pem.write(key, options, "pkcs8");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs8(alg, type, der) {
    if (der.peek() === asn1.Ber.Integer) {
      assert.strictEqual(type, "private", "unexpected Integer at start of public key");
      der.readString(asn1.Ber.Integer, true);
    }
    der.readSequence();
    var next = der.offset + der.length;
    var oid = der.readOID();
    switch (oid) {
      case "1.2.840.113549.1.1.1":
        der._offset = next;
        if (type === "public")
          return readPkcs8RSAPublic(der);
        else
          return readPkcs8RSAPrivate(der);
      case "1.2.840.10040.4.1":
        if (type === "public")
          return readPkcs8DSAPublic(der);
        else
          return readPkcs8DSAPrivate(der);
      case "1.2.840.10045.2.1":
        if (type === "public")
          return readPkcs8ECDSAPublic(der);
        else
          return readPkcs8ECDSAPrivate(der);
      case "1.3.101.112":
        if (type === "public") {
          return readPkcs8EdDSAPublic(der);
        } else {
          return readPkcs8EdDSAPrivate(der);
        }
      case "1.3.101.110":
        if (type === "public") {
          return readPkcs8X25519Public(der);
        } else {
          return readPkcs8X25519Private(der);
        }
      default:
        throw new Error("Unknown key type OID " + oid);
    }
  }
  function readPkcs8RSAPublic(der) {
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    der.readSequence();
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key = {
      type: "rsa",
      source: der.originalInput,
      parts: [
        { name: "e", data: e },
        { name: "n", data: n }
      ]
    };
    return new Key(key);
  }
  function readPkcs8RSAPrivate(der) {
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var ver = readMPInt(der, "version");
    assert.equal(ver[0], 0, "unknown RSA private key version");
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key = {
      type: "rsa",
      parts: [
        { name: "n", data: n },
        { name: "e", data: e },
        { name: "d", data: d },
        { name: "iqmp", data: iqmp },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "dmodp", data: dmodp },
        { name: "dmodq", data: dmodq }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8DSAPublic(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    var y = readMPInt(der, "y");
    var key = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y }
      ]
    };
    return new Key(key);
  }
  function readPkcs8DSAPrivate(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.OctetString);
    var x = readMPInt(der, "x");
    var y = utils.calculateDSAPublic(g, p, x);
    var key = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y },
        { name: "x", data: x }
      ]
    };
    return new PrivateKey(key);
  }
  function readECDSACurve(der) {
    var curveName, curveNames;
    var j, c, cd;
    if (der.peek() === asn1.Ber.OID) {
      var oid = der.readOID();
      curveNames = Object.keys(algs.curves);
      for (j = 0;j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        if (cd.pkcs8oid === oid) {
          curveName = c;
          break;
        }
      }
    } else {
      der.readSequence();
      var version = der.readString(asn1.Ber.Integer, true);
      assert.strictEqual(version[0], 1, "ECDSA key not version 1");
      var curve = {};
      der.readSequence();
      var fieldTypeOid = der.readOID();
      assert.strictEqual(fieldTypeOid, "1.2.840.10045.1.1", "ECDSA key is not from a prime-field");
      var p = curve.p = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.size = p.length * 8 - utils.countZeros(p);
      der.readSequence();
      curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      if (der.peek() === asn1.Ber.BitString)
        curve.s = der.readString(asn1.Ber.BitString, true);
      curve.G = der.readString(asn1.Ber.OctetString, true);
      assert.strictEqual(curve.G[0], 4, "uncompressed G is required");
      curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      assert.strictEqual(curve.h[0], 1, "a cofactor=1 curve is " + "required");
      curveNames = Object.keys(algs.curves);
      var ks = Object.keys(curve);
      for (j = 0;j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        var equal = true;
        for (var i = 0;i < ks.length; ++i) {
          var k = ks[i];
          if (cd[k] === undefined)
            continue;
          if (typeof cd[k] === "object" && cd[k].equals !== undefined) {
            if (!cd[k].equals(curve[k])) {
              equal = false;
              break;
            }
          } else if (Buffer2.isBuffer(cd[k])) {
            if (cd[k].toString("binary") !== curve[k].toString("binary")) {
              equal = false;
              break;
            }
          } else {
            if (cd[k] !== curve[k]) {
              equal = false;
              break;
            }
          }
        }
        if (equal) {
          curveName = c;
          break;
        }
      }
    }
    return curveName;
  }
  function readPkcs8ECDSAPrivate(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var version = readMPInt(der, "version");
    assert.equal(version[0], 1, "unknown version of ECDSA key");
    var d = der.readString(asn1.Ber.OctetString, true);
    var Q;
    if (der.peek() == 160) {
      der.readSequence(160);
      der._offset += der.length;
    }
    if (der.peek() == 161) {
      der.readSequence(161);
      Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
    }
    if (Q === undefined) {
      var pub = utils.publicFromPrivateECDSA(curveName, d);
      Q = pub.part.Q.data;
    }
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curveName) },
        { name: "Q", data: Q },
        { name: "d", data: d }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8ECDSAPublic(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curveName) },
        { name: "Q", data: Q }
      ]
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPublic(der) {
    if (der.peek() === 0)
      der.readByte();
    var A = utils.readBitString(der);
    var key = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) }
      ]
    };
    return new Key(key);
  }
  function readPkcs8X25519Public(der) {
    var A = utils.readBitString(der);
    var key = {
      type: "curve25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) }
      ]
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPrivate(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A, tag;
    while ((tag = der.peek()) !== null) {
      if (tag === (asn1.Ber.Context | 1)) {
        A = utils.readBitString(der, tag);
      } else {
        der.readSequence(tag);
        der._offset += der.length;
      }
    }
    if (A === undefined)
      A = utils.calculateED25519Public(k);
    var key = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) },
        { name: "k", data: utils.zeroPadToLength(k, 32) }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8X25519Private(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A = utils.calculateX25519Public(k);
    var key = {
      type: "curve25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) },
        { name: "k", data: utils.zeroPadToLength(k, 32) }
      ]
    };
    return new PrivateKey(key);
  }
  function pkcs8ToBuffer(key) {
    var der = new asn1.BerWriter;
    writePkcs8(der, key);
    return der.buffer;
  }
  function writePkcs8(der, key) {
    der.startSequence();
    if (PrivateKey.isPrivateKey(key)) {
      var version = 0;
      if (key.type === "ed25519")
        version = 1;
      var vbuf = Buffer2.from([version]);
      der.writeBuffer(vbuf, asn1.Ber.Integer);
    }
    der.startSequence();
    switch (key.type) {
      case "rsa":
        der.writeOID("1.2.840.113549.1.1.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8RSAPrivate(key, der);
        else
          writePkcs8RSAPublic(key, der);
        break;
      case "dsa":
        der.writeOID("1.2.840.10040.4.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8DSAPrivate(key, der);
        else
          writePkcs8DSAPublic(key, der);
        break;
      case "ecdsa":
        der.writeOID("1.2.840.10045.2.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8ECDSAPrivate(key, der);
        else
          writePkcs8ECDSAPublic(key, der);
        break;
      case "ed25519":
        der.writeOID("1.3.101.112");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8EdDSAPrivate(key, der);
        else
          writePkcs8EdDSAPublic(key, der);
        break;
      default:
        throw new Error("Unsupported key type: " + key.type);
    }
    der.endSequence();
  }
  function writePkcs8RSAPrivate(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([0]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq)
      utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8RSAPublic(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.startSequence();
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8DSAPrivate(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writePkcs8DSAPublic(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writeECDSACurve(key, der) {
    var curve = algs.curves[key.curve];
    if (curve.pkcs8oid) {
      der.writeOID(curve.pkcs8oid);
    } else {
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.startSequence();
      der.writeOID("1.2.840.10045.1.1");
      der.writeBuffer(curve.p, asn1.Ber.Integer);
      der.endSequence();
      der.startSequence();
      var a = curve.p;
      if (a[0] === 0)
        a = a.slice(1);
      der.writeBuffer(a, asn1.Ber.OctetString);
      der.writeBuffer(curve.b, asn1.Ber.OctetString);
      der.writeBuffer(curve.s, asn1.Ber.BitString);
      der.endSequence();
      der.writeBuffer(curve.G, asn1.Ber.OctetString);
      der.writeBuffer(curve.n, asn1.Ber.Integer);
      var h = curve.h;
      if (!h) {
        h = Buffer2.from([1]);
      }
      der.writeBuffer(h, asn1.Ber.Integer);
      der.endSequence();
    }
  }
  function writePkcs8ECDSAPublic(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs8ECDSAPrivate(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([1]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8EdDSAPublic(key, der) {
    der.endSequence();
    utils.writeBitString(der, key.part.A.data);
  }
  function writePkcs8EdDSAPrivate(key, der) {
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    var k = utils.mpNormalize(key.part.k.data);
    while (k.length > 32 && k[0] === 0)
      k = k.slice(1);
    der.writeBuffer(k, asn1.Ber.OctetString);
    der.endSequence();
    utils.writeBitString(der, key.part.A.data, asn1.Ber.Context | 1);
  }
});

// node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS((exports, module) => {
  module.exports = {
    read,
    readPkcs1,
    write,
    writePkcs1
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var pkcs8 = require_pkcs8();
  var readECDSACurve = pkcs8.readECDSACurve;
  function read(buf, options) {
    return pem.read(buf, options, "pkcs1");
  }
  function write(key, options) {
    return pem.write(key, options, "pkcs1");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs1(alg, type, der) {
    switch (alg) {
      case "RSA":
        if (type === "public")
          return readPkcs1RSAPublic(der);
        else if (type === "private")
          return readPkcs1RSAPrivate(der);
        throw new Error("Unknown key type: " + type);
      case "DSA":
        if (type === "public")
          return readPkcs1DSAPublic(der);
        else if (type === "private")
          return readPkcs1DSAPrivate(der);
        throw new Error("Unknown key type: " + type);
      case "EC":
      case "ECDSA":
        if (type === "private")
          return readPkcs1ECDSAPrivate(der);
        else if (type === "public")
          return readPkcs1ECDSAPublic(der);
        throw new Error("Unknown key type: " + type);
      case "EDDSA":
      case "EdDSA":
        if (type === "private")
          return readPkcs1EdDSAPrivate(der);
        throw new Error(type + " keys not supported with EdDSA");
      default:
        throw new Error("Unknown key algo: " + alg);
    }
  }
  function readPkcs1RSAPublic(der) {
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key = {
      type: "rsa",
      parts: [
        { name: "e", data: e },
        { name: "n", data: n }
      ]
    };
    return new Key(key);
  }
  function readPkcs1RSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version[0], 0);
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key = {
      type: "rsa",
      parts: [
        { name: "n", data: n },
        { name: "e", data: e },
        { name: "d", data: d },
        { name: "iqmp", data: iqmp },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "dmodp", data: dmodp },
        { name: "dmodq", data: dmodq }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 0);
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var y = readMPInt(der, "y");
    var x = readMPInt(der, "x");
    var key = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y },
        { name: "x", data: x }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1EdDSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 1);
    var k = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var oid = der.readOID();
    assert.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
    der.readSequence(161);
    var A = utils.readBitString(der);
    var key = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) },
        { name: "k", data: k }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPublic(der) {
    var y = readMPInt(der, "y");
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var key = {
      type: "dsa",
      parts: [
        { name: "y", data: y },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g }
      ]
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPublic(der) {
    der.readSequence();
    var oid = der.readOID();
    assert.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
    var curveOid = der.readOID();
    var curve;
    var curves = Object.keys(algs.curves);
    for (var j = 0;j < curves.length; ++j) {
      var c = curves[j];
      var cd = algs.curves[c];
      if (cd.pkcs8oid === curveOid) {
        curve = c;
        break;
      }
    }
    assert.string(curve, "a known ECDSA named curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curve) },
        { name: "Q", data: Q }
      ]
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 1);
    var d = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var curve = readECDSACurve(der);
    assert.string(curve, "a known elliptic curve");
    der.readSequence(161);
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curve) },
        { name: "Q", data: Q },
        { name: "d", data: d }
      ]
    };
    return new PrivateKey(key);
  }
  function writePkcs1(der, key) {
    der.startSequence();
    switch (key.type) {
      case "rsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1RSAPrivate(der, key);
        else
          writePkcs1RSAPublic(der, key);
        break;
      case "dsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1DSAPrivate(der, key);
        else
          writePkcs1DSAPublic(der, key);
        break;
      case "ecdsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1ECDSAPrivate(der, key);
        else
          writePkcs1ECDSAPublic(der, key);
        break;
      case "ed25519":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1EdDSAPrivate(der, key);
        else
          writePkcs1EdDSAPublic(der, key);
        break;
      default:
        throw new Error("Unknown key algo: " + key.type);
    }
    der.endSequence();
  }
  function writePkcs1RSAPublic(der, key) {
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  }
  function writePkcs1RSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq)
      utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPublic(der, key) {
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  }
  function writePkcs1ECDSAPublic(der, key) {
    der.startSequence();
    der.writeOID("1.2.840.10045.2.1");
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs1ECDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(160);
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
  }
  function writePkcs1EdDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
    der.startSequence(160);
    der.writeOID("1.3.101.112");
    der.endSequence();
    der.startSequence(161);
    utils.writeBitString(der, key.part.A.data);
    der.endSequence();
  }
  function writePkcs1EdDSAPublic(der, key) {
    throw new Error("Public keys are not supported for EdDSA PKCS#1");
  }
});

// node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS((exports, module) => {
  module.exports = {
    read: read.bind(undefined, false, undefined),
    readType: read.bind(undefined, false),
    write,
    readPartial: read.bind(undefined, true),
    readInternal: read,
    keyTypeToAlg,
    algToKeyType
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var SSHBuffer = require_ssh_buffer();
  function algToKeyType(alg) {
    assert.string(alg);
    if (alg === "ssh-dss")
      return "dsa";
    else if (alg === "ssh-rsa")
      return "rsa";
    else if (alg === "ssh-ed25519")
      return "ed25519";
    else if (alg === "ssh-curve25519")
      return "curve25519";
    else if (alg.match(/^ecdsa-sha2-/))
      return "ecdsa";
    else
      throw new Error("Unknown algorithm " + alg);
  }
  function keyTypeToAlg(key) {
    assert.object(key);
    if (key.type === "dsa")
      return "ssh-dss";
    else if (key.type === "rsa")
      return "ssh-rsa";
    else if (key.type === "ed25519")
      return "ssh-ed25519";
    else if (key.type === "curve25519")
      return "ssh-curve25519";
    else if (key.type === "ecdsa")
      return "ecdsa-sha2-" + key.part.curve.data.toString();
    else
      throw new Error("Unknown key type " + key.type);
  }
  function read(partial, type, buf, options) {
    if (typeof buf === "string")
      buf = Buffer2.from(buf);
    assert.buffer(buf, "buf");
    var key = {};
    var parts = key.parts = [];
    var sshbuf = new SSHBuffer({ buffer: buf });
    var alg = sshbuf.readString();
    assert.ok(!sshbuf.atEnd(), "key must have at least one part");
    key.type = algToKeyType(alg);
    var partCount = algs.info[key.type].parts.length;
    if (type && type === "private")
      partCount = algs.privInfo[key.type].parts.length;
    while (!sshbuf.atEnd() && parts.length < partCount)
      parts.push(sshbuf.readPart());
    while (!partial && !sshbuf.atEnd())
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    assert.ok(partial || sshbuf.atEnd(), "leftover bytes at end of key");
    var Constructor = Key;
    var algInfo = algs.info[key.type];
    if (type === "private" || algInfo.parts.length !== parts.length) {
      algInfo = algs.privInfo[key.type];
      Constructor = PrivateKey;
    }
    assert.strictEqual(algInfo.parts.length, parts.length);
    if (key.type === "ecdsa") {
      var res = /^ecdsa-sha2-(.+)$/.exec(alg);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    var normalized = true;
    for (var i = 0;i < algInfo.parts.length; ++i) {
      var p = parts[i];
      p.name = algInfo.parts[i];
      if (key.type === "ed25519" && p.name === "k")
        p.data = p.data.slice(0, 32);
      if (p.name !== "curve" && algInfo.normalize !== false) {
        var nd;
        if (key.type === "ed25519") {
          nd = utils.zeroPadToLength(p.data, 32);
        } else {
          nd = utils.mpNormalize(p.data);
        }
        if (nd.toString("binary") !== p.data.toString("binary")) {
          p.data = nd;
          normalized = false;
        }
      }
    }
    if (normalized)
      key._rfc4253Cache = sshbuf.toBuffer();
    if (partial && typeof partial === "object") {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Constructor(key);
  }
  function write(key, options) {
    assert.object(key);
    var alg = keyTypeToAlg(key);
    var i;
    var algInfo = algs.info[key.type];
    if (PrivateKey.isPrivateKey(key))
      algInfo = algs.privInfo[key.type];
    var parts = algInfo.parts;
    var buf = new SSHBuffer({});
    buf.writeString(alg);
    for (i = 0;i < parts.length; ++i) {
      var data = key.part[parts[i]].data;
      if (algInfo.normalize !== false) {
        if (key.type === "ed25519")
          data = utils.zeroPadToLength(data, 32);
        else
          data = utils.mpNormalize(data);
      }
      if (key.type === "ed25519" && parts[i] === "k")
        data = Buffer2.concat([data, key.part.A.data]);
      buf.writeBuffer(data);
    }
    return buf.toBuffer();
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS((exports, module) => {
  var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
  var BLF_J = 0;
  var Blowfish = function() {
    this.S = [
      new Uint32Array([
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946
      ]),
      new Uint32Array([
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        2909710000,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055
      ]),
      new Uint32Array([
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504
      ]),
      new Uint32Array([
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409000,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ])
    ];
    this.P = new Uint32Array([
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ]);
  };
  function F(S, x8, i) {
    return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
  }
  Blowfish.prototype.encipher = function(x, x8) {
    if (x8 === undefined) {
      x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
    }
    x[0] ^= this.P[0];
    for (var i = 1;i < 16; i += 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[17];
    x[1] = t;
  };
  Blowfish.prototype.decipher = function(x) {
    var x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
    x[0] ^= this.P[17];
    for (var i = 16;i > 0; i -= 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[0];
    x[1] = t;
  };
  function stream2word(data, databytes) {
    var i, temp = 0;
    for (i = 0;i < 4; i++, BLF_J++) {
      if (BLF_J >= databytes)
        BLF_J = 0;
      temp = temp << 8 | data[BLF_J];
    }
    return temp;
  }
  Blowfish.prototype.expand0state = function(key, keybytes) {
    var d = new Uint32Array(2), i, k;
    var d8 = new Uint8Array(d.buffer);
    for (i = 0, BLF_J = 0;i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    BLF_J = 0;
    for (i = 0;i < 18; i += 2) {
      this.encipher(d, d8);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0;i < 4; i++) {
      for (k = 0;k < 256; k += 2) {
        this.encipher(d, d8);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
  };
  Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
    var d = new Uint32Array(2), i, k;
    for (i = 0, BLF_J = 0;i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    for (i = 0, BLF_J = 0;i < 18; i += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0;i < 4; i++) {
      for (k = 0;k < 256; k += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
    BLF_J = 0;
  };
  Blowfish.prototype.enc = function(data, blocks) {
    for (var i = 0;i < blocks; i++) {
      this.encipher(data.subarray(i * 2));
    }
  };
  Blowfish.prototype.dec = function(data, blocks) {
    for (var i = 0;i < blocks; i++) {
      this.decipher(data.subarray(i * 2));
    }
  };
  var BCRYPT_BLOCKS = 8;
  var BCRYPT_HASHSIZE = 32;
  function bcrypt_hash(sha2pass, sha2salt, out) {
    var state = new Blowfish, cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
      79,
      120,
      121,
      99,
      104,
      114,
      111,
      109,
      97,
      116,
      105,
      99,
      66,
      108,
      111,
      119,
      102,
      105,
      115,
      104,
      83,
      119,
      97,
      116,
      68,
      121,
      110,
      97,
      109,
      105,
      116,
      101
    ]);
    state.expandstate(sha2salt, 64, sha2pass, 64);
    for (i = 0;i < 64; i++) {
      state.expand0state(sha2salt, 64);
      state.expand0state(sha2pass, 64);
    }
    for (i = 0;i < BCRYPT_BLOCKS; i++)
      cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
    for (i = 0;i < 64; i++)
      state.enc(cdata, cdata.byteLength / 8);
    for (i = 0;i < BCRYPT_BLOCKS; i++) {
      out[4 * i + 3] = cdata[i] >>> 24;
      out[4 * i + 2] = cdata[i] >>> 16;
      out[4 * i + 1] = cdata[i] >>> 8;
      out[4 * i + 0] = cdata[i];
    }
  }
  function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
    var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
    if (rounds < 1)
      return -1;
    if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
      return -1;
    stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
    amt = Math.floor((keylen + stride - 1) / stride);
    for (i = 0;i < saltlen; i++)
      countsalt[i] = salt[i];
    crypto_hash_sha512(sha2pass, pass, passlen);
    for (count = 1;keylen > 0; count++) {
      countsalt[saltlen + 0] = count >>> 24;
      countsalt[saltlen + 1] = count >>> 16;
      countsalt[saltlen + 2] = count >>> 8;
      countsalt[saltlen + 3] = count;
      crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (i = out.byteLength;i--; )
        out[i] = tmpout[i];
      for (i = 1;i < rounds; i++) {
        crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (j = 0;j < out.byteLength; j++)
          out[j] ^= tmpout[j];
      }
      amt = Math.min(amt, keylen);
      for (i = 0;i < amt; i++) {
        dest = i * stride + (count - 1);
        if (dest >= origkeylen)
          break;
        key[dest] = out[i];
      }
      keylen -= i;
    }
    return 0;
  }
  module.exports = {
    BLOCKS: BCRYPT_BLOCKS,
    HASHSIZE: BCRYPT_HASHSIZE,
    hash: bcrypt_hash,
    pbkdf: bcrypt_pbkdf
  };
});

// node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS((exports, module) => {
  module.exports = {
    read,
    readSSHPrivate,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var crypto = __require("crypto");
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var rfc4253 = require_rfc4253();
  var SSHBuffer = require_ssh_buffer();
  var errors = require_errors();
  var bcrypt;
  function read(buf, options) {
    return pem.read(buf, options);
  }
  var MAGIC = "openssh-key-v1";
  function readSSHPrivate(type, buf, options) {
    buf = new SSHBuffer({ buffer: buf });
    var magic = buf.readCString();
    assert.strictEqual(magic, MAGIC, "bad magic string");
    var cipher = buf.readString();
    var kdf = buf.readString();
    var kdfOpts = buf.readBuffer();
    var nkeys = buf.readInt();
    if (nkeys !== 1) {
      throw new Error("OpenSSH-format key file contains " + "multiple keys: this is unsupported.");
    }
    var pubKey = buf.readBuffer();
    if (type === "public") {
      assert.ok(buf.atEnd(), "excess bytes left after key");
      return rfc4253.read(pubKey);
    }
    var privKeyBlob = buf.readBuffer();
    assert.ok(buf.atEnd(), "excess bytes left after key");
    var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
    switch (kdf) {
      case "none":
        if (cipher !== "none") {
          throw new Error('OpenSSH-format key uses KDF "none" ' + 'but specifies a cipher other than "none"');
        }
        break;
      case "bcrypt":
        var salt = kdfOptsBuf.readBuffer();
        var rounds = kdfOptsBuf.readInt();
        var cinf = utils.opensshCipherInfo(cipher);
        if (bcrypt === undefined) {
          bcrypt = require_bcrypt_pbkdf();
        }
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "OpenSSH");
        }
        var pass = new Uint8Array(options.passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned " + "failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createDecipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase " + "supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(privKeyBlob);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privKeyBlob = Buffer2.concat(chunks);
        break;
      default:
        throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
    }
    buf = new SSHBuffer({ buffer: privKeyBlob });
    var checkInt1 = buf.readInt();
    var checkInt2 = buf.readInt();
    if (checkInt1 !== checkInt2) {
      throw new Error("Incorrect passphrase supplied, could not " + "decrypt key");
    }
    var ret = {};
    var key = rfc4253.readInternal(ret, "private", buf.remainder());
    buf.skip(ret.consumed);
    var comment = buf.readString();
    key.comment = comment;
    return key;
  }
  function write(key, options) {
    var pubKey;
    if (PrivateKey.isPrivateKey(key))
      pubKey = key.toPublic();
    else
      pubKey = key;
    var cipher = "none";
    var kdf = "none";
    var kdfopts = Buffer2.alloc(0);
    var cinf = { blockSize: 8 };
    var passphrase;
    if (options !== undefined) {
      passphrase = options.passphrase;
      if (typeof passphrase === "string")
        passphrase = Buffer2.from(passphrase, "utf-8");
      if (passphrase !== undefined) {
        assert.buffer(passphrase, "options.passphrase");
        assert.optionalString(options.cipher, "options.cipher");
        cipher = options.cipher;
        if (cipher === undefined)
          cipher = "aes128-ctr";
        cinf = utils.opensshCipherInfo(cipher);
        kdf = "bcrypt";
      }
    }
    var privBuf;
    if (PrivateKey.isPrivateKey(key)) {
      privBuf = new SSHBuffer({});
      var checkInt = crypto.randomBytes(4).readUInt32BE(0);
      privBuf.writeInt(checkInt);
      privBuf.writeInt(checkInt);
      privBuf.write(key.toBuffer("rfc4253"));
      privBuf.writeString(key.comment || "");
      var n = 1;
      while (privBuf._offset % cinf.blockSize !== 0)
        privBuf.writeChar(n++);
      privBuf = privBuf.toBuffer();
    }
    switch (kdf) {
      case "none":
        break;
      case "bcrypt":
        var salt = crypto.randomBytes(16);
        var rounds = 16;
        var kdfssh = new SSHBuffer({});
        kdfssh.writeBuffer(salt);
        kdfssh.writeInt(rounds);
        kdfopts = kdfssh.toBuffer();
        if (bcrypt === undefined) {
          bcrypt = require_bcrypt_pbkdf();
        }
        var pass = new Uint8Array(passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned " + "failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createCipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          throw e;
        });
        cipherStream.write(privBuf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privBuf = Buffer2.concat(chunks);
        break;
      default:
        throw new Error("Unsupported kdf " + kdf);
    }
    var buf = new SSHBuffer({});
    buf.writeCString(MAGIC);
    buf.writeString(cipher);
    buf.writeString(kdf);
    buf.writeBuffer(kdfopts);
    buf.writeInt(1);
    buf.writeBuffer(pubKey.toBuffer("rfc4253"));
    if (privBuf)
      buf.writeBuffer(privBuf);
    buf = buf.toBuffer();
    var header;
    if (PrivateKey.isPrivateKey(key))
      header = "OPENSSH PRIVATE KEY";
    else
      header = "OPENSSH PUBLIC KEY";
    var tmp = buf.toString("base64");
    var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
    buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + `-----
`, o);
    for (var i = 0;i < tmp.length; ) {
      var limit = i + 70;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + `-----
`, o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS((exports, module) => {
  module.exports = {
    read,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var crypto = __require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pkcs1 = require_pkcs1();
  var pkcs8 = require_pkcs8();
  var sshpriv = require_ssh_private();
  var rfc4253 = require_rfc4253();
  var errors = require_errors();
  var OID_PBES2 = "1.2.840.113549.1.5.13";
  var OID_PBKDF2 = "1.2.840.113549.1.5.12";
  var OID_TO_CIPHER = {
    "1.2.840.113549.3.7": "3des-cbc",
    "2.16.840.1.101.3.4.1.2": "aes128-cbc",
    "2.16.840.1.101.3.4.1.42": "aes256-cbc"
  };
  var CIPHER_TO_OID = {};
  Object.keys(OID_TO_CIPHER).forEach(function(k) {
    CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
  });
  var OID_TO_HASH = {
    "1.2.840.113549.2.7": "sha1",
    "1.2.840.113549.2.9": "sha256",
    "1.2.840.113549.2.11": "sha512"
  };
  var HASH_TO_OID = {};
  Object.keys(OID_TO_HASH).forEach(function(k) {
    HASH_TO_OID[OID_TO_HASH[k]] = k;
  });
  function read(buf, options, forceType) {
    var input = buf;
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
    }
    assert.ok(m2, "invalid PEM footer");
    assert.equal(m[2], m2[2]);
    var type = m[2].toLowerCase();
    var alg;
    if (m[1]) {
      assert.equal(m[1], m2[1], "PEM header and footer mismatch");
      alg = m[1].trim();
    }
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    var cipher, key, iv;
    if (headers["proc-type"]) {
      var parts = headers["proc-type"].split(",");
      if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        } else {
          parts = headers["dek-info"].split(",");
          assert.ok(parts.length === 2);
          cipher = parts[0].toLowerCase();
          iv = Buffer2.from(parts[1], "hex");
          key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
        }
      }
    }
    if (alg && alg.toLowerCase() === "encrypted") {
      var eder = new asn1.BerReader(buf);
      var pbesEnd;
      eder.readSequence();
      eder.readSequence();
      pbesEnd = eder.offset + eder.length;
      var method = eder.readOID();
      if (method !== OID_PBES2) {
        throw new Error("Unsupported PEM/PKCS8 encryption " + "scheme: " + method);
      }
      eder.readSequence();
      eder.readSequence();
      var kdfEnd = eder.offset + eder.length;
      var kdfOid = eder.readOID();
      if (kdfOid !== OID_PBKDF2)
        throw new Error("Unsupported PBES2 KDF: " + kdfOid);
      eder.readSequence();
      var salt = eder.readString(asn1.Ber.OctetString, true);
      var iterations = eder.readInt();
      var hashAlg = "sha1";
      if (eder.offset < kdfEnd) {
        eder.readSequence();
        var hashAlgOid = eder.readOID();
        hashAlg = OID_TO_HASH[hashAlgOid];
        if (hashAlg === undefined) {
          throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
        }
      }
      eder._offset = kdfEnd;
      eder.readSequence();
      var cipherOid = eder.readOID();
      cipher = OID_TO_CIPHER[cipherOid];
      if (cipher === undefined) {
        throw new Error("Unsupported PBES2 cipher: " + cipherOid);
      }
      iv = eder.readString(asn1.Ber.OctetString, true);
      eder._offset = pbesEnd;
      buf = eder.readString(asn1.Ber.OctetString, true);
      if (typeof options.passphrase === "string") {
        options.passphrase = Buffer2.from(options.passphrase, "utf-8");
      }
      if (!Buffer2.isBuffer(options.passphrase)) {
        throw new errors.KeyEncryptedError(options.filename, "PEM");
      }
      var cinfo = utils.opensshCipherInfo(cipher);
      cipher = cinfo.opensslName;
      key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize, options.passphrase);
      alg = undefined;
    }
    if (cipher && key && iv) {
      var cipherStream = crypto.createDecipheriv(cipher, key, iv);
      var chunk, chunks = [];
      cipherStream.once("error", function(e) {
        if (e.toString().indexOf("bad decrypt") !== -1) {
          throw new Error("Incorrect passphrase " + "supplied, could not decrypt key");
        }
        throw e;
      });
      cipherStream.write(buf);
      cipherStream.end();
      while ((chunk = cipherStream.read()) !== null)
        chunks.push(chunk);
      buf = Buffer2.concat(chunks);
    }
    if (alg && alg.toLowerCase() === "openssh")
      return sshpriv.readSSHPrivate(type, buf, options);
    if (alg && alg.toLowerCase() === "ssh2")
      return rfc4253.readType(type, buf, options);
    var der = new asn1.BerReader(buf);
    der.originalInput = input;
    der.readSequence();
    if (alg) {
      if (forceType)
        assert.strictEqual(forceType, "pkcs1");
      return pkcs1.readPkcs1(alg, type, der);
    } else {
      if (forceType)
        assert.strictEqual(forceType, "pkcs8");
      return pkcs8.readPkcs8(alg, type, der);
    }
  }
  function write(key, options, type) {
    assert.object(key);
    var alg = {
      ecdsa: "EC",
      rsa: "RSA",
      dsa: "DSA",
      ed25519: "EdDSA"
    }[key.type];
    var header;
    var der = new asn1.BerWriter;
    if (PrivateKey.isPrivateKey(key)) {
      if (type && type === "pkcs8") {
        header = "PRIVATE KEY";
        pkcs8.writePkcs8(der, key);
      } else {
        if (type)
          assert.strictEqual(type, "pkcs1");
        header = alg + " PRIVATE KEY";
        pkcs1.writePkcs1(der, key);
      }
    } else if (Key.isKey(key)) {
      if (type && type === "pkcs1") {
        header = alg + " PUBLIC KEY";
        pkcs1.writePkcs1(der, key);
      } else {
        if (type)
          assert.strictEqual(type, "pkcs8");
        header = "PUBLIC KEY";
        pkcs8.writePkcs8(der, key);
      }
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
    var tmp = der.buffer.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + `-----
`, o);
    for (var i = 0;i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + `-----
`, o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS((exports, module) => {
  module.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var sshpriv = require_ssh_private();
  var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
  var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var trimmed = buf.trim().replace(/[\\\r]/g, "");
    var m = trimmed.match(SSHKEY_RE);
    if (!m)
      m = trimmed.match(SSHKEY_RE2);
    assert.ok(m, "key must match regex");
    var type = rfc4253.algToKeyType(m[1]);
    var kbuf = Buffer2.from(m[2], "base64");
    var key;
    var ret = {};
    if (m[4]) {
      try {
        key = rfc4253.read(kbuf);
      } catch (e) {
        m = trimmed.match(SSHKEY_RE2);
        assert.ok(m, "key must match regex");
        kbuf = Buffer2.from(m[2], "base64");
        key = rfc4253.readInternal(ret, "public", kbuf);
      }
    } else {
      key = rfc4253.readInternal(ret, "public", kbuf);
    }
    assert.strictEqual(type, key.type);
    if (m[4] && m[4].length > 0) {
      key.comment = m[4];
    } else if (ret.consumed) {
      var data = m[2] + (m[3] ? m[3] : "");
      var realOffset = Math.ceil(ret.consumed / 3) * 4;
      data = data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data.slice(realOffset - 2);
      var padding = ret.consumed % 3;
      if (padding > 0 && data.slice(realOffset - 1, realOffset) !== "=")
        realOffset--;
      while (data.slice(realOffset, realOffset + 1) === "=")
        realOffset++;
      var trailer = data.slice(realOffset);
      trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
      if (trailer.match(/^[a-zA-Z0-9]/))
        key.comment = trailer;
    }
    return key;
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key))
      throw new Error("Must be a public key");
    var parts = [];
    var alg = rfc4253.keyTypeToAlg(key);
    parts.push(alg);
    var buf = rfc4253.write(key);
    parts.push(buf.toString("base64"));
    if (key.comment)
      parts.push(key.comment);
    return Buffer2.from(parts.join(" "));
  }
});

// node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS((exports, module) => {
  module.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Key = require_key();
  var PrivateKey = require_private_key();
  var utils = require_utils();
  var SSHBuffer = require_ssh_buffer();
  var Dhe = require_dhe();
  var supportedAlgos = {
    "rsa-sha1": 5,
    "rsa-sha256": 8,
    "rsa-sha512": 10,
    "ecdsa-p256-sha256": 13,
    "ecdsa-p384-sha384": 14
  };
  var supportedAlgosById = {};
  Object.keys(supportedAlgos).forEach(function(k) {
    supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
  });
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.split(`
`);
    if (lines[0].match(/^Private-key-format\: v1/)) {
      var algElems = lines[1].split(" ");
      var algoNum = parseInt(algElems[1], 10);
      var algoName = algElems[2];
      if (!supportedAlgosById[algoNum])
        throw new Error("Unsupported algorithm: " + algoName);
      return readDNSSECPrivateKey(algoNum, lines.slice(2));
    }
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
      return readRFC3110(lines[line]);
    }
    throw new Error("Cannot parse dnssec key");
  }
  function readRFC3110(keyString) {
    var elems = keyString.split(" ");
    var algorithm = parseInt(elems[5], 10);
    if (!supportedAlgosById[algorithm])
      throw new Error("Unsupported algorithm: " + algorithm);
    var base64key = elems.slice(6, elems.length).join();
    var keyBuffer = Buffer2.from(base64key, "base64");
    if (supportedAlgosById[algorithm].match(/^RSA-/)) {
      var publicExponentLen = keyBuffer.readUInt8(0);
      if (publicExponentLen != 3 && publicExponentLen != 1)
        throw new Error("Cannot parse dnssec key: " + "unsupported exponent length");
      var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
      publicExponent = utils.mpNormalize(publicExponent);
      var modulus = keyBuffer.slice(1 + publicExponentLen);
      modulus = utils.mpNormalize(modulus);
      var rsaKey = {
        type: "rsa",
        parts: []
      };
      rsaKey.parts.push({ name: "e", data: publicExponent });
      rsaKey.parts.push({ name: "n", data: modulus });
      return new Key(rsaKey);
    }
    if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
        curve = "nistp256";
        size = 256;
      }
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: utils.ecNormalize(keyBuffer) }
        ]
      };
      return new Key(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
  }
  function elementToBuf(e) {
    return Buffer2.from(e.split(" ")[1], "base64");
  }
  function readDNSSECRSAPrivateKey(elements) {
    var rsaParams = {};
    elements.forEach(function(element) {
      if (element.split(" ")[0] === "Modulus:")
        rsaParams["n"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PublicExponent:")
        rsaParams["e"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PrivateExponent:")
        rsaParams["d"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime1:")
        rsaParams["p"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime2:")
        rsaParams["q"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent1:")
        rsaParams["dmodp"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent2:")
        rsaParams["dmodq"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Coefficient:")
        rsaParams["iqmp"] = elementToBuf(element);
    });
    var key = {
      type: "rsa",
      parts: [
        { name: "e", data: utils.mpNormalize(rsaParams["e"]) },
        { name: "n", data: utils.mpNormalize(rsaParams["n"]) },
        { name: "d", data: utils.mpNormalize(rsaParams["d"]) },
        { name: "p", data: utils.mpNormalize(rsaParams["p"]) },
        { name: "q", data: utils.mpNormalize(rsaParams["q"]) },
        {
          name: "dmodp",
          data: utils.mpNormalize(rsaParams["dmodp"])
        },
        {
          name: "dmodq",
          data: utils.mpNormalize(rsaParams["dmodq"])
        },
        {
          name: "iqmp",
          data: utils.mpNormalize(rsaParams["iqmp"])
        }
      ]
    };
    return new PrivateKey(key);
  }
  function readDNSSECPrivateKey(alg, elements) {
    if (supportedAlgosById[alg].match(/^RSA-/)) {
      return readDNSSECRSAPrivateKey(elements);
    }
    if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
      var d = Buffer2.from(elements[0].split(" ")[1], "base64");
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        curve = "nistp256";
        size = 256;
      }
      var publicKey = utils.publicFromPrivateECDSA(curve, d);
      var Q = publicKey.part["Q"].data;
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "d", data: d },
          { name: "Q", data: Q }
        ]
      };
      return new PrivateKey(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
  }
  function dnssecTimestamp(date) {
    var year = date.getFullYear() + "";
    var month = date.getMonth() + 1;
    var timestampStr = year + month + date.getUTCDate();
    timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
    timestampStr += date.getUTCSeconds();
    return timestampStr;
  }
  function rsaAlgFromOptions(opts) {
    if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
      return "5 (RSASHA1)";
    else if (opts.hashAlgo === "sha256")
      return "8 (RSASHA256)";
    else if (opts.hashAlgo === "sha512")
      return "10 (RSASHA512)";
    else
      throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
  }
  function writeRSA(key, options) {
    if (!key.part.dmodp || !key.part.dmodq) {
      utils.addRSAMissing(key);
    }
    var out = "";
    out += `Private-key-format: v1.3
`;
    out += "Algorithm: " + rsaAlgFromOptions(options) + `
`;
    var n = utils.mpDenormalize(key.part["n"].data);
    out += "Modulus: " + n.toString("base64") + `
`;
    var e = utils.mpDenormalize(key.part["e"].data);
    out += "PublicExponent: " + e.toString("base64") + `
`;
    var d = utils.mpDenormalize(key.part["d"].data);
    out += "PrivateExponent: " + d.toString("base64") + `
`;
    var p = utils.mpDenormalize(key.part["p"].data);
    out += "Prime1: " + p.toString("base64") + `
`;
    var q2 = utils.mpDenormalize(key.part["q"].data);
    out += "Prime2: " + q2.toString("base64") + `
`;
    var dmodp = utils.mpDenormalize(key.part["dmodp"].data);
    out += "Exponent1: " + dmodp.toString("base64") + `
`;
    var dmodq = utils.mpDenormalize(key.part["dmodq"].data);
    out += "Exponent2: " + dmodq.toString("base64") + `
`;
    var iqmp = utils.mpDenormalize(key.part["iqmp"].data);
    out += "Coefficient: " + iqmp.toString("base64") + `
`;
    var timestamp = new Date;
    out += "Created: " + dnssecTimestamp(timestamp) + `
`;
    out += "Publish: " + dnssecTimestamp(timestamp) + `
`;
    out += "Activate: " + dnssecTimestamp(timestamp) + `
`;
    return Buffer2.from(out, "ascii");
  }
  function writeECDSA(key, options) {
    var out = "";
    out += `Private-key-format: v1.3
`;
    if (key.curve === "nistp256") {
      out += `Algorithm: 13 (ECDSAP256SHA256)
`;
    } else if (key.curve === "nistp384") {
      out += `Algorithm: 14 (ECDSAP384SHA384)
`;
    } else {
      throw new Error("Unsupported curve");
    }
    var base64Key = key.part["d"].data.toString("base64");
    out += "PrivateKey: " + base64Key + `
`;
    var timestamp = new Date;
    out += "Created: " + dnssecTimestamp(timestamp) + `
`;
    out += "Publish: " + dnssecTimestamp(timestamp) + `
`;
    out += "Activate: " + dnssecTimestamp(timestamp) + `
`;
    return Buffer2.from(out, "ascii");
  }
  function write(key, options) {
    if (PrivateKey.isPrivateKey(key)) {
      if (key.type === "rsa") {
        return writeRSA(key, options);
      } else if (key.type === "ecdsa") {
        return writeECDSA(key, options);
      } else {
        throw new Error("Unsupported algorithm: " + key.type);
      }
    } else if (Key.isKey(key)) {
      throw new Error('Format "dnssec" only supports ' + "writing private keys");
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
  }
});

// node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS((exports, module) => {
  module.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var Key = require_key();
  var SSHBuffer = require_ssh_buffer();
  var crypto = __require("crypto");
  var PrivateKey = require_private_key();
  var errors = require_errors();
  function read(buf, options) {
    var lines = buf.toString("ascii").split(/[\r\n]+/);
    var found = false;
    var parts;
    var si = 0;
    var formatVersion;
    while (si < lines.length) {
      parts = splitHeader(lines[si++]);
      if (parts) {
        formatVersion = {
          "putty-user-key-file-2": 2,
          "putty-user-key-file-3": 3
        }[parts[0].toLowerCase()];
        if (formatVersion) {
          found = true;
          break;
        }
      }
    }
    if (!found) {
      throw new Error("No PuTTY format first line found");
    }
    var alg = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "encryption");
    var encryption = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "comment");
    var comment = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "public-lines");
    var publicLines = parseInt(parts[1], 10);
    if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
      throw new Error("Invalid public-lines count");
    }
    var publicBuf = Buffer2.from(lines.slice(si, si + publicLines).join(""), "base64");
    var keyType = rfc4253.algToKeyType(alg);
    var key = rfc4253.read(publicBuf);
    if (key.type !== keyType) {
      throw new Error("Outer key algorithm mismatch");
    }
    si += publicLines;
    if (lines[si]) {
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "private-lines");
      var privateLines = parseInt(parts[1], 10);
      if (!isFinite(privateLines) || privateLines < 0 || privateLines > lines.length) {
        throw new Error("Invalid private-lines count");
      }
      var privateBuf = Buffer2.from(lines.slice(si, si + privateLines).join(""), "base64");
      if (encryption !== "none" && formatVersion === 3) {
        throw new Error("Encrypted keys arenot supported for" + " PuTTY format version 3");
      }
      if (encryption === "aes256-cbc") {
        if (!options.passphrase) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        }
        var iv = Buffer2.alloc(16, 0);
        var decipher = crypto.createDecipheriv("aes-256-cbc", derivePPK2EncryptionKey(options.passphrase), iv);
        decipher.setAutoPadding(false);
        privateBuf = Buffer2.concat([
          decipher.update(privateBuf),
          decipher.final()
        ]);
      }
      key = new PrivateKey(key);
      if (key.type !== keyType) {
        throw new Error("Outer key algorithm mismatch");
      }
      var sshbuf = new SSHBuffer({ buffer: privateBuf });
      var privateKeyParts;
      if (alg === "ssh-dss") {
        privateKeyParts = [{
          name: "x",
          data: sshbuf.readBuffer()
        }];
      } else if (alg === "ssh-rsa") {
        privateKeyParts = [
          { name: "d", data: sshbuf.readBuffer() },
          { name: "p", data: sshbuf.readBuffer() },
          { name: "q", data: sshbuf.readBuffer() },
          { name: "iqmp", data: sshbuf.readBuffer() }
        ];
      } else if (alg.match(/^ecdsa-sha2-nistp/)) {
        privateKeyParts = [{
          name: "d",
          data: sshbuf.readBuffer()
        }];
      } else if (alg === "ssh-ed25519") {
        privateKeyParts = [{
          name: "k",
          data: sshbuf.readBuffer()
        }];
      } else {
        throw new Error("Unsupported PPK key type: " + alg);
      }
      key = new PrivateKey({
        type: key.type,
        parts: key.parts.concat(privateKeyParts)
      });
    }
    key.comment = comment;
    return key;
  }
  function derivePPK2EncryptionKey(passphrase) {
    var hash1 = crypto.createHash("sha1").update(Buffer2.concat([
      Buffer2.from([0, 0, 0, 0]),
      Buffer2.from(passphrase)
    ])).digest();
    var hash2 = crypto.createHash("sha1").update(Buffer2.concat([
      Buffer2.from([0, 0, 0, 1]),
      Buffer2.from(passphrase)
    ])).digest();
    return Buffer2.concat([hash1, hash2]).slice(0, 32);
  }
  function splitHeader(line) {
    var idx = line.indexOf(":");
    if (idx === -1)
      return null;
    var header = line.slice(0, idx);
    ++idx;
    while (line[idx] === " ")
      ++idx;
    var rest = line.slice(idx);
    return [header, rest];
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key))
      throw new Error("Must be a public key");
    var alg = rfc4253.keyTypeToAlg(key);
    var buf = rfc4253.write(key);
    var comment = key.comment || "";
    var b64 = buf.toString("base64");
    var lines = wrap(b64, 64);
    lines.unshift("Public-Lines: " + lines.length);
    lines.unshift("Comment: " + comment);
    lines.unshift("Encryption: none");
    lines.unshift("PuTTY-User-Key-File-2: " + alg);
    return Buffer2.from(lines.join(`
`) + `
`);
  }
  function wrap(txt, len) {
    var lines = [];
    var pos = 0;
    while (pos < txt.length) {
      lines.push(txt.slice(pos, pos + 64));
      pos += 64;
    }
    return lines;
  }
});

// node_modules/sshpk/lib/formats/auto.js
var require_auto = __commonJS((exports, module) => {
  module.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var ssh = require_ssh();
  var rfc4253 = require_rfc4253();
  var dnssec = require_dnssec();
  var putty = require_putty();
  var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
  function read(buf, options) {
    if (typeof buf === "string") {
      if (buf.trim().match(/^[-]+[ ]*BEGIN/))
        return pem.read(buf, options);
      if (buf.match(/^\s*ssh-[a-z]/))
        return ssh.read(buf, options);
      if (buf.match(/^\s*ecdsa-/))
        return ssh.read(buf, options);
      if (buf.match(/^putty-user-key-file-2:/i))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec.read(buf, options);
      buf = Buffer2.from(buf, "binary");
    } else {
      assert.buffer(buf);
      if (findPEMHeader(buf))
        return pem.read(buf, options);
      if (findSSHHeader(buf))
        return ssh.read(buf, options);
      if (findPuTTYHeader(buf))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec.read(buf, options);
    }
    if (buf.readUInt32BE(0) < buf.length)
      return rfc4253.read(buf, options);
    throw new Error("Failed to auto-detect format of key");
  }
  function findPuTTYHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
      return true;
    return false;
  }
  function findSSHHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
      return true;
    if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
      return true;
    return false;
  }
  function findPEMHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
      ++offset;
    if (buf[offset] !== 45)
      return false;
    while (offset < buf.length && buf[offset] === 45)
      ++offset;
    while (offset < buf.length && buf[offset] === 32)
      ++offset;
    if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
      return false;
    return true;
  }
  function findDNSSECHeader(buf) {
    if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
      return false;
    var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
    if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
      return true;
    if (typeof buf !== "string") {
      buf = buf.toString("ascii");
    }
    var lines = buf.split(`
`);
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if (lines[line].toString("ascii").match(/\. IN KEY /))
      return true;
    if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
      return true;
    return false;
  }
  function write(key, options) {
    throw new Error('"auto" format cannot be used for writing');
  }
});

// node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS((exports, module) => {
  module.exports = PrivateKey;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = __require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = __require("util");
  var utils = require_utils();
  var dhe = require_dhe();
  var generateECDSA = dhe.generateECDSA;
  var generateED25519 = dhe.generateED25519;
  var edCompat = require_ed_compat();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var KeyEncryptedError = errs.KeyEncryptedError;
  var formats = {};
  formats["auto"] = require_auto();
  formats["pem"] = require_pem();
  formats["pkcs1"] = require_pkcs1();
  formats["pkcs8"] = require_pkcs8();
  formats["rfc4253"] = require_rfc4253();
  formats["ssh-private"] = require_ssh_private();
  formats["openssh"] = formats["ssh-private"];
  formats["ssh"] = formats["ssh-private"];
  formats["dnssec"] = require_dnssec();
  formats["putty"] = require_putty();
  function PrivateKey(opts) {
    assert.object(opts, "options");
    Key.call(this, opts);
    this._pubCache = undefined;
  }
  util.inherits(PrivateKey, Key);
  PrivateKey.formats = formats;
  PrivateKey.prototype.toBuffer = function(format, options) {
    if (format === undefined)
      format = "pkcs1";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    return formats[format].write(this, options);
  };
  PrivateKey.prototype.hash = function(algo, type) {
    return this.toPublic().hash(algo, type);
  };
  PrivateKey.prototype.fingerprint = function(algo, type) {
    return this.toPublic().fingerprint(algo, type);
  };
  PrivateKey.prototype.toPublic = function() {
    if (this._pubCache)
      return this._pubCache;
    var algInfo = algs.info[this.type];
    var pubParts = [];
    for (var i = 0;i < algInfo.parts.length; ++i) {
      var p = algInfo.parts[i];
      pubParts.push(this.part[p]);
    }
    this._pubCache = new Key({
      type: this.type,
      source: this,
      parts: pubParts
    });
    if (this.comment)
      this._pubCache.comment = this.comment;
    return this._pubCache;
  };
  PrivateKey.prototype.derive = function(newType) {
    assert.string(newType, "type");
    var priv, pub, pair;
    if (this.type === "ed25519" && newType === "curve25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "curve25519",
        parts: [
          { name: "A", data: utils.mpNormalize(pub) },
          { name: "k", data: utils.mpNormalize(priv) }
        ]
      });
    } else if (this.type === "curve25519" && newType === "ed25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "ed25519",
        parts: [
          { name: "A", data: utils.mpNormalize(pub) },
          { name: "k", data: utils.mpNormalize(priv) }
        ]
      });
    }
    throw new Error("Key derivation not supported from " + this.type + " to " + newType);
  };
  PrivateKey.prototype.createVerify = function(hashAlgo) {
    return this.toPublic().createVerify(hashAlgo);
  };
  PrivateKey.prototype.createSign = function(hashAlgo) {
    if (hashAlgo === undefined)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat !== undefined)
      return new edCompat.Signer(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for " + "signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    } catch (e) {
      err = e;
    }
    if (v === undefined || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldSign = v.sign.bind(v);
    var key = this.toBuffer("pkcs1");
    var type = this.type;
    var curve = this.curve;
    v.sign = function() {
      var sig = oldSign(key);
      if (typeof sig === "string")
        sig = Buffer2.from(sig, "binary");
      sig = Signature.parse(sig, type, "asn1");
      sig.hashAlgorithm = hashAlgo;
      sig.curve = curve;
      return sig;
    };
    return v;
  };
  PrivateKey.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === undefined)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === undefined)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      assert.ok(k instanceof PrivateKey, "key is not a private key");
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  PrivateKey.isPrivateKey = function(obj2, ver) {
    return utils.isCompatible(obj2, PrivateKey, ver);
  };
  PrivateKey.generate = function(type, options) {
    if (options === undefined)
      options = {};
    assert.object(options, "options");
    switch (type) {
      case "ecdsa":
        if (options.curve === undefined)
          options.curve = "nistp256";
        assert.string(options.curve, "options.curve");
        return generateECDSA(options.curve);
      case "ed25519":
        return generateED25519();
      default:
        throw new Error("Key generation not supported with key " + 'type "' + type + '"');
    }
  };
  PrivateKey.prototype._sshpkApiVersion = [1, 6];
  PrivateKey._oldVersionDetect = function(obj2) {
    assert.func(obj2.toPublic);
    assert.func(obj2.createSign);
    if (obj2.derive)
      return [1, 3];
    if (obj2.defaultHashAlgorithm)
      return [1, 2];
    if (obj2.formats["auto"])
      return [1, 1];
    return [1, 0];
  };
});

// node_modules/sshpk/lib/identity.js
var require_identity = __commonJS((exports, module) => {
  module.exports = Identity;
  var assert = require_assert();
  var algs = require_algs();
  var crypto = __require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = __require("util");
  var utils = require_utils();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
  var oids = {};
  oids.cn = "2.5.4.3";
  oids.o = "2.5.4.10";
  oids.ou = "2.5.4.11";
  oids.l = "2.5.4.7";
  oids.s = "2.5.4.8";
  oids.c = "2.5.4.6";
  oids.sn = "2.5.4.4";
  oids.postalCode = "2.5.4.17";
  oids.serialNumber = "2.5.4.5";
  oids.street = "2.5.4.9";
  oids.x500UniqueIdentifier = "2.5.4.45";
  oids.role = "2.5.4.72";
  oids.telephoneNumber = "2.5.4.20";
  oids.description = "2.5.4.13";
  oids.dc = "0.9.2342.19200300.100.1.25";
  oids.uid = "0.9.2342.19200300.100.1.1";
  oids.mail = "0.9.2342.19200300.100.1.3";
  oids.title = "2.5.4.12";
  oids.gn = "2.5.4.42";
  oids.initials = "2.5.4.43";
  oids.pseudonym = "2.5.4.65";
  oids.emailAddress = "1.2.840.113549.1.9.1";
  var unoids = {};
  Object.keys(oids).forEach(function(k) {
    unoids[oids[k]] = k;
  });
  function Identity(opts) {
    var self2 = this;
    assert.object(opts, "options");
    assert.arrayOfObject(opts.components, "options.components");
    this.components = opts.components;
    this.componentLookup = {};
    this.components.forEach(function(c) {
      if (c.name && !c.oid)
        c.oid = oids[c.name];
      if (c.oid && !c.name)
        c.name = unoids[c.oid];
      if (self2.componentLookup[c.name] === undefined)
        self2.componentLookup[c.name] = [];
      self2.componentLookup[c.name].push(c);
    });
    if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
      this.cn = this.componentLookup.cn[0].value;
    }
    assert.optionalString(opts.type, "options.type");
    if (opts.type === undefined) {
      if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
        this.type = "host";
        this.hostname = this.componentLookup.dc.map(function(c) {
          return c.value;
        }).join(".");
      } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
        this.type = "email";
        this.email = this.componentLookup.mail[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.cn[0].value;
      } else {
        this.type = "unknown";
      }
    } else {
      this.type = opts.type;
      if (this.type === "host")
        this.hostname = opts.hostname;
      else if (this.type === "user")
        this.uid = opts.uid;
      else if (this.type === "email")
        this.email = opts.email;
      else
        throw new Error("Unknown type " + this.type);
    }
  }
  Identity.prototype.toString = function() {
    return this.components.map(function(c) {
      var n = c.name.toUpperCase();
      n = n.replace(/=/g, "\\=");
      var v = c.value;
      v = v.replace(/,/g, "\\,");
      return n + "=" + v;
    }).join(", ");
  };
  Identity.prototype.get = function(name, asArray) {
    assert.string(name, "name");
    var arr = this.componentLookup[name];
    if (arr === undefined || arr.length === 0)
      return;
    if (!asArray && arr.length > 1)
      throw new Error("Multiple values for attribute " + name);
    if (!asArray)
      return arr[0].value;
    return arr.map(function(c) {
      return c.value;
    });
  };
  Identity.prototype.toArray = function(idx) {
    return this.components.map(function(c) {
      return {
        name: c.name,
        value: c.value
      };
    });
  };
  var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
  var NOT_IA5 = /[^\x00-\x7f]/;
  Identity.prototype.toAsn1 = function(der, tag) {
    der.startSequence(tag);
    this.components.forEach(function(c) {
      der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      der.startSequence();
      der.writeOID(c.oid);
      if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
        var v = Buffer2.from(c.value, "utf8");
        der.writeBuffer(v, asn1.Ber.Utf8String);
      } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
        der.writeString(c.value, asn1.Ber.IA5String);
      } else {
        var type = asn1.Ber.PrintableString;
        if (c.asn1type !== undefined)
          type = c.asn1type;
        der.writeString(c.value, type);
      }
      der.endSequence();
      der.endSequence();
    });
    der.endSequence();
  };
  function globMatch(a, b) {
    if (a === "**" || b === "**")
      return true;
    var aParts = a.split(".");
    var bParts = b.split(".");
    if (aParts.length !== bParts.length)
      return false;
    for (var i = 0;i < aParts.length; ++i) {
      if (aParts[i] === "*" || bParts[i] === "*")
        continue;
      if (aParts[i] !== bParts[i])
        return false;
    }
    return true;
  }
  Identity.prototype.equals = function(other) {
    if (!Identity.isIdentity(other, [1, 0]))
      return false;
    if (other.components.length !== this.components.length)
      return false;
    for (var i = 0;i < this.components.length; ++i) {
      if (this.components[i].oid !== other.components[i].oid)
        return false;
      if (!globMatch(this.components[i].value, other.components[i].value)) {
        return false;
      }
    }
    return true;
  };
  Identity.forHost = function(hostname) {
    assert.string(hostname, "hostname");
    return new Identity({
      type: "host",
      hostname,
      components: [{ name: "cn", value: hostname }]
    });
  };
  Identity.forUser = function(uid) {
    assert.string(uid, "uid");
    return new Identity({
      type: "user",
      uid,
      components: [{ name: "uid", value: uid }]
    });
  };
  Identity.forEmail = function(email) {
    assert.string(email, "email");
    return new Identity({
      type: "email",
      email,
      components: [{ name: "mail", value: email }]
    });
  };
  Identity.parseDN = function(dn) {
    assert.string(dn, "dn");
    var parts = [""];
    var idx = 0;
    var rem = dn;
    while (rem.length > 0) {
      var m;
      if ((m = /^,/.exec(rem)) !== null) {
        parts[++idx] = "";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\,/.exec(rem)) !== null) {
        parts[idx] += ",";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\./.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else {
        throw new Error("Failed to parse DN");
      }
    }
    var cmps = parts.map(function(c) {
      c = c.trim();
      var eqPos = c.indexOf("=");
      while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
        eqPos = c.indexOf("=", eqPos + 1);
      if (eqPos === -1) {
        throw new Error("Failed to parse DN");
      }
      var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
      var value = c.slice(eqPos + 1);
      return { name, value };
    });
    return new Identity({ components: cmps });
  };
  Identity.fromArray = function(components) {
    assert.arrayOfObject(components, "components");
    components.forEach(function(cmp) {
      assert.object(cmp, "component");
      assert.string(cmp.name, "component.name");
      if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
        throw new Error("Invalid component value");
      }
    });
    return new Identity({ components });
  };
  Identity.parseAsn1 = function(der, top) {
    var components = [];
    der.readSequence(top);
    var end = der.offset + der.length;
    while (der.offset < end) {
      der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      var after = der.offset + der.length;
      der.readSequence();
      var oid = der.readOID();
      var type = der.peek();
      var value;
      switch (type) {
        case asn1.Ber.PrintableString:
        case asn1.Ber.IA5String:
        case asn1.Ber.OctetString:
        case asn1.Ber.T61String:
          value = der.readString(type);
          break;
        case asn1.Ber.Utf8String:
          value = der.readString(type, true);
          value = value.toString("utf8");
          break;
        case asn1.Ber.CharacterString:
        case asn1.Ber.BMPString:
          value = der.readString(type, true);
          value = value.toString("utf16le");
          break;
        default:
          throw new Error("Unknown asn1 type " + type);
      }
      components.push({ oid, asn1type: type, value });
      der._offset = after;
    }
    der._offset = end;
    return new Identity({
      components
    });
  };
  Identity.isIdentity = function(obj2, ver) {
    return utils.isCompatible(obj2, Identity, ver);
  };
  Identity.prototype._sshpkApiVersion = [1, 0];
  Identity._oldVersionDetect = function(obj2) {
    return [1, 0];
  };
});

// node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS((exports, module) => {
  module.exports = {
    read,
    verify,
    sign,
    signAsync,
    write,
    fromBuffer,
    toBuffer
  };
  var assert = require_assert();
  var SSHBuffer = require_ssh_buffer();
  var crypto = __require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var rfc4253 = require_rfc4253();
  var Signature = require_signature();
  var utils = require_utils();
  var Certificate = require_certificate();
  function verify(cert, key) {
    return false;
  }
  var TYPES = {
    user: 1,
    host: 2
  };
  Object.keys(TYPES).forEach(function(k) {
    TYPES[TYPES[k]] = k;
  });
  var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
  function read(buf, options) {
    if (Buffer2.isBuffer(buf))
      buf = buf.toString("ascii");
    var parts = buf.trim().split(/[ \t\n]+/g);
    if (parts.length < 2 || parts.length > 3)
      throw new Error("Not a valid SSH certificate line");
    var algo = parts[0];
    var data = parts[1];
    data = Buffer2.from(data, "base64");
    return fromBuffer(data, algo);
  }
  function fromBuffer(data, algo, partial) {
    var sshbuf = new SSHBuffer({ buffer: data });
    var innerAlgo = sshbuf.readString();
    if (algo !== undefined && innerAlgo !== algo)
      throw new Error("SSH certificate algorithm mismatch");
    if (algo === undefined)
      algo = innerAlgo;
    var cert = {};
    cert.signatures = {};
    cert.signatures.openssh = {};
    cert.signatures.openssh.nonce = sshbuf.readBuffer();
    var key = {};
    var parts = key.parts = [];
    key.type = getAlg(algo);
    var partCount = algs.info[key.type].parts.length;
    while (parts.length < partCount)
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    var algInfo = algs.info[key.type];
    if (key.type === "ecdsa") {
      var res = ECDSA_ALGO.exec(algo);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    for (var i = 0;i < algInfo.parts.length; ++i) {
      parts[i].name = algInfo.parts[i];
      if (parts[i].name !== "curve" && algInfo.normalize !== false) {
        var p = parts[i];
        p.data = utils.mpNormalize(p.data);
      }
    }
    cert.subjectKey = new Key(key);
    cert.serial = sshbuf.readInt64();
    var type = TYPES[sshbuf.readInt()];
    assert.string(type, "valid cert type");
    cert.signatures.openssh.keyId = sshbuf.readString();
    var principals = [];
    var pbuf = sshbuf.readBuffer();
    var psshbuf = new SSHBuffer({ buffer: pbuf });
    while (!psshbuf.atEnd())
      principals.push(psshbuf.readString());
    if (principals.length === 0)
      principals = ["*"];
    cert.subjects = principals.map(function(pr) {
      if (type === "user")
        return Identity.forUser(pr);
      else if (type === "host")
        return Identity.forHost(pr);
      throw new Error("Unknown identity type " + type);
    });
    cert.validFrom = int64ToDate(sshbuf.readInt64());
    cert.validUntil = int64ToDate(sshbuf.readInt64());
    var exts = [];
    var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    var ext;
    while (!extbuf.atEnd()) {
      ext = { critical: true };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    while (!extbuf.atEnd()) {
      ext = { critical: false };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    cert.signatures.openssh.exts = exts;
    sshbuf.readBuffer();
    var signingKeyBuf = sshbuf.readBuffer();
    cert.issuerKey = rfc4253.read(signingKeyBuf);
    cert.issuer = Identity.forHost("**");
    var sigBuf = sshbuf.readBuffer();
    cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
    if (partial !== undefined) {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Certificate(cert);
  }
  function int64ToDate(buf) {
    var i = buf.readUInt32BE(0) * 4294967296;
    i += buf.readUInt32BE(4);
    var d = new Date;
    d.setTime(i * 1000);
    d.sourceInt64 = buf;
    return d;
  }
  function dateToInt64(date) {
    if (date.sourceInt64 !== undefined)
      return date.sourceInt64;
    var i = Math.round(date.getTime() / 1000);
    var upper = Math.floor(i / 4294967296);
    var lower = Math.floor(i % 4294967296);
    var buf = Buffer2.alloc(8);
    buf.writeUInt32BE(upper, 0);
    buf.writeUInt32BE(lower, 4);
    return buf;
  }
  function sign(cert, key) {
    if (cert.signatures.openssh === undefined)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      return false;
    }
    var sig = cert.signatures.openssh;
    var hashAlgo = undefined;
    if (key.type === "rsa" || key.type === "dsa")
      hashAlgo = "sha1";
    var signer = key.createSign(hashAlgo);
    signer.write(blob);
    sig.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.openssh === undefined)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      done(e);
      return;
    }
    var sig = cert.signatures.openssh;
    signer(blob, function(err, signature) {
      if (err) {
        done(err);
        return;
      }
      try {
        signature.toBuffer("ssh");
      } catch (e) {
        done(e);
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    if (options === undefined)
      options = {};
    var blob = toBuffer(cert);
    var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
    if (options.comment)
      out = out + " " + options.comment;
    return out;
  }
  function toBuffer(cert, noSig) {
    assert.object(cert.signatures.openssh, "signature for openssh format");
    var sig = cert.signatures.openssh;
    if (sig.nonce === undefined)
      sig.nonce = crypto.randomBytes(16);
    var buf = new SSHBuffer({});
    buf.writeString(getCertType(cert.subjectKey));
    buf.writeBuffer(sig.nonce);
    var key = cert.subjectKey;
    var algInfo = algs.info[key.type];
    algInfo.parts.forEach(function(part) {
      buf.writePart(key.part[part]);
    });
    buf.writeInt64(cert.serial);
    var type = cert.subjects[0].type;
    assert.notStrictEqual(type, "unknown");
    cert.subjects.forEach(function(id) {
      assert.strictEqual(id.type, type);
    });
    type = TYPES[type];
    buf.writeInt(type);
    if (sig.keyId === undefined) {
      sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
    }
    buf.writeString(sig.keyId);
    var sub = new SSHBuffer({});
    cert.subjects.forEach(function(id) {
      if (type === TYPES.host)
        sub.writeString(id.hostname);
      else if (type === TYPES.user)
        sub.writeString(id.uid);
    });
    buf.writeBuffer(sub.toBuffer());
    buf.writeInt64(dateToInt64(cert.validFrom));
    buf.writeInt64(dateToInt64(cert.validUntil));
    var exts = sig.exts;
    if (exts === undefined)
      exts = [];
    var extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical !== true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical === true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    buf.writeBuffer(Buffer2.alloc(0));
    sub = rfc4253.write(cert.issuerKey);
    buf.writeBuffer(sub);
    if (!noSig)
      buf.writeBuffer(sig.signature.toBuffer("ssh"));
    return buf.toBuffer();
  }
  function getAlg(certType) {
    if (certType === "ssh-rsa-cert-v01@openssh.com")
      return "rsa";
    if (certType === "ssh-dss-cert-v01@openssh.com")
      return "dsa";
    if (certType.match(ECDSA_ALGO))
      return "ecdsa";
    if (certType === "ssh-ed25519-cert-v01@openssh.com")
      return "ed25519";
    throw new Error("Unsupported cert type " + certType);
  }
  function getCertType(key) {
    if (key.type === "rsa")
      return "ssh-rsa-cert-v01@openssh.com";
    if (key.type === "dsa")
      return "ssh-dss-cert-v01@openssh.com";
    if (key.type === "ecdsa")
      return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
    if (key.type === "ed25519")
      return "ssh-ed25519-cert-v01@openssh.com";
    throw new Error("Unsupported key type " + key.type);
  }
});

// node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS((exports, module) => {
  module.exports = {
    read,
    verify,
    sign,
    signAsync,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  var pkcs8 = require_pkcs8();
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function verify(cert, key) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var algParts = sig.algo.split("-");
    if (algParts[0] !== key.type)
      return false;
    var blob = sig.cache;
    if (blob === undefined) {
      var der = new asn1.BerWriter;
      writeTBSCert(cert, der);
      blob = der.buffer;
    }
    var verifier = key.createVerify(algParts[1]);
    verifier.write(blob);
    return verifier.verify(sig.signature);
  }
  function Local(i) {
    return asn1.Ber.Context | asn1.Ber.Constructor | i;
  }
  function Context(i) {
    return asn1.Ber.Context | i;
  }
  var SIGN_ALGS = {
    "rsa-md5": "1.2.840.113549.1.1.4",
    "rsa-sha1": "1.2.840.113549.1.1.5",
    "rsa-sha256": "1.2.840.113549.1.1.11",
    "rsa-sha384": "1.2.840.113549.1.1.12",
    "rsa-sha512": "1.2.840.113549.1.1.13",
    "dsa-sha1": "1.2.840.10040.4.3",
    "dsa-sha256": "2.16.840.1.101.3.4.3.2",
    "ecdsa-sha1": "1.2.840.10045.4.1",
    "ecdsa-sha256": "1.2.840.10045.4.3.2",
    "ecdsa-sha384": "1.2.840.10045.4.3.3",
    "ecdsa-sha512": "1.2.840.10045.4.3.4",
    "ed25519-sha512": "1.3.101.112"
  };
  Object.keys(SIGN_ALGS).forEach(function(k) {
    SIGN_ALGS[SIGN_ALGS[k]] = k;
  });
  SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
  SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
  var EXTS = {
    issuerKeyId: "2.5.29.35",
    altName: "2.5.29.17",
    basicConstraints: "2.5.29.19",
    keyUsage: "2.5.29.15",
    extKeyUsage: "2.5.29.37"
  };
  function read(buf, options) {
    if (typeof buf === "string") {
      buf = Buffer2.from(buf, "binary");
    }
    assert.buffer(buf, "buf");
    var der = new asn1.BerReader(buf);
    der.readSequence();
    if (Math.abs(der.length - der.remain) > 1) {
      throw new Error("DER sequence does not contain whole byte " + "stream");
    }
    var tbsStart = der.offset;
    der.readSequence();
    var sigOffset = der.offset + der.length;
    var tbsEnd = sigOffset;
    if (der.peek() === Local(0)) {
      der.readSequence(Local(0));
      var version = der.readInt();
      assert.ok(version <= 3, "only x.509 versions up to v3 supported");
    }
    var cert = {};
    cert.signatures = {};
    var sig = cert.signatures.x509 = {};
    sig.extras = {};
    cert.serial = readMPInt(der, "serial");
    der.readSequence();
    var after = der.offset + der.length;
    var certAlgOid = der.readOID();
    var certAlg = SIGN_ALGS[certAlgOid];
    if (certAlg === undefined)
      throw new Error("unknown signature algorithm " + certAlgOid);
    der._offset = after;
    cert.issuer = Identity.parseAsn1(der);
    der.readSequence();
    cert.validFrom = readDate(der);
    cert.validUntil = readDate(der);
    cert.subjects = [Identity.parseAsn1(der)];
    der.readSequence();
    after = der.offset + der.length;
    cert.subjectKey = pkcs8.readPkcs8(undefined, "public", der);
    der._offset = after;
    if (der.peek() === Local(1)) {
      der.readSequence(Local(1));
      sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(2)) {
      der.readSequence(Local(2));
      sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(3)) {
      der.readSequence(Local(3));
      var extEnd = der.offset + der.length;
      der.readSequence();
      while (der.offset < extEnd)
        readExtension(cert, buf, der);
      assert.strictEqual(der.offset, extEnd);
    }
    assert.strictEqual(der.offset, sigOffset);
    der.readSequence();
    after = der.offset + der.length;
    var sigAlgOid = der.readOID();
    var sigAlg = SIGN_ALGS[sigAlgOid];
    if (sigAlg === undefined)
      throw new Error("unknown signature algorithm " + sigAlgOid);
    der._offset = after;
    var sigData = der.readString(asn1.Ber.BitString, true);
    if (sigData[0] === 0)
      sigData = sigData.slice(1);
    var algParts = sigAlg.split("-");
    sig.signature = Signature.parse(sigData, algParts[0], "asn1");
    sig.signature.hashAlgorithm = algParts[1];
    sig.algo = sigAlg;
    sig.cache = buf.slice(tbsStart, tbsEnd);
    return new Certificate(cert);
  }
  function readDate(der) {
    if (der.peek() === asn1.Ber.UTCTime) {
      return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
    } else if (der.peek() === asn1.Ber.GeneralizedTime) {
      return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
    } else {
      throw new Error("Unsupported date format");
    }
  }
  function writeDate(der, date) {
    if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
      der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
    } else {
      der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
    }
  }
  var ALTNAME = {
    OtherName: Local(0),
    RFC822Name: Context(1),
    DNSName: Context(2),
    X400Address: Local(3),
    DirectoryName: Local(4),
    EDIPartyName: Local(5),
    URI: Context(6),
    IPAddress: Context(7),
    OID: Context(8)
  };
  var EXTPURPOSE = {
    serverAuth: "1.3.6.1.5.5.7.3.1",
    clientAuth: "1.3.6.1.5.5.7.3.2",
    codeSigning: "1.3.6.1.5.5.7.3.3",
    joyentDocker: "1.3.6.1.4.1.38678.1.4.1",
    joyentCmon: "1.3.6.1.4.1.38678.1.4.2"
  };
  var EXTPURPOSE_REV = {};
  Object.keys(EXTPURPOSE).forEach(function(k) {
    EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
  });
  var KEYUSEBITS = [
    "signature",
    "identity",
    "keyEncryption",
    "encryption",
    "keyAgreement",
    "ca",
    "crl"
  ];
  function readExtension(cert, buf, der) {
    der.readSequence();
    var after = der.offset + der.length;
    var extId = der.readOID();
    var id;
    var sig = cert.signatures.x509;
    if (!sig.extras.exts)
      sig.extras.exts = [];
    var critical;
    if (der.peek() === asn1.Ber.Boolean)
      critical = der.readBoolean();
    switch (extId) {
      case EXTS.basicConstraints:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var bcEnd = der.offset + der.length;
        var ca = false;
        if (der.peek() === asn1.Ber.Boolean)
          ca = der.readBoolean();
        if (cert.purposes === undefined)
          cert.purposes = [];
        if (ca === true)
          cert.purposes.push("ca");
        var bc = { oid: extId, critical };
        if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
          bc.pathLen = der.readInt();
        sig.extras.exts.push(bc);
        break;
      case EXTS.extKeyUsage:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        if (cert.purposes === undefined)
          cert.purposes = [];
        var ekEnd = der.offset + der.length;
        while (der.offset < ekEnd) {
          var oid = der.readOID();
          cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
        }
        if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "host") {
              ide.type = "host";
              ide.hostname = ide.uid || ide.email || ide.components[0].value;
            }
          });
        } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "user") {
              ide.type = "user";
              ide.uid = ide.hostname || ide.email || ide.components[0].value;
            }
          });
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      case EXTS.keyUsage:
        der.readSequence(asn1.Ber.OctetString);
        var bits = der.readString(asn1.Ber.BitString, true);
        var setBits = readBitField(bits, KEYUSEBITS);
        setBits.forEach(function(bit) {
          if (cert.purposes === undefined)
            cert.purposes = [];
          if (cert.purposes.indexOf(bit) === -1)
            cert.purposes.push(bit);
        });
        sig.extras.exts.push({
          oid: extId,
          critical,
          bits
        });
        break;
      case EXTS.altName:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var aeEnd = der.offset + der.length;
        while (der.offset < aeEnd) {
          switch (der.peek()) {
            case ALTNAME.OtherName:
            case ALTNAME.EDIPartyName:
              der.readSequence();
              der._offset += der.length;
              break;
            case ALTNAME.OID:
              der.readOID(ALTNAME.OID);
              break;
            case ALTNAME.RFC822Name:
              var email = der.readString(ALTNAME.RFC822Name);
              id = Identity.forEmail(email);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DirectoryName:
              der.readSequence(ALTNAME.DirectoryName);
              id = Identity.parseAsn1(der);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DNSName:
              var host = der.readString(ALTNAME.DNSName);
              id = Identity.forHost(host);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            default:
              der.readString(der.peek());
              break;
          }
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      default:
        sig.extras.exts.push({
          oid: extId,
          critical,
          data: der.readString(asn1.Ber.OctetString, true)
        });
        break;
    }
    der._offset = after;
  }
  var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function utcTimeToDate(t) {
    var m = t.match(UTCTIME_RE);
    assert.ok(m, "timestamps must be in UTC");
    var d = new Date;
    var thisYear = d.getUTCFullYear();
    var century = Math.floor(thisYear / 100) * 100;
    var year = parseInt(m[1], 10);
    if (thisYear % 100 < 50 && year >= 60)
      year += century - 1;
    else
      year += century;
    d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function gTimeToDate(t) {
    var m = t.match(GTIME_RE);
    assert.ok(m);
    var d = new Date;
    d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  function zeroPad(n, m) {
    if (m === undefined)
      m = 2;
    var s = "" + n;
    while (s.length < m)
      s = "0" + s;
    return s;
  }
  function dateToUTCTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear() % 100);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function dateToGTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear(), 4);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function sign(cert, key) {
    if (cert.signatures.x509 === undefined)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    sig.algo = key.type + "-" + key.defaultHashAlgorithm();
    if (SIGN_ALGS[sig.algo] === undefined)
      return false;
    var der = new asn1.BerWriter;
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    var signer = key.createSign();
    signer.write(blob);
    cert.signatures.x509.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.x509 === undefined)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    var der = new asn1.BerWriter;
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    signer(blob, function(err, signature) {
      if (err) {
        done(err);
        return;
      }
      sig.algo = signature.type + "-" + signature.hashAlgorithm;
      if (SIGN_ALGS[sig.algo] === undefined) {
        done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var der = new asn1.BerWriter;
    der.startSequence();
    if (sig.cache) {
      der._ensure(sig.cache.length);
      sig.cache.copy(der._buf, der._offset);
      der._offset += sig.cache.length;
    } else {
      writeTBSCert(cert, der);
    }
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    var sigData = sig.signature.toBuffer("asn1");
    var data = Buffer2.alloc(sigData.length + 1);
    data[0] = 0;
    sigData.copy(data, 1);
    der.writeBuffer(data, asn1.Ber.BitString);
    der.endSequence();
    return der.buffer;
  }
  function writeTBSCert(cert, der) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    der.startSequence();
    der.startSequence(Local(0));
    der.writeInt(2);
    der.endSequence();
    der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    cert.issuer.toAsn1(der);
    der.startSequence();
    writeDate(der, cert.validFrom);
    writeDate(der, cert.validUntil);
    der.endSequence();
    var subject = cert.subjects[0];
    var altNames = cert.subjects.slice(1);
    subject.toAsn1(der);
    pkcs8.writePkcs8(der, cert.subjectKey);
    if (sig.extras && sig.extras.issuerUniqueID) {
      der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
    }
    if (sig.extras && sig.extras.subjectUniqueID) {
      der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
    }
    if (altNames.length > 0 || subject.type === "host" || cert.purposes !== undefined && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
      der.startSequence(Local(3));
      der.startSequence();
      var exts = [];
      if (cert.purposes !== undefined && cert.purposes.length > 0) {
        exts.push({
          oid: EXTS.basicConstraints,
          critical: true
        });
        exts.push({
          oid: EXTS.keyUsage,
          critical: true
        });
        exts.push({
          oid: EXTS.extKeyUsage,
          critical: true
        });
      }
      exts.push({ oid: EXTS.altName });
      if (sig.extras && sig.extras.exts)
        exts = sig.extras.exts;
      for (var i = 0;i < exts.length; ++i) {
        der.startSequence();
        der.writeOID(exts[i].oid);
        if (exts[i].critical !== undefined)
          der.writeBoolean(exts[i].critical);
        if (exts[i].oid === EXTS.altName) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          if (subject.type === "host") {
            der.writeString(subject.hostname, Context(2));
          }
          for (var j = 0;j < altNames.length; ++j) {
            if (altNames[j].type === "host") {
              der.writeString(altNames[j].hostname, ALTNAME.DNSName);
            } else if (altNames[j].type === "email") {
              der.writeString(altNames[j].email, ALTNAME.RFC822Name);
            } else {
              der.startSequence(ALTNAME.DirectoryName);
              altNames[j].toAsn1(der);
              der.endSequence();
            }
          }
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.basicConstraints) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          var ca = cert.purposes.indexOf("ca") !== -1;
          var pathLen = exts[i].pathLen;
          der.writeBoolean(ca);
          if (pathLen !== undefined)
            der.writeInt(pathLen);
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.extKeyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          cert.purposes.forEach(function(purpose) {
            if (purpose === "ca")
              return;
            if (KEYUSEBITS.indexOf(purpose) !== -1)
              return;
            var oid = purpose;
            if (EXTPURPOSE[purpose] !== undefined)
              oid = EXTPURPOSE[purpose];
            der.writeOID(oid);
          });
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.keyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          if (exts[i].bits !== undefined) {
            der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
          } else {
            var bits = writeBitField(cert.purposes, KEYUSEBITS);
            der.writeBuffer(bits, asn1.Ber.BitString);
          }
          der.endSequence();
        } else {
          der.writeBuffer(exts[i].data, asn1.Ber.OctetString);
        }
        der.endSequence();
      }
      der.endSequence();
      der.endSequence();
    }
    der.endSequence();
  }
  function readBitField(bits, bitIndex) {
    var bitLen = 8 * (bits.length - 1) - bits[0];
    var setBits = {};
    for (var i = 0;i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var bitVal = (bits[byteN] & mask) !== 0;
      var name = bitIndex[i];
      if (bitVal && typeof name === "string") {
        setBits[name] = true;
      }
    }
    return Object.keys(setBits);
  }
  function writeBitField(setBits, bitIndex) {
    var bitLen = bitIndex.length;
    var blen = Math.ceil(bitLen / 8);
    var unused = blen * 8 - bitLen;
    var bits = Buffer2.alloc(1 + blen);
    bits[0] = unused;
    for (var i = 0;i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var name = bitIndex[i];
      if (name === undefined)
        continue;
      var bitVal = setBits.indexOf(name) !== -1;
      if (bitVal) {
        bits[byteN] |= mask;
      }
    }
    return bits;
  }
});

// node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS((exports, module) => {
  var x509 = require_x509();
  module.exports = {
    read,
    verify: x509.verify,
    sign: x509.sign,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m2, "invalid PEM footer");
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    return x509.read(buf, options);
  }
  function write(cert, options) {
    var dbuf = x509.write(cert, options);
    var header = "CERTIFICATE";
    var tmp = dbuf.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + `-----
`, o);
    for (var i = 0;i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + `-----
`, o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS((exports, module) => {
  module.exports = Certificate;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = __require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = __require("util");
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var formats = {};
  formats["openssh"] = require_openssh_cert();
  formats["x509"] = require_x509();
  formats["pem"] = require_x509_pem();
  var CertificateParseError = errs.CertificateParseError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Certificate(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.subjects, "options.subjects");
    utils.assertCompatible(opts.subjects[0], Identity, [1, 0], "options.subjects");
    utils.assertCompatible(opts.subjectKey, Key, [1, 0], "options.subjectKey");
    utils.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
    if (opts.issuerKey !== undefined) {
      utils.assertCompatible(opts.issuerKey, Key, [1, 0], "options.issuerKey");
    }
    assert.object(opts.signatures, "options.signatures");
    assert.buffer(opts.serial, "options.serial");
    assert.date(opts.validFrom, "options.validFrom");
    assert.date(opts.validUntil, "optons.validUntil");
    assert.optionalArrayOfString(opts.purposes, "options.purposes");
    this._hashCache = {};
    this.subjects = opts.subjects;
    this.issuer = opts.issuer;
    this.subjectKey = opts.subjectKey;
    this.issuerKey = opts.issuerKey;
    this.signatures = opts.signatures;
    this.serial = opts.serial;
    this.validFrom = opts.validFrom;
    this.validUntil = opts.validUntil;
    this.purposes = opts.purposes;
  }
  Certificate.formats = formats;
  Certificate.prototype.toBuffer = function(format, options) {
    if (format === undefined)
      format = "x509";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    return formats[format].write(this, options);
  };
  Certificate.prototype.toString = function(format, options) {
    if (format === undefined)
      format = "pem";
    return this.toBuffer(format, options).toString();
  };
  Certificate.prototype.fingerprint = function(algo) {
    if (algo === undefined)
      algo = "sha256";
    assert.string(algo, "algorithm");
    var opts = {
      type: "certificate",
      hash: this.hash(algo),
      algorithm: algo
    };
    return new Fingerprint(opts);
  };
  Certificate.prototype.hash = function(algo) {
    assert.string(algo, "algorithm");
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === undefined)
      throw new InvalidAlgorithmError(algo);
    if (this._hashCache[algo])
      return this._hashCache[algo];
    var hash = crypto.createHash(algo).update(this.toBuffer("x509")).digest();
    this._hashCache[algo] = hash;
    return hash;
  };
  Certificate.prototype.isExpired = function(when) {
    if (when === undefined)
      when = new Date;
    return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
  };
  Certificate.prototype.isSignedBy = function(issuerCert) {
    utils.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
    if (!this.issuer.equals(issuerCert.subjects[0]))
      return false;
    if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
      return false;
    }
    return this.isSignedByKey(issuerCert.subjectKey);
  };
  Certificate.prototype.getExtension = function(keyOrOid) {
    assert.string(keyOrOid, "keyOrOid");
    var ext = this.getExtensions().filter(function(maybeExt) {
      if (maybeExt.format === "x509")
        return maybeExt.oid === keyOrOid;
      if (maybeExt.format === "openssh")
        return maybeExt.name === keyOrOid;
      return false;
    })[0];
    return ext;
  };
  Certificate.prototype.getExtensions = function() {
    var exts = [];
    var x509 = this.signatures.x509;
    if (x509 && x509.extras && x509.extras.exts) {
      x509.extras.exts.forEach(function(ext) {
        ext.format = "x509";
        exts.push(ext);
      });
    }
    var openssh = this.signatures.openssh;
    if (openssh && openssh.exts) {
      openssh.exts.forEach(function(ext) {
        ext.format = "openssh";
        exts.push(ext);
      });
    }
    return exts;
  };
  Certificate.prototype.isSignedByKey = function(issuerKey) {
    utils.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
    if (this.issuerKey !== undefined) {
      return this.issuerKey.fingerprint("sha512").matches(issuerKey);
    }
    var fmt = Object.keys(this.signatures)[0];
    var valid = formats[fmt].verify(this, issuerKey);
    if (valid)
      this.issuerKey = issuerKey;
    return valid;
  };
  Certificate.prototype.signWith = function(key) {
    utils.assertCompatible(key, PrivateKey, [1, 2], "key");
    var fmts = Object.keys(formats);
    var didOne = false;
    for (var i = 0;i < fmts.length; ++i) {
      if (fmts[i] !== "pem") {
        var ret = formats[fmts[i]].sign(this, key);
        if (ret === true)
          didOne = true;
      }
    }
    if (!didOne) {
      throw new Error("Failed to sign the certificate for any " + "available certificate formats");
    }
  };
  Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils.assertCompatible(key, PrivateKey, [1, 2], "private key");
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === undefined)
      validFrom = new Date;
    if (validUntil === undefined) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === undefined)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date;
      validUntil.setTime(validUntil.getTime() + lifetime * 1000);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === undefined)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === undefined)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (purposes.indexOf("ca") === -1)
      purposes.push("ca");
    if (purposes.indexOf("crl") === -1)
      purposes.push("crl");
    if (purposes.length <= 3) {
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
    }
    var cert = new Certificate({
      subjects,
      issuer: subjects[0],
      subjectKey: key.toPublic(),
      issuerKey: key.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(key);
    return cert;
  };
  Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils.assertCompatible(key, Key, [1, 0], "key");
    if (PrivateKey.isPrivateKey(key))
      key = key.toPublic();
    utils.assertCompatible(issuer, Identity, [1, 0], "issuer");
    utils.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === undefined)
      validFrom = new Date;
    if (validUntil === undefined) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === undefined)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date;
      validUntil.setTime(validUntil.getTime() + lifetime * 1000);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === undefined)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === undefined)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (options.ca === true) {
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
    }
    var hostSubjects = subjects.filter(function(subject) {
      return subject.type === "host";
    });
    var userSubjects = subjects.filter(function(subject) {
      return subject.type === "user";
    });
    if (hostSubjects.length > 0) {
      if (purposes.indexOf("serverAuth") === -1)
        purposes.push("serverAuth");
    }
    if (userSubjects.length > 0) {
      if (purposes.indexOf("clientAuth") === -1)
        purposes.push("clientAuth");
    }
    if (userSubjects.length > 0 || hostSubjects.length > 0) {
      if (purposes.indexOf("keyAgreement") === -1)
        purposes.push("keyAgreement");
      if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
        purposes.push("encryption");
    }
    var cert = new Certificate({
      subjects,
      issuer,
      subjectKey: key,
      issuerKey: issuerKey.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(issuerKey);
    return cert;
  };
  Certificate.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === undefined)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === undefined)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      return k;
    } catch (e) {
      throw new CertificateParseError(options.filename, format, e);
    }
  };
  Certificate.isCertificate = function(obj2, ver) {
    return utils.isCompatible(obj2, Certificate, ver);
  };
  Certificate.prototype._sshpkApiVersion = [1, 1];
  Certificate._oldVersionDetect = function(obj2) {
    return [1, 0];
  };
});

// node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS((exports, module) => {
  module.exports = Fingerprint;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = __require("crypto");
  var errs = require_errors();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var utils = require_utils();
  var FingerprintFormatError = errs.FingerprintFormatError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Fingerprint(opts) {
    assert.object(opts, "options");
    assert.string(opts.type, "options.type");
    assert.buffer(opts.hash, "options.hash");
    assert.string(opts.algorithm, "options.algorithm");
    this.algorithm = opts.algorithm.toLowerCase();
    if (algs.hashAlgs[this.algorithm] !== true)
      throw new InvalidAlgorithmError(this.algorithm);
    this.hash = opts.hash;
    this.type = opts.type;
    this.hashType = opts.hashType;
  }
  Fingerprint.prototype.toString = function(format) {
    if (format === undefined) {
      if (this.algorithm === "md5" || this.hashType === "spki")
        format = "hex";
      else
        format = "base64";
    }
    assert.string(format);
    switch (format) {
      case "hex":
        if (this.hashType === "spki")
          return this.hash.toString("hex");
        return addColons(this.hash.toString("hex"));
      case "base64":
        if (this.hashType === "spki")
          return this.hash.toString("base64");
        return sshBase64Format(this.algorithm, this.hash.toString("base64"));
      default:
        throw new FingerprintFormatError(undefined, format);
    }
  };
  Fingerprint.prototype.matches = function(other) {
    assert.object(other, "key or certificate");
    if (this.type === "key" && this.hashType !== "ssh") {
      utils.assertCompatible(other, Key, [1, 7], "key with spki");
      if (PrivateKey.isPrivateKey(other)) {
        utils.assertCompatible(other, PrivateKey, [1, 6], "privatekey with spki support");
      }
    } else if (this.type === "key") {
      utils.assertCompatible(other, Key, [1, 0], "key");
    } else {
      utils.assertCompatible(other, Certificate, [1, 0], "certificate");
    }
    var theirHash = other.hash(this.algorithm, this.hashType);
    var theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest("base64");
    if (this.hash2 === undefined)
      this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest("base64");
    return this.hash2 === theirHash2;
  };
  var base64RE = /^[A-Za-z0-9+\/=]+$/;
  var hexRE = /^[a-fA-F0-9]+$/;
  Fingerprint.parse = function(fp, options) {
    assert.string(fp, "fingerprint");
    var alg, hash, enAlgs;
    if (Array.isArray(options)) {
      enAlgs = options;
      options = {};
    }
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    if (options.enAlgs !== undefined)
      enAlgs = options.enAlgs;
    if (options.algorithms !== undefined)
      enAlgs = options.algorithms;
    assert.optionalArrayOfString(enAlgs, "algorithms");
    var hashType = "ssh";
    if (options.hashType !== undefined)
      hashType = options.hashType;
    assert.string(hashType, "options.hashType");
    var parts = fp.split(":");
    if (parts.length == 2) {
      alg = parts[0].toLowerCase();
      if (!base64RE.test(parts[1]))
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts[1], "base64");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else if (parts.length > 2) {
      alg = "md5";
      if (parts[0].toLowerCase() === "md5")
        parts = parts.slice(1);
      parts = parts.map(function(p) {
        while (p.length < 2)
          p = "0" + p;
        if (p.length > 2)
          throw new FingerprintFormatError(fp);
        return p;
      });
      parts = parts.join("");
      if (!hexRE.test(parts) || parts.length % 2 !== 0)
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts, "hex");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else {
      if (hexRE.test(fp)) {
        hash = Buffer2.from(fp, "hex");
      } else if (base64RE.test(fp)) {
        hash = Buffer2.from(fp, "base64");
      } else {
        throw new FingerprintFormatError(fp);
      }
      switch (hash.length) {
        case 32:
          alg = "sha256";
          break;
        case 16:
          alg = "md5";
          break;
        case 20:
          alg = "sha1";
          break;
        case 64:
          alg = "sha512";
          break;
        default:
          throw new FingerprintFormatError(fp);
      }
      if (options.hashType === undefined)
        hashType = "spki";
    }
    if (alg === undefined)
      throw new FingerprintFormatError(fp);
    if (algs.hashAlgs[alg] === undefined)
      throw new InvalidAlgorithmError(alg);
    if (enAlgs !== undefined) {
      enAlgs = enAlgs.map(function(a) {
        return a.toLowerCase();
      });
      if (enAlgs.indexOf(alg) === -1)
        throw new InvalidAlgorithmError(alg);
    }
    return new Fingerprint({
      algorithm: alg,
      hash,
      type: options.type || "key",
      hashType
    });
  };
  function addColons(s) {
    return s.replace(/(.{2})(?=.)/g, "$1:");
  }
  function base64Strip(s) {
    return s.replace(/=*$/, "");
  }
  function sshBase64Format(alg, h) {
    return alg.toUpperCase() + ":" + base64Strip(h);
  }
  Fingerprint.isFingerprint = function(obj2, ver) {
    return utils.isCompatible(obj2, Fingerprint, ver);
  };
  Fingerprint.prototype._sshpkApiVersion = [1, 2];
  Fingerprint._oldVersionDetect = function(obj2) {
    assert.func(obj2.toString);
    assert.func(obj2.matches);
    return [1, 0];
  };
});

// node_modules/sshpk/lib/key.js
var require_key = __commonJS((exports, module) => {
  module.exports = Key;
  var assert = require_assert();
  var algs = require_algs();
  var crypto = __require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var DiffieHellman = require_dhe().DiffieHellman;
  var errs = require_errors();
  var utils = require_utils();
  var PrivateKey = require_private_key();
  var edCompat;
  try {
    edCompat = require_ed_compat();
  } catch (e) {}
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var formats = {};
  formats["auto"] = require_auto();
  formats["pem"] = require_pem();
  formats["pkcs1"] = require_pkcs1();
  formats["pkcs8"] = require_pkcs8();
  formats["rfc4253"] = require_rfc4253();
  formats["ssh"] = require_ssh();
  formats["ssh-private"] = require_ssh_private();
  formats["openssh"] = formats["ssh-private"];
  formats["dnssec"] = require_dnssec();
  formats["putty"] = require_putty();
  formats["ppk"] = formats["putty"];
  function Key(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    assert.optionalString(opts.comment, "options.comment");
    var algInfo = algs.info[opts.type];
    if (typeof algInfo !== "object")
      throw new InvalidAlgorithmError(opts.type);
    var partLookup = {};
    for (var i = 0;i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.parts = opts.parts;
    this.part = partLookup;
    this.comment = undefined;
    this.source = opts.source;
    this._rfc4253Cache = opts._rfc4253Cache;
    this._hashCache = {};
    var sz;
    this.curve = undefined;
    if (this.type === "ecdsa") {
      var curve = this.part.curve.data.toString();
      this.curve = curve;
      sz = algs.curves[curve].size;
    } else if (this.type === "ed25519" || this.type === "curve25519") {
      sz = 256;
      this.curve = "curve25519";
    } else {
      var szPart = this.part[algInfo.sizePart];
      sz = szPart.data.length;
      sz = sz * 8 - utils.countZeros(szPart.data);
    }
    this.size = sz;
  }
  Key.formats = formats;
  Key.prototype.toBuffer = function(format, options) {
    if (format === undefined)
      format = "ssh";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    if (format === "rfc4253") {
      if (this._rfc4253Cache === undefined)
        this._rfc4253Cache = formats["rfc4253"].write(this);
      return this._rfc4253Cache;
    }
    return formats[format].write(this, options);
  };
  Key.prototype.toString = function(format, options) {
    return this.toBuffer(format, options).toString();
  };
  Key.prototype.hash = function(algo, type) {
    assert.string(algo, "algorithm");
    assert.optionalString(type, "type");
    if (type === undefined)
      type = "ssh";
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === undefined)
      throw new InvalidAlgorithmError(algo);
    var cacheKey = algo + "||" + type;
    if (this._hashCache[cacheKey])
      return this._hashCache[cacheKey];
    var buf;
    if (type === "ssh") {
      buf = this.toBuffer("rfc4253");
    } else if (type === "spki") {
      buf = formats.pkcs8.pkcs8ToBuffer(this);
    } else {
      throw new Error("Hash type " + type + " not supported");
    }
    var hash = crypto.createHash(algo).update(buf).digest();
    this._hashCache[cacheKey] = hash;
    return hash;
  };
  Key.prototype.fingerprint = function(algo, type) {
    if (algo === undefined)
      algo = "sha256";
    if (type === undefined)
      type = "ssh";
    assert.string(algo, "algorithm");
    assert.string(type, "type");
    var opts = {
      type: "key",
      hash: this.hash(algo, type),
      algorithm: algo,
      hashType: type
    };
    return new Fingerprint(opts);
  };
  Key.prototype.defaultHashAlgorithm = function() {
    var hashAlgo = "sha1";
    if (this.type === "rsa")
      hashAlgo = "sha256";
    if (this.type === "dsa" && this.size > 1024)
      hashAlgo = "sha256";
    if (this.type === "ed25519")
      hashAlgo = "sha512";
    if (this.type === "ecdsa") {
      if (this.size <= 256)
        hashAlgo = "sha256";
      else if (this.size <= 384)
        hashAlgo = "sha384";
      else
        hashAlgo = "sha512";
    }
    return hashAlgo;
  };
  Key.prototype.createVerify = function(hashAlgo) {
    if (hashAlgo === undefined)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat !== undefined)
      return new edCompat.Verifier(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for " + "signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    } catch (e) {
      err = e;
    }
    if (v === undefined || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldVerify = v.verify.bind(v);
    var key = this.toBuffer("pkcs8");
    var curve = this.curve;
    var self2 = this;
    v.verify = function(signature, fmt) {
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== self2.type)
          return false;
        if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
          return false;
        if (signature.curve && self2.type === "ecdsa" && signature.curve !== curve)
          return false;
        return oldVerify(key, signature.toBuffer("asn1"));
      } else if (typeof signature === "string" || Buffer.isBuffer(signature)) {
        return oldVerify(key, signature, fmt);
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error("signature was created by too old " + "a version of sshpk and cannot be verified");
      } else {
        throw new TypeError("signature must be a string, " + "Buffer, or Signature object");
      }
    };
    return v;
  };
  Key.prototype.createDiffieHellman = function() {
    if (this.type === "rsa")
      throw new Error("RSA keys do not support Diffie-Hellman");
    return new DiffieHellman(this);
  };
  Key.prototype.createDH = Key.prototype.createDiffieHellman;
  Key.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === undefined)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === undefined)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      if (k instanceof PrivateKey)
        k = k.toPublic();
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  Key.isKey = function(obj2, ver) {
    return utils.isCompatible(obj2, Key, ver);
  };
  Key.prototype._sshpkApiVersion = [1, 7];
  Key._oldVersionDetect = function(obj2) {
    assert.func(obj2.toBuffer);
    assert.func(obj2.fingerprint);
    if (obj2.createDH)
      return [1, 4];
    if (obj2.defaultHashAlgorithm)
      return [1, 3];
    if (obj2.formats["auto"])
      return [1, 2];
    if (obj2.formats["pkcs1"])
      return [1, 1];
    return [1, 0];
  };
});

// node_modules/sshpk/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Key = require_key();
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var Identity = require_identity();
  var errs = require_errors();
  module.exports = {
    Key,
    parseKey: Key.parse,
    Fingerprint,
    parseFingerprint: Fingerprint.parse,
    Signature,
    parseSignature: Signature.parse,
    PrivateKey,
    parsePrivateKey: PrivateKey.parse,
    generatePrivateKey: PrivateKey.generate,
    Certificate,
    parseCertificate: Certificate.parse,
    createSelfSignedCertificate: Certificate.createSelfSigned,
    createCertificate: Certificate.create,
    Identity,
    identityFromDN: Identity.parseDN,
    identityForHost: Identity.forHost,
    identityForUser: Identity.forUser,
    identityForEmail: Identity.forEmail,
    identityFromArray: Identity.fromArray,
    FingerprintFormatError: errs.FingerprintFormatError,
    InvalidAlgorithmError: errs.InvalidAlgorithmError,
    KeyParseError: errs.KeyParseError,
    SignatureParseError: errs.SignatureParseError,
    KeyEncryptedError: errs.KeyEncryptedError,
    CertificateParseError: errs.CertificateParseError
  };
});

// node_modules/http-signature/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var assert = require_assert();
  var sshpk = require_lib2();
  var util = __require("util");
  var HASH_ALGOS = {
    sha1: true,
    sha256: true,
    sha512: true
  };
  var PK_ALGOS = {
    rsa: true,
    dsa: true,
    ecdsa: true
  };
  function HttpSignatureError(message, caller) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, caller || HttpSignatureError);
    this.message = message;
    this.name = caller.name;
  }
  util.inherits(HttpSignatureError, Error);
  function InvalidAlgorithmError(message) {
    HttpSignatureError.call(this, message, InvalidAlgorithmError);
  }
  util.inherits(InvalidAlgorithmError, HttpSignatureError);
  function validateAlgorithm(algorithm) {
    var alg = algorithm.toLowerCase().split("-");
    if (alg.length !== 2) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a " + "valid algorithm");
    }
    if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys " + "are not supported");
    }
    if (!HASH_ALGOS[alg[1]]) {
      throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a " + "supported hash algorithm");
    }
    return alg;
  }
  module.exports = {
    HASH_ALGOS,
    PK_ALGOS,
    HttpSignatureError,
    InvalidAlgorithmError,
    validateAlgorithm,
    sshKeyToPEM: function sshKeyToPEM(key) {
      assert.string(key, "ssh_key");
      var k = sshpk.parseKey(key, "ssh");
      return k.toString("pem");
    },
    fingerprint: function fingerprint(key) {
      assert.string(key, "ssh_key");
      var k = sshpk.parseKey(key, "ssh");
      return k.fingerprint("md5").toString("hex");
    },
    pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
      assert.equal("string", typeof pem, "typeof pem");
      var k = sshpk.parseKey(pem, "pem");
      k.comment = comment;
      return k.toString("ssh");
    }
  };
});

// node_modules/http-signature/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var assert = require_assert();
  var util = __require("util");
  var utils = require_utils2();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var HttpSignatureError = utils.HttpSignatureError;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var validateAlgorithm = utils.validateAlgorithm;
  var State = {
    New: 0,
    Params: 1
  };
  var ParamsState = {
    Name: 0,
    Quote: 1,
    Value: 2,
    Comma: 3
  };
  function ExpiredRequestError(message) {
    HttpSignatureError.call(this, message, ExpiredRequestError);
  }
  util.inherits(ExpiredRequestError, HttpSignatureError);
  function InvalidHeaderError(message) {
    HttpSignatureError.call(this, message, InvalidHeaderError);
  }
  util.inherits(InvalidHeaderError, HttpSignatureError);
  function InvalidParamsError(message) {
    HttpSignatureError.call(this, message, InvalidParamsError);
  }
  util.inherits(InvalidParamsError, HttpSignatureError);
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util.inherits(StrictParsingError, HttpSignatureError);
  module.exports = {
    parseRequest: function parseRequest(request, options) {
      assert.object(request, "request");
      assert.object(request.headers, "request.headers");
      if (options === undefined) {
        options = {};
      }
      if (options.headers === undefined) {
        options.headers = [request.headers["x-date"] ? "x-date" : "date"];
      }
      assert.object(options, "options");
      assert.arrayOfString(options.headers, "options.headers");
      assert.optionalFinite(options.clockSkew, "options.clockSkew");
      var authzHeaderName = options.authorizationHeaderName || "authorization";
      if (!request.headers[authzHeaderName]) {
        throw new MissingHeaderError("no " + authzHeaderName + " header " + "present in the request");
      }
      options.clockSkew = options.clockSkew || 300;
      var i = 0;
      var state = State.New;
      var substate = ParamsState.Name;
      var tmpName = "";
      var tmpValue = "";
      var parsed = {
        scheme: "",
        params: {},
        signingString: ""
      };
      var authz = request.headers[authzHeaderName];
      for (i = 0;i < authz.length; i++) {
        var c = authz.charAt(i);
        switch (Number(state)) {
          case State.New:
            if (c !== " ")
              parsed.scheme += c;
            else
              state = State.Params;
            break;
          case State.Params:
            switch (Number(substate)) {
              case ParamsState.Name:
                var code = c.charCodeAt(0);
                if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
                  tmpName += c;
                } else if (c === "=") {
                  if (tmpName.length === 0)
                    throw new InvalidHeaderError("bad param format");
                  substate = ParamsState.Quote;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Quote:
                if (c === '"') {
                  tmpValue = "";
                  substate = ParamsState.Value;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Value:
                if (c === '"') {
                  parsed.params[tmpName] = tmpValue;
                  substate = ParamsState.Comma;
                } else {
                  tmpValue += c;
                }
                break;
              case ParamsState.Comma:
                if (c === ",") {
                  tmpName = "";
                  substate = ParamsState.Name;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              default:
                throw new Error("Invalid substate");
            }
            break;
          default:
            throw new Error("Invalid substate");
        }
      }
      if (!parsed.params.headers || parsed.params.headers === "") {
        if (request.headers["x-date"]) {
          parsed.params.headers = ["x-date"];
        } else {
          parsed.params.headers = ["date"];
        }
      } else {
        parsed.params.headers = parsed.params.headers.split(" ");
      }
      if (!parsed.scheme || parsed.scheme !== "Signature")
        throw new InvalidHeaderError('scheme was not "Signature"');
      if (!parsed.params.keyId)
        throw new InvalidHeaderError("keyId was not specified");
      if (!parsed.params.algorithm)
        throw new InvalidHeaderError("algorithm was not specified");
      if (!parsed.params.signature)
        throw new InvalidHeaderError("signature was not specified");
      parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
      try {
        validateAlgorithm(parsed.params.algorithm);
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw new InvalidParamsError(parsed.params.algorithm + " is not " + "supported");
        else
          throw e;
      }
      for (i = 0;i < parsed.params.headers.length; i++) {
        var h = parsed.params.headers[i].toLowerCase();
        parsed.params.headers[i] = h;
        if (h === "request-line") {
          if (!options.strict) {
            parsed.signingString += request.method + " " + request.url + " HTTP/" + request.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header " + "with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          parsed.signingString += "(request-target): " + request.method.toLowerCase() + " " + request.url;
        } else {
          var value = request.headers[h];
          if (value === undefined)
            throw new MissingHeaderError(h + " was not in the request");
          parsed.signingString += h + ": " + value;
        }
        if (i + 1 < parsed.params.headers.length)
          parsed.signingString += `
`;
      }
      var date;
      if (request.headers.date || request.headers["x-date"]) {
        if (request.headers["x-date"]) {
          date = new Date(request.headers["x-date"]);
        } else {
          date = new Date(request.headers.date);
        }
        var now = new Date;
        var skew = Math.abs(now.getTime() - date.getTime());
        if (skew > options.clockSkew * 1000) {
          throw new ExpiredRequestError("clock skew of " + skew / 1000 + "s was greater than " + options.clockSkew + "s");
        }
      }
      options.headers.forEach(function(hdr) {
        if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
          throw new MissingHeaderError(hdr + " was not a signed header");
      });
      if (options.algorithms) {
        if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
          throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
      }
      parsed.algorithm = parsed.params.algorithm.toUpperCase();
      parsed.keyId = parsed.params.keyId;
      return parsed;
    }
  };
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS((exports) => {
  var mod_assert = __require("assert");
  var mod_util = __require("util");
  exports.sprintf = jsSprintf;
  exports.printf = jsPrintf;
  exports.fprintf = jsFprintf;
  function jsSprintf(fmt) {
    var regex = [
      "([^%]*)",
      "%",
      "(['\\-+ #0]*?)",
      "([1-9]\\d*)?",
      "(\\.([1-9]\\d*))?",
      "[lhjztL]*?",
      "([diouxXfFeEgGaAcCsSp%jr])"
    ].join("");
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match;
    var ret = "";
    var argn = 1;
    mod_assert.equal("string", typeof fmt);
    while ((match = re.exec(fmt)) !== null) {
      ret += match[1];
      fmt = fmt.substring(match[0].length);
      flags = match[2] || "";
      width = match[3] || 0;
      precision = match[4] || "";
      conversion = match[6];
      left = false;
      sign = false;
      pad = " ";
      if (conversion == "%") {
        ret += "%";
        continue;
      }
      if (args.length === 0)
        throw new Error("too few args to sprintf");
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/))
        throw new Error("unsupported flags: " + flags);
      if (precision.length > 0)
        throw new Error("non-zero precision not supported");
      if (flags.match(/-/))
        left = true;
      if (flags.match(/0/))
        pad = "0";
      if (flags.match(/\+/))
        sign = true;
      switch (conversion) {
        case "s":
          if (arg === undefined || arg === null)
            throw new Error("argument " + argn + ": attempted to print undefined or null " + "as a string");
          ret += doPad(pad, width, left, arg.toString());
          break;
        case "d":
          arg = Math.floor(arg);
        case "f":
          sign = sign && arg > 0 ? "+" : "";
          ret += sign + doPad(pad, width, left, arg.toString());
          break;
        case "x":
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case "j":
          if (width === 0)
            width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case "r":
          ret += dumpException(arg);
          break;
        default:
          throw new Error("unsupported conversion: " + conversion);
      }
    }
    ret += fmt;
    return ret;
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str) {
    var ret = str;
    while (ret.length < width) {
      if (left)
        ret += chr;
      else
        ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf("invalid type for %%r: %j", ex));
    ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
    if (ex.cause && typeof ex.cause === "function") {
      var cex = ex.cause();
      if (cex) {
        ret += `
Caused by: ` + dumpException(cex);
      }
    }
    return ret;
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/verror/lib/verror.js
var require_verror = __commonJS((exports, module) => {
  var mod_assertplus = require_assert();
  var mod_util = __require("util");
  var mod_extsprintf = require_extsprintf();
  var mod_isError = require_util().isError;
  var sprintf = mod_extsprintf.sprintf;
  module.exports = VError;
  VError.VError = VError;
  VError.SError = SError;
  VError.WError = WError;
  VError.MultiError = MultiError;
  function parseConstructorArguments(args) {
    var argv, options, sprintf_args, shortmessage, k;
    mod_assertplus.object(args, "args");
    mod_assertplus.bool(args.strict, "args.strict");
    mod_assertplus.array(args.argv, "args.argv");
    argv = args.argv;
    if (argv.length === 0) {
      options = {};
      sprintf_args = [];
    } else if (mod_isError(argv[0])) {
      options = { cause: argv[0] };
      sprintf_args = argv.slice(1);
    } else if (typeof argv[0] === "object") {
      options = {};
      for (k in argv[0]) {
        options[k] = argv[0][k];
      }
      sprintf_args = argv.slice(1);
    } else {
      mod_assertplus.string(argv[0], "first argument to VError, SError, or WError " + "constructor must be a string, object, or Error");
      options = {};
      sprintf_args = argv;
    }
    mod_assertplus.object(options);
    if (!options.strict && !args.strict) {
      sprintf_args = sprintf_args.map(function(a) {
        return a === null ? "null" : a === undefined ? "undefined" : a;
      });
    }
    if (sprintf_args.length === 0) {
      shortmessage = "";
    } else {
      shortmessage = sprintf.apply(null, sprintf_args);
    }
    return {
      options,
      shortmessage
    };
  }
  function VError() {
    var args, obj2, parsed, cause, ctor, message, k;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof VError)) {
      obj2 = Object.create(VError.prototype);
      VError.apply(obj2, arguments);
      return obj2;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false
    });
    if (parsed.options.name) {
      mod_assertplus.string(parsed.options.name, `error's "name" must be a string`);
      this.name = parsed.options.name;
    }
    this.jse_shortmsg = parsed.shortmessage;
    message = parsed.shortmessage;
    cause = parsed.options.cause;
    if (cause) {
      mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
      this.jse_cause = cause;
      if (!parsed.options.skipCauseMessage) {
        message += ": " + cause.message;
      }
    }
    this.jse_info = {};
    if (parsed.options.info) {
      for (k in parsed.options.info) {
        this.jse_info[k] = parsed.options.info[k];
      }
    }
    this.message = message;
    Error.call(this, message);
    if (Error.captureStackTrace) {
      ctor = parsed.options.constructorOpt || this.constructor;
      Error.captureStackTrace(this, ctor);
    }
    return this;
  }
  mod_util.inherits(VError, Error);
  VError.prototype.name = "VError";
  VError.prototype.toString = function ve_toString() {
    var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str += ": " + this.message;
    return str;
  };
  VError.prototype.cause = function ve_cause() {
    var cause = VError.cause(this);
    return cause === null ? undefined : cause;
  };
  VError.cause = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    return mod_isError(err.jse_cause) ? err.jse_cause : null;
  };
  VError.info = function(err) {
    var rv, cause, k;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    cause = VError.cause(err);
    if (cause !== null) {
      rv = VError.info(cause);
    } else {
      rv = {};
    }
    if (typeof err.jse_info == "object" && err.jse_info !== null) {
      for (k in err.jse_info) {
        rv[k] = err.jse_info[k];
      }
    }
    return rv;
  };
  VError.findCauseByName = function(err, name) {
    var cause;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.string(name, "name");
    mod_assertplus.ok(name.length > 0, "name cannot be empty");
    for (cause = err;cause !== null; cause = VError.cause(cause)) {
      mod_assertplus.ok(mod_isError(cause));
      if (cause.name == name) {
        return cause;
      }
    }
    return null;
  };
  VError.hasCauseWithName = function(err, name) {
    return VError.findCauseByName(err, name) !== null;
  };
  VError.fullStack = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    var cause = VError.cause(err);
    if (cause) {
      return err.stack + `
caused by: ` + VError.fullStack(cause);
    }
    return err.stack;
  };
  VError.errorFromList = function(errors) {
    mod_assertplus.arrayOfObject(errors, "errors");
    if (errors.length === 0) {
      return null;
    }
    errors.forEach(function(e) {
      mod_assertplus.ok(mod_isError(e));
    });
    if (errors.length == 1) {
      return errors[0];
    }
    return new MultiError(errors);
  };
  VError.errorForEach = function(err, func) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.func(func, "func");
    if (err instanceof MultiError) {
      err.errors().forEach(function iterError(e) {
        func(e);
      });
    } else {
      func(err);
    }
  };
  function SError() {
    var args, obj2, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof SError)) {
      obj2 = Object.create(SError.prototype);
      SError.apply(obj2, arguments);
      return obj2;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: true
    });
    options = parsed.options;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(SError, VError);
  function MultiError(errors) {
    mod_assertplus.array(errors, "list of errors");
    mod_assertplus.ok(errors.length > 0, "must be at least one error");
    this.ase_errors = errors;
    VError.call(this, {
      cause: errors[0]
    }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
  }
  mod_util.inherits(MultiError, VError);
  MultiError.prototype.name = "MultiError";
  MultiError.prototype.errors = function me_errors() {
    return this.ase_errors.slice(0);
  };
  function WError() {
    var args, obj2, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof WError)) {
      obj2 = Object.create(WError.prototype);
      WError.apply(obj2, args);
      return obj2;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false
    });
    options = parsed.options;
    options["skipCauseMessage"] = true;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(WError, VError);
  WError.prototype.name = "WError";
  WError.prototype.toString = function we_toString() {
    var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str += ": " + this.message;
    if (this.jse_cause && this.jse_cause.message)
      str += "; caused by " + this.jse_cause.toString();
    return str;
  };
  WError.prototype.cause = function we_cause(c) {
    if (mod_isError(c))
      this.jse_cause = c;
    return this.jse_cause;
  };
});

// node_modules/json-schema/lib/validate.js
var require_validate = __commonJS((exports, module) => {
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define([], function() {
        return factory();
      });
    } else if (typeof module === "object" && module.exports) {
      module.exports = factory();
    } else {
      root.jsonSchema = factory();
    }
  })(exports, function() {
    var exports2 = validate;
    exports2.Integer = { type: "integer" };
    var primitiveConstructors = {
      String,
      Boolean,
      Number,
      Object,
      Array,
      Date
    };
    exports2.validate = validate;
    function validate(instance, schema) {
      return validate(instance, schema, { changing: false });
    }
    exports2.checkPropertyChange = function(value, schema, property) {
      return validate(value, schema, { changing: property || "property" });
    };
    var validate = exports2._validate = function(instance, schema, options) {
      if (!options)
        options = {};
      var _changing = options.changing;
      function getType(schema2) {
        return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
      }
      var errors = [];
      function checkProp(value, schema2, path, i) {
        var l2;
        path += path ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
        function addError(message) {
          errors.push({ property: path, message });
        }
        if ((typeof schema2 != "object" || schema2 instanceof Array) && (path || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
          if (typeof schema2 == "function") {
            if (!(value instanceof schema2)) {
              addError("is not an instance of the class/constructor " + schema2.name);
            }
          } else if (schema2) {
            addError("Invalid schema/property definition " + schema2);
          }
          return null;
        }
        if (_changing && schema2.readonly) {
          addError("is a readonly field, it can not be changed");
        }
        if (schema2["extends"]) {
          checkProp(value, schema2["extends"], path, i);
        }
        function checkType(type, value2) {
          if (type) {
            if (typeof type == "string" && type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && !(value2 instanceof Date && type == "date") && !(type == "integer" && value2 % 1 === 0)) {
              return [{ property: path, message: value2 + " - " + typeof value2 + " value found, but a " + type + " is required" }];
            }
            if (type instanceof Array) {
              var unionErrors = [];
              for (var j2 = 0;j2 < type.length; j2++) {
                if (!(unionErrors = checkType(type[j2], value2)).length) {
                  break;
                }
              }
              if (unionErrors.length) {
                return unionErrors;
              }
            } else if (typeof type == "object") {
              var priorErrors = errors;
              errors = [];
              checkProp(value2, type, path);
              var theseErrors = errors;
              errors = priorErrors;
              return theseErrors;
            }
          }
          return [];
        }
        if (value === undefined) {
          if (schema2.required) {
            addError("is missing and it is required");
          }
        } else {
          errors = errors.concat(checkType(getType(schema2), value));
          if (schema2.disallow && !checkType(schema2.disallow, value).length) {
            addError(" disallowed value was matched");
          }
          if (value !== null) {
            if (value instanceof Array) {
              if (schema2.items) {
                var itemsIsArray = schema2.items instanceof Array;
                var propDef = schema2.items;
                for (i = 0, l2 = value.length;i < l2; i += 1) {
                  if (itemsIsArray)
                    propDef = schema2.items[i];
                  if (options.coerce)
                    value[i] = options.coerce(value[i], propDef);
                  errors.concat(checkProp(value[i], propDef, path, i));
                }
              }
              if (schema2.minItems && value.length < schema2.minItems) {
                addError("There must be a minimum of " + schema2.minItems + " in the array");
              }
              if (schema2.maxItems && value.length > schema2.maxItems) {
                addError("There must be a maximum of " + schema2.maxItems + " in the array");
              }
            } else if (schema2.properties || schema2.additionalProperties) {
              errors.concat(checkObj(value, schema2.properties, path, schema2.additionalProperties));
            }
            if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
              addError("does not match the regex pattern " + schema2.pattern);
            }
            if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
              addError("may only be " + schema2.maxLength + " characters long");
            }
            if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
              addError("must be at least " + schema2.minLength + " characters long");
            }
            if (typeof schema2.minimum !== "undefined" && typeof value == typeof schema2.minimum && schema2.minimum > value) {
              addError("must have a minimum value of " + schema2.minimum);
            }
            if (typeof schema2.maximum !== "undefined" && typeof value == typeof schema2.maximum && schema2.maximum < value) {
              addError("must have a maximum value of " + schema2.maximum);
            }
            if (schema2["enum"]) {
              var enumer = schema2["enum"];
              l2 = enumer.length;
              var found;
              for (var j = 0;j < l2; j++) {
                if (enumer[j] === value) {
                  found = 1;
                  break;
                }
              }
              if (!found) {
                addError("does not have a value in the enumeration " + enumer.join(", "));
              }
            }
            if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
              addError("may only have " + schema2.maxDecimal + " digits of decimal places");
            }
          }
        }
        return null;
      }
      function checkObj(instance2, objTypeDef, path, additionalProp) {
        if (typeof objTypeDef == "object") {
          if (typeof instance2 != "object" || instance2 instanceof Array) {
            errors.push({ property: path, message: "an object is required" });
          }
          for (var i in objTypeDef) {
            if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
              var value = instance2.hasOwnProperty(i) ? instance2[i] : undefined;
              if (value === undefined && options.existingOnly)
                continue;
              var propDef = objTypeDef[i];
              if (value === undefined && propDef["default"]) {
                value = instance2[i] = propDef["default"];
              }
              if (options.coerce && i in instance2) {
                value = instance2[i] = options.coerce(value, propDef);
              }
              checkProp(value, propDef, path, i);
            }
          }
        }
        for (i in instance2) {
          if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
            if (options.filter) {
              delete instance2[i];
              continue;
            } else {
              errors.push({ property: path, message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
            }
          }
          var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
          if (requires && !(requires in instance2)) {
            errors.push({ property: path, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
          }
          value = instance2[i];
          if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
            if (options.coerce) {
              value = instance2[i] = options.coerce(value, additionalProp);
            }
            checkProp(value, additionalProp, path, i);
          }
          if (!_changing && value && value.$schema) {
            errors = errors.concat(checkProp(value, value.$schema, path, i));
          }
        }
        return errors;
      }
      if (schema) {
        checkProp(instance, schema, "", _changing || "");
      }
      if (!_changing && instance && instance.$schema) {
        checkProp(instance, instance.$schema, "", "");
      }
      return { valid: !errors.length, errors };
    };
    exports2.mustBeValid = function(result) {
      if (!result.valid) {
        throw new TypeError(result.errors.map(function(error) {
          return "for property " + error.property + ": " + error.message;
        }).join(`, 
`));
      }
    };
    return exports2;
  });
});

// node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS((exports) => {
  var mod_assert = require_assert();
  var mod_util = __require("util");
  var mod_extsprintf = require_extsprintf();
  var mod_verror = require_verror();
  var mod_jsonschema = require_validate();
  exports.deepCopy = deepCopy;
  exports.deepEqual = deepEqual;
  exports.isEmpty = isEmpty;
  exports.hasKey = hasKey;
  exports.forEachKey = forEachKey;
  exports.pluck = pluck;
  exports.flattenObject = flattenObject;
  exports.flattenIter = flattenIter;
  exports.validateJsonObject = validateJsonObjectJS;
  exports.validateJsonObjectJS = validateJsonObjectJS;
  exports.randElt = randElt;
  exports.extraProperties = extraProperties;
  exports.mergeObjects = mergeObjects;
  exports.startsWith = startsWith;
  exports.endsWith = endsWith;
  exports.parseInteger = parseInteger;
  exports.iso8601 = iso8601;
  exports.rfc1123 = rfc1123;
  exports.parseDateTime = parseDateTime;
  exports.hrtimediff = hrtimeDiff;
  exports.hrtimeDiff = hrtimeDiff;
  exports.hrtimeAccum = hrtimeAccum;
  exports.hrtimeAdd = hrtimeAdd;
  exports.hrtimeNanosec = hrtimeNanosec;
  exports.hrtimeMicrosec = hrtimeMicrosec;
  exports.hrtimeMillisec = hrtimeMillisec;
  function deepCopy(obj2) {
    var ret, key;
    var marker = "__deepCopy";
    if (obj2 && obj2[marker])
      throw new Error("attempted deep copy of cyclic object");
    if (obj2 && obj2.constructor == Object) {
      ret = {};
      obj2[marker] = true;
      for (key in obj2) {
        if (key == marker)
          continue;
        ret[key] = deepCopy(obj2[key]);
      }
      delete obj2[marker];
      return ret;
    }
    if (obj2 && obj2.constructor == Array) {
      ret = [];
      obj2[marker] = true;
      for (key = 0;key < obj2.length; key++)
        ret.push(deepCopy(obj2[key]));
      delete obj2[marker];
      return ret;
    }
    return obj2;
  }
  function deepEqual(obj1, obj2) {
    if (typeof obj1 != typeof obj2)
      return false;
    if (obj1 === null || obj2 === null || typeof obj1 != "object")
      return obj1 === obj2;
    if (obj1.constructor != obj2.constructor)
      return false;
    var k;
    for (k in obj1) {
      if (!obj2.hasOwnProperty(k))
        return false;
      if (!deepEqual(obj1[k], obj2[k]))
        return false;
    }
    for (k in obj2) {
      if (!obj1.hasOwnProperty(k))
        return false;
    }
    return true;
  }
  function isEmpty(obj2) {
    var key;
    for (key in obj2)
      return false;
    return true;
  }
  function hasKey(obj2, key) {
    mod_assert.equal(typeof key, "string");
    return Object.prototype.hasOwnProperty.call(obj2, key);
  }
  function forEachKey(obj2, callback) {
    for (var key in obj2) {
      if (hasKey(obj2, key)) {
        callback(key, obj2[key]);
      }
    }
  }
  function pluck(obj2, key) {
    mod_assert.equal(typeof key, "string");
    return pluckv(obj2, key);
  }
  function pluckv(obj2, key) {
    if (obj2 === null || typeof obj2 !== "object")
      return;
    if (obj2.hasOwnProperty(key))
      return obj2[key];
    var i = key.indexOf(".");
    if (i == -1)
      return;
    var key1 = key.substr(0, i);
    if (!obj2.hasOwnProperty(key1))
      return;
    return pluckv(obj2[key1], key.substr(i + 1));
  }
  function flattenIter(data, depth, callback) {
    doFlattenIter(data, depth, [], callback);
  }
  function doFlattenIter(data, depth, accum, callback) {
    var each;
    var key;
    if (depth === 0) {
      each = accum.slice(0);
      each.push(data);
      callback(each);
      return;
    }
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    for (key in data) {
      each = accum.slice(0);
      each.push(key);
      doFlattenIter(data[key], depth - 1, each, callback);
    }
  }
  function flattenObject(data, depth) {
    if (depth === 0)
      return [data];
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    var rv = [];
    var key;
    for (key in data) {
      flattenObject(data[key], depth - 1).forEach(function(p) {
        rv.push([key].concat(p));
      });
    }
    return rv;
  }
  function startsWith(str, prefix) {
    return str.substr(0, prefix.length) == prefix;
  }
  function endsWith(str, suffix) {
    return str.substr(str.length - suffix.length, suffix.length) == suffix;
  }
  function iso8601(d) {
    if (typeof d == "number")
      d = new Date(d);
    mod_assert.ok(d.constructor === Date);
    return mod_extsprintf.sprintf("%4d-%02d-%02dT%02d:%02d:%02d.%03dZ", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  }
  var RFC1123_MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var RFC1123_DAYS = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  function rfc1123(date) {
    return mod_extsprintf.sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  }
  function parseDateTime(str) {
    var numeric = +str;
    if (!isNaN(numeric)) {
      return new Date(numeric);
    } else {
      return new Date(str);
    }
  }
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var PI_DEFAULTS = {
    base: 10,
    allowSign: true,
    allowPrefix: false,
    allowTrailing: false,
    allowImprecise: false,
    trimWhitespace: false,
    leadingZeroIsOctal: false
  };
  var CP_0 = 48;
  var CP_9 = 57;
  var CP_A = 65;
  var CP_B = 66;
  var CP_O = 79;
  var CP_T = 84;
  var CP_X = 88;
  var CP_Z = 90;
  var CP_a = 97;
  var CP_b = 98;
  var CP_o = 111;
  var CP_t = 116;
  var CP_x = 120;
  var CP_z = 122;
  var PI_CONV_DEC = 48;
  var PI_CONV_UC = 55;
  var PI_CONV_LC = 87;
  function parseInteger(str, uopts) {
    mod_assert.string(str, "str");
    mod_assert.optionalObject(uopts, "options");
    var baseOverride = false;
    var options = PI_DEFAULTS;
    if (uopts) {
      baseOverride = hasKey(uopts, "base");
      options = mergeObjects(options, uopts);
      mod_assert.number(options.base, "options.base");
      mod_assert.ok(options.base >= 2, "options.base >= 2");
      mod_assert.ok(options.base <= 36, "options.base <= 36");
      mod_assert.bool(options.allowSign, "options.allowSign");
      mod_assert.bool(options.allowPrefix, "options.allowPrefix");
      mod_assert.bool(options.allowTrailing, "options.allowTrailing");
      mod_assert.bool(options.allowImprecise, "options.allowImprecise");
      mod_assert.bool(options.trimWhitespace, "options.trimWhitespace");
      mod_assert.bool(options.leadingZeroIsOctal, "options.leadingZeroIsOctal");
      if (options.leadingZeroIsOctal) {
        mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are ' + "mutually exclusive");
      }
    }
    var c;
    var pbase = -1;
    var base = options.base;
    var start;
    var mult = 1;
    var value = 0;
    var idx = 0;
    var len = str.length;
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (options.allowSign) {
      if (str[idx] === "-") {
        idx += 1;
        mult = -1;
      } else if (str[idx] === "+") {
        idx += 1;
      }
    }
    if (str[idx] === "0") {
      if (options.allowPrefix) {
        pbase = prefixToBase(str.charCodeAt(idx + 1));
        if (pbase !== -1 && (!baseOverride || pbase === base)) {
          base = pbase;
          idx += 2;
        }
      }
      if (pbase === -1 && options.leadingZeroIsOctal) {
        base = 8;
      }
    }
    for (start = idx;idx < len; ++idx) {
      c = translateDigit(str.charCodeAt(idx));
      if (c !== -1 && c < base) {
        value *= base;
        value += c;
      } else {
        break;
      }
    }
    if (start === idx) {
      return new Error("invalid number: " + JSON.stringify(str));
    }
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (idx < len && !options.allowTrailing) {
      return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
    }
    if (value === 0) {
      return 0;
    }
    var result = value * mult;
    if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
      return new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx)));
    }
    return result;
  }
  function translateDigit(d) {
    if (d >= CP_0 && d <= CP_9) {
      return d - PI_CONV_DEC;
    } else if (d >= CP_A && d <= CP_Z) {
      return d - PI_CONV_UC;
    } else if (d >= CP_a && d <= CP_z) {
      return d - PI_CONV_LC;
    } else {
      return -1;
    }
  }
  function isSpace(c) {
    return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
  }
  function prefixToBase(c) {
    if (c === CP_b || c === CP_B) {
      return 2;
    } else if (c === CP_o || c === CP_O) {
      return 8;
    } else if (c === CP_t || c === CP_T) {
      return 10;
    } else if (c === CP_x || c === CP_X) {
      return 16;
    } else {
      return -1;
    }
  }
  function validateJsonObjectJS(schema, input) {
    var report = mod_jsonschema.validate(input, schema);
    if (report.errors.length === 0)
      return null;
    var error = report.errors[0];
    var propname = error["property"];
    var reason = error["message"].toLowerCase();
    var i, j;
    if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the " + "schema does not allow additional properties")) != -1) {
      i += "the property ".length;
      if (propname === "")
        propname = reason.substr(i, j - i);
      else
        propname = propname + "." + reason.substr(i, j - i);
      reason = "unsupported property";
    }
    var rv = new mod_verror.VError('property "%s": %s', propname, reason);
    rv.jsv_details = error;
    return rv;
  }
  function randElt(arr) {
    mod_assert.ok(Array.isArray(arr) && arr.length > 0, "randElt argument must be a non-empty array");
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function assertHrtime(a) {
    mod_assert.ok(a[0] >= 0 && a[1] >= 0, "negative numbers not allowed in hrtimes");
    mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
  }
  function hrtimeDiff(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], "negative differences not allowed");
    var rv = [a[0] - b[0], 0];
    if (a[1] >= b[1]) {
      rv[1] = a[1] - b[1];
    } else {
      rv[0]--;
      rv[1] = 1e9 - (b[1] - a[1]);
    }
    return rv;
  }
  function hrtimeNanosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e9 + a[1]);
  }
  function hrtimeMicrosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e6 + a[1] / 1000);
  }
  function hrtimeMillisec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1000 + a[1] / 1e6);
  }
  function hrtimeAccum(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    a[1] += b[1];
    if (a[1] >= 1e9) {
      a[0]++;
      a[1] -= 1e9;
    }
    a[0] += b[0];
    return a;
  }
  function hrtimeAdd(a, b) {
    assertHrtime(a);
    var rv = [a[0], a[1]];
    return hrtimeAccum(rv, b);
  }
  function extraProperties(obj2, allowed) {
    mod_assert.ok(typeof obj2 === "object" && obj2 !== null, "obj argument must be a non-null object");
    mod_assert.ok(Array.isArray(allowed), "allowed argument must be an array of strings");
    for (var i = 0;i < allowed.length; i++) {
      mod_assert.ok(typeof allowed[i] === "string", "allowed argument must be an array of strings");
    }
    return Object.keys(obj2).filter(function(key) {
      return allowed.indexOf(key) === -1;
    });
  }
  function mergeObjects(provided, overrides, defaults) {
    var rv, k;
    rv = {};
    if (defaults) {
      for (k in defaults)
        rv[k] = defaults[k];
    }
    if (provided) {
      for (k in provided)
        rv[k] = provided[k];
    }
    if (overrides) {
      for (k in overrides)
        rv[k] = overrides[k];
    }
    return rv;
  }
});

// node_modules/http-signature/lib/signer.js
var require_signer = __commonJS((exports, module) => {
  var assert = require_assert();
  var crypto = __require("crypto");
  var http = __require("http");
  var util = __require("util");
  var sshpk = require_lib2();
  var jsprim = require_jsprim();
  var utils = require_utils2();
  var sprintf = __require("util").format;
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  var AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util.inherits(StrictParsingError, HttpSignatureError);
  function RequestSigner(options) {
    assert.object(options, "options");
    var alg = [];
    if (options.algorithm !== undefined) {
      assert.string(options.algorithm, "options.algorithm");
      alg = validateAlgorithm(options.algorithm);
    }
    this.rs_alg = alg;
    if (options.sign !== undefined) {
      assert.func(options.sign, "options.sign");
      this.rs_signFunc = options.sign;
    } else if (alg[0] === "hmac" && options.key !== undefined) {
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
        throw new TypeError("options.key for HMAC must be a string or Buffer");
      this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
      this.rs_signer.sign = function() {
        var digest = this.digest("base64");
        return {
          hashAlgorithm: alg[1],
          toString: function() {
            return digest;
          }
        };
      };
    } else if (options.key !== undefined) {
      var key = options.key;
      if (typeof key === "string" || Buffer.isBuffer(key))
        key = sshpk.parsePrivateKey(key);
      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
      this.rs_key = key;
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (!PK_ALGOS[key.type]) {
        throw new InvalidAlgorithmError(key.type.toUpperCase() + " type " + "keys are not supported");
      }
      if (alg[0] !== undefined && key.type !== alg[0]) {
        throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
      }
      this.rs_signer = key.createSign(alg[1]);
    } else {
      throw new TypeError("options.sign (func) or options.key is required");
    }
    this.rs_headers = [];
    this.rs_lines = [];
  }
  RequestSigner.prototype.writeHeader = function(header, value) {
    assert.string(header, "header");
    header = header.toLowerCase();
    assert.string(value, "value");
    this.rs_headers.push(header);
    if (this.rs_signFunc) {
      this.rs_lines.push(header + ": " + value);
    } else {
      var line = header + ": " + value;
      if (this.rs_headers.length > 0)
        line = `
` + line;
      this.rs_signer.update(line);
    }
    return value;
  };
  RequestSigner.prototype.writeDateHeader = function() {
    return this.writeHeader("date", jsprim.rfc1123(new Date));
  };
  RequestSigner.prototype.writeTarget = function(method, path) {
    assert.string(method, "method");
    assert.string(path, "path");
    method = method.toLowerCase();
    this.writeHeader("(request-target)", method + " " + path);
  };
  RequestSigner.prototype.sign = function(cb) {
    assert.func(cb, "callback");
    if (this.rs_headers.length < 1)
      throw new Error("At least one header must be signed");
    var alg, authz;
    if (this.rs_signFunc) {
      var data = this.rs_lines.join(`
`);
      var self2 = this;
      this.rs_signFunc(data, function(err, sig) {
        if (err) {
          cb(err);
          return;
        }
        try {
          assert.object(sig, "signature");
          assert.string(sig.keyId, "signature.keyId");
          assert.string(sig.algorithm, "signature.algorithm");
          assert.string(sig.signature, "signature.signature");
          alg = validateAlgorithm(sig.algorithm);
          authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self2.rs_headers.join(" "), sig.signature);
        } catch (e) {
          cb(e);
          return;
        }
        cb(null, authz);
      });
    } else {
      try {
        var sigObj = this.rs_signer.sign();
      } catch (e) {
        cb(e);
        return;
      }
      alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
      var signature = sigObj.toString();
      authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(" "), signature);
      cb(null, authz);
    }
  };
  module.exports = {
    isSigner: function(obj2) {
      if (typeof obj2 === "object" && obj2 instanceof RequestSigner)
        return true;
      return false;
    },
    createSigner: function createSigner(options) {
      return new RequestSigner(options);
    },
    signRequest: function signRequest(request, options) {
      assert.object(request, "request");
      assert.object(options, "options");
      assert.optionalString(options.algorithm, "options.algorithm");
      assert.string(options.keyId, "options.keyId");
      assert.optionalArrayOfString(options.headers, "options.headers");
      assert.optionalString(options.httpVersion, "options.httpVersion");
      if (!request.getHeader("Date"))
        request.setHeader("Date", jsprim.rfc1123(new Date));
      if (!options.headers)
        options.headers = ["date"];
      if (!options.httpVersion)
        options.httpVersion = "1.1";
      var alg = [];
      if (options.algorithm) {
        options.algorithm = options.algorithm.toLowerCase();
        alg = validateAlgorithm(options.algorithm);
      }
      var i;
      var stringToSign = "";
      for (i = 0;i < options.headers.length; i++) {
        if (typeof options.headers[i] !== "string")
          throw new TypeError("options.headers must be an array of Strings");
        var h = options.headers[i].toLowerCase();
        if (h === "request-line") {
          if (!options.strict) {
            stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header " + "with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          stringToSign += "(request-target): " + request.method.toLowerCase() + " " + request.path;
        } else {
          var value = request.getHeader(h);
          if (value === undefined || value === "") {
            throw new MissingHeaderError(h + " was not in the request");
          }
          stringToSign += h + ": " + value;
        }
        if (i + 1 < options.headers.length)
          stringToSign += `
`;
      }
      if (request.hasOwnProperty("_stringToSign")) {
        request._stringToSign = stringToSign;
      }
      var signature;
      if (alg[0] === "hmac") {
        if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
          throw new TypeError("options.key must be a string or Buffer");
        var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
        hmac.update(stringToSign);
        signature = hmac.digest("base64");
      } else {
        var key = options.key;
        if (typeof key === "string" || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(options.key);
        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(key.type.toUpperCase() + " type " + "keys are not supported");
        }
        if (alg[0] !== undefined && key.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
        }
        var signer = key.createSign(alg[1]);
        signer.update(stringToSign);
        var sigObj = signer.sign();
        if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
          throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
        }
        options.algorithm = key.type + "-" + sigObj.hashAlgorithm;
        signature = sigObj.toString();
        assert.notStrictEqual(signature, "", "empty signature produced");
      }
      var authzHeaderName = options.authorizationHeaderName || "Authorization";
      request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(" "), signature));
      return true;
    }
  };
});

// node_modules/http-signature/lib/verify.js
var require_verify = __commonJS((exports, module) => {
  var assert = require_assert();
  var crypto = __require("crypto");
  var sshpk = require_lib2();
  var utils = require_utils2();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  module.exports = {
    verifySignature: function verifySignature(parsedSignature, pubkey) {
      assert.object(parsedSignature, "parsedSignature");
      if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
        pubkey = sshpk.parseKey(pubkey);
      assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] === "hmac" || alg[0] !== pubkey.type)
        return false;
      var v = pubkey.createVerify(alg[1]);
      v.update(parsedSignature.signingString);
      return v.verify(parsedSignature.params.signature, "base64");
    },
    verifyHMAC: function verifyHMAC(parsedSignature, secret) {
      assert.object(parsedSignature, "parsedHMAC");
      assert.string(secret, "secret");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] !== "hmac")
        return false;
      var hashAlg = alg[1].toUpperCase();
      var hmac = crypto.createHmac(hashAlg, secret);
      hmac.update(parsedSignature.signingString);
      var h1 = crypto.createHmac(hashAlg, secret);
      h1.update(hmac.digest());
      h1 = h1.digest();
      var h2 = crypto.createHmac(hashAlg, secret);
      h2.update(new Buffer(parsedSignature.params.signature, "base64"));
      h2 = h2.digest();
      if (typeof h1 === "string")
        return h1 === h2;
      if (Buffer.isBuffer(h1) && !h1.equals)
        return h1.toString("binary") === h2.toString("binary");
      return h1.equals(h2);
    }
  };
});

// node_modules/http-signature/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var parser = require_parser();
  var signer = require_signer();
  var verify = require_verify();
  var utils = require_utils2();
  module.exports = {
    parse: parser.parseRequest,
    parseRequest: parser.parseRequest,
    sign: signer.signRequest,
    signRequest: signer.signRequest,
    createSigner: signer.createSigner,
    isSigner: signer.isSigner,
    sshKeyToPEM: utils.sshKeyToPEM,
    sshKeyFingerprint: utils.fingerprint,
    pemToRsaSSHKey: utils.pemToRsaSSHKey,
    verify: verify.verifySignature,
    verifySignature: verify.verifySignature,
    verifyHMAC: verify.verifyHMAC
  };
});

// node_modules/postman-request/node_modules/mime-types/node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/postman-request/node_modules/mime-types/node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/postman-request/node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/caseless/index.js
var require_caseless = __commonJS((exports, module) => {
  function Caseless(dict) {
    this.dict = dict || {};
  }
  Caseless.prototype.set = function(name, value, clobber) {
    if (typeof name === "object") {
      for (var i in name) {
        this.set(i, name[i], value);
      }
    } else {
      if (typeof clobber === "undefined")
        clobber = true;
      var has = this.has(name);
      if (!clobber && has)
        this.dict[has] = this.dict[has] + "," + value;
      else
        this.dict[has || name] = value;
      return has;
    }
  };
  Caseless.prototype.has = function(name) {
    var keys = Object.keys(this.dict), name = name.toLowerCase();
    for (var i = 0;i < keys.length; i++) {
      if (keys[i].toLowerCase() === name)
        return keys[i];
    }
    return false;
  };
  Caseless.prototype.get = function(name) {
    name = name.toLowerCase();
    var result, _key;
    var headers = this.dict;
    Object.keys(headers).forEach(function(key) {
      _key = key.toLowerCase();
      if (name === _key)
        result = headers[key];
    });
    return result;
  };
  Caseless.prototype.swap = function(name) {
    var has = this.has(name);
    if (has === name)
      return;
    if (!has)
      throw new Error('There is no header than matches "' + name + '"');
    this.dict[name] = this.dict[has];
    delete this.dict[has];
  };
  Caseless.prototype.del = function(name) {
    var has = this.has(name);
    return delete this.dict[has || name];
  };
  module.exports = function(dict) {
    return new Caseless(dict);
  };
  module.exports.httpify = function(resp, headers) {
    var c = new Caseless(headers);
    resp.setHeader = function(key, value, clobber) {
      if (typeof value === "undefined")
        return;
      return c.set(key, value, clobber);
    };
    resp.hasHeader = function(key) {
      return c.has(key);
    };
    resp.getHeader = function(key) {
      return c.get(key);
    };
    resp.removeHeader = function(key) {
      return c.del(key);
    };
    resp.headers = c.dict;
    return c;
  };
});

// node_modules/forever-agent/index.js
var require_forever_agent = __commonJS((exports, module) => {
  module.exports = ForeverAgent;
  ForeverAgent.SSL = ForeverAgentSSL;
  var util = __require("util");
  var Agent = __require("http").Agent;
  var net = __require("net");
  var tls = __require("tls");
  var AgentSSL = __require("https").Agent;
  function getConnectionName(host, port) {
    var name = "";
    if (typeof host === "string") {
      name = host + ":" + port;
    } else {
      name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
    }
    return name;
  }
  function ForeverAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.requests = {};
    self2.sockets = {};
    self2.freeSockets = {};
    self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
    self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
    self2.on("free", function(socket, host, port) {
      var name = getConnectionName(host, port);
      if (self2.requests[name] && self2.requests[name].length) {
        self2.requests[name].shift().onSocket(socket);
      } else if (self2.sockets[name].length < self2.minSockets) {
        if (!self2.freeSockets[name])
          self2.freeSockets[name] = [];
        self2.freeSockets[name].push(socket);
        var onIdleError = function() {
          socket.destroy();
        };
        socket._onIdleError = onIdleError;
        socket.on("error", onIdleError);
      } else {
        socket.destroy();
      }
    });
  }
  util.inherits(ForeverAgent, Agent);
  ForeverAgent.defaultMinSockets = 5;
  ForeverAgent.prototype.createConnection = net.createConnection;
  ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
  ForeverAgent.prototype.addRequest = function(req, host, port) {
    var name = getConnectionName(host, port);
    if (typeof host !== "string") {
      var options = host;
      port = options.port;
      host = options.host;
    }
    if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
      var idleSocket = this.freeSockets[name].pop();
      idleSocket.removeListener("error", idleSocket._onIdleError);
      delete idleSocket._onIdleError;
      req._reusedSocket = true;
      req.onSocket(idleSocket);
    } else {
      this.addRequestNoreuse(req, host, port);
    }
  };
  ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
    if (this.sockets[name]) {
      var index = this.sockets[name].indexOf(s);
      if (index !== -1) {
        this.sockets[name].splice(index, 1);
      }
    } else if (this.sockets[name] && this.sockets[name].length === 0) {
      delete this.sockets[name];
      delete this.requests[name];
    }
    if (this.freeSockets[name]) {
      var index = this.freeSockets[name].indexOf(s);
      if (index !== -1) {
        this.freeSockets[name].splice(index, 1);
        if (this.freeSockets[name].length === 0) {
          delete this.freeSockets[name];
        }
      }
    }
    if (this.requests[name] && this.requests[name].length) {
      this.createSocket(name, host, port).emit("free");
    }
  };
  function ForeverAgentSSL(options) {
    ForeverAgent.call(this, options);
  }
  util.inherits(ForeverAgentSSL, ForeverAgent);
  ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
  ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
  function createConnectionSSL(port, host, options) {
    if (typeof port === "object") {
      options = port;
    } else if (typeof host === "object") {
      options = host;
    } else if (typeof options === "object") {
      options = options;
    } else {
      options = {};
    }
    if (typeof port === "number") {
      options.port = port;
    }
    if (typeof host === "string") {
      options.host = host;
    }
    return tls.connect(options);
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var util = __require("util");
  module.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// node_modules/form-data/node_modules/mime-types/node_modules/mime-db/db.json
var require_db2 = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/form-data/node_modules/mime-types/node_modules/mime-db/index.js
var require_mime_db2 = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db2();
});

// node_modules/form-data/node_modules/mime-types/index.js
var require_mime_types2 = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db2();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
  module.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports, module) => {
  var defer = require_defer();
  module.exports = async;
  function async(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  module.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var async = require_async();
  var abort = require_abort();
  module.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  module.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var abort = require_abort();
  var async = require_async();
  module.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serialOrdered = require_serialOrdered();
  module.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var CombinedStream = require_combined_stream();
  var util = __require("util");
  var path = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs = __require("fs");
  var mime = require_mime_types2();
  var asynckit = require_asynckit();
  var populate = require_populate();
  module.exports = FormData;
  util.inherits(FormData, CombinedStream);
  function FormData(options) {
    if (!(this instanceof FormData)) {
      return new FormData;
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData.LINE_BREAK = `\r
`;
  FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (util.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty("fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty("httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (value.hasOwnProperty("httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop))
        continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
      }
    }
    return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
  };
  FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty("httpVersion")) {
      filename = path.basename(value.client._httpMessage.path);
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
  };
  FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0;i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData.prototype.submit = function(params, cb) {
    var request, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err) {
        this._error(err);
        return;
      }
      request.setHeader("Content-Length", length);
      this.pipe(request);
      if (cb) {
        request.on("error", cb);
        request.on("response", cb.bind(this, null));
      }
    }.bind(this));
    return request;
  };
  FormData.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData.prototype.toString = function() {
    return "[object FormData]";
  };
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS((exports, module) => {
  var stream = __require("stream");
  function isStream(obj2) {
    return obj2 instanceof stream.Stream;
  }
  function isReadable(obj2) {
    return isStream(obj2) && typeof obj2._read == "function" && typeof obj2._readableState == "object";
  }
  function isWritable(obj2) {
    return isStream(obj2) && typeof obj2._write == "function" && typeof obj2._writableState == "object";
  }
  function isDuplex(obj2) {
    return isReadable(obj2) && isWritable(obj2);
  }
  module.exports = isStream;
  module.exports.isReadable = isReadable;
  module.exports.isWritable = isWritable;
  module.exports.isDuplex = isDuplex;
});

// node_modules/stream-length/node_modules/bluebird/js/main/es5.js
var require_es5 = __commonJS((exports, module) => {
  var isES5 = function() {
    return this === undefined;
  }();
  if (isES5) {
    module.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj2, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    has = {}.hasOwnProperty;
    str = {}.toString;
    proto = {}.constructor.prototype;
    ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    ObjectFreeze = function(obj2) {
      return obj2;
    };
    ObjectGetPrototypeOf = function(obj2) {
      try {
        return Object(obj2).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    ArrayIsArray = function(obj2) {
      try {
        return str.call(obj2) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    module.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  var has;
  var str;
  var proto;
  var ObjectKeys;
  var ObjectGetDescriptor;
  var ObjectDefineProperty;
  var ObjectFreeze;
  var ObjectGetPrototypeOf;
  var ArrayIsArray;
});

// node_modules/stream-length/node_modules/bluebird/js/main/util.js
var require_util2 = __commonJS((exports, module) => {
  var es5 = require_es5();
  var canEvaluate = typeof navigator == "undefined";
  var haveGetters = function() {
    try {
      var o = {};
      es5.defineProperty(o, "f", {
        get: function() {
          return 3;
        }
      });
      return o.f === 3;
    } catch (e) {
      return false;
    }
  }();
  var errorObj = { e: {} };
  var tryCatchTarget;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T;
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject(value) {
    return !isPrimitive(value);
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError))
      return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0;i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es5.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : undefined;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2))
      return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es5.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0;i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es5.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0;i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key])
              continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es5.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2))
          return [];
        var ret2 = [];
        enumeration:
          for (var key in obj2) {
            if (hasProp.call(obj2, key)) {
              ret2.push(key);
            } else {
              for (var i = 0;i < excludedPrototypes.length; ++i) {
                if (hasProp.call(excludedPrototypes[i], key)) {
                  continue enumeration;
                }
              }
              ret2.push(key);
            }
          }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es5.names(fn.prototype);
        var hasMethods = es5.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    function f() {}
    f.prototype = obj;
    var l = 8;
    while (l--)
      new f;
    return obj;
    eval(obj);
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0;i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {}
  }
  function originatesFromRejection(e) {
    if (e == null)
      return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return obj2 instanceof Error && es5.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error)) {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      if (filter(key)) {
        try {
          es5.defineProperty(to, key, es5.getDescriptor(from, key));
        } catch (ignore) {}
      }
    }
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    haveGetters,
    notEnumerableProp,
    isPrimitive,
    isObject,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
  };
  ret.isRecentNode = ret.isNode && function() {
    var version = process.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
  }();
  if (ret.isNode)
    ret.toFastProperties(process);
  try {
    throw new Error;
  } catch (e) {
    ret.lastLineError = e;
  }
  module.exports = ret;
});

// node_modules/stream-length/node_modules/bluebird/js/main/schedule.js
var require_schedule = __commonJS((exports, module) => {
  var schedule;
  var util = require_util2();
  var noAsyncScheduler = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/m3OTXk
`);
  };
  if (util.isNode && typeof MutationObserver === "undefined") {
    GlobalSetImmediate = global.setImmediate;
    ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(global, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
    schedule = function(fn) {
      var div = document.createElement("div");
      var observer = new MutationObserver(fn);
      observer.observe(div, { attributes: true });
      return function() {
        div.classList.toggle("foo");
      };
    };
    schedule.isStatic = true;
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  var GlobalSetImmediate;
  var ProcessNextTick;
  module.exports = schedule;
});

// node_modules/stream-length/node_modules/bluebird/js/main/queue.js
var require_queue = __commonJS((exports, module) => {
  function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0;j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = undefined;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype._unshiftOne = function(value) {
    var capacity = this._capacity;
    this._checkCapacity(this.length() + 1);
    var front = this._front;
    var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
    this[i] = value;
    this._front = i;
    this._length = this.length() + 1;
  };
  Queue.prototype.unshift = function(fn, receiver, arg) {
    this._unshiftOne(arg);
    this._unshiftOne(receiver);
    this._unshiftOne(fn);
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  module.exports = Queue;
});

// node_modules/stream-length/node_modules/bluebird/js/main/async.js
var require_async2 = __commonJS((exports, module) => {
  var firstLineError;
  try {
    throw new Error;
  } catch (e) {
    firstLineError = e;
  }
  var schedule = require_schedule();
  var Queue = require_queue();
  var util = require_util2();
  function Async() {
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
  }
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.enableTrampoline = function() {
    if (!this._trampolineEnabled) {
      this._trampolineEnabled = true;
      this._schedule = function(fn) {
        setTimeout(fn, 0);
      };
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._normalQueue.length() > 0;
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else
      try {
        this._schedule(function() {
          fn(arg);
        });
      } catch (e) {
        throw new Error(`No async scheduler available

    See http://goo.gl/m3OTXk
`);
      }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
  }
  if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    if (schedule.isStatic) {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    }
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise);
      } else {
        this._schedule(function() {
          promise._settlePromises();
        });
      }
    };
  }
  Async.prototype.invokeFirst = function(fn, receiver, arg) {
    this._normalQueue.unshift(fn, receiver, arg);
    this._queueTick();
  };
  Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
      var fn = queue.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue.shift();
      var arg = queue.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  module.exports = new Async;
  module.exports.firstLineError = firstLineError;
});

// node_modules/stream-length/node_modules/bluebird/js/main/errors.js
var require_errors3 = __commonJS((exports, module) => {
  var es5 = require_es5();
  var Objectfreeze = es5.freeze;
  var util = require_util2();
  var inherits = util.inherits;
  var notEnumerableProp = util.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError))
        return new SubError(message);
      notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits(SubError, Error);
    return SubError;
  }
  var _TypeError;
  var _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
  for (i = 0;i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  var i;
  es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError.prototype["isOperational"] = true;
  var level = 0;
  AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = `
` + indent + "AggregateError of:" + `
`;
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0;i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split(`
`);
      for (var j = 0;j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join(`
`);
      ret += str + `
`;
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError
    });
    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
  }
  module.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/thenables.js
var require_thenables = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var util = require_util2();
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    function tryConvertToPromise(obj2, context) {
      if (isObject(obj2)) {
        if (obj2 instanceof Promise2) {
          return obj2;
        } else if (isAnyBluebirdPromise(obj2)) {
          var ret = new Promise2(INTERNAL);
          obj2._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
          return ret;
        }
        var then = util.tryCatch(getThen)(obj2);
        if (then === errorObj) {
          if (context)
            context._pushContext();
          var ret = Promise2.reject(then.e);
          if (context)
            context._popContext();
          return ret;
        } else if (typeof then === "function") {
          return doThenable(obj2, then, context);
        }
      }
      return obj2;
    }
    function getThen(obj2) {
      return obj2.then;
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj2) {
      return hasProp.call(obj2, "_promise0");
    }
    function doThenable(x, then, context) {
      var promise = new Promise2(INTERNAL);
      var ret = promise;
      if (context)
        context._pushContext();
      promise._captureStackTrace();
      if (context)
        context._popContext();
      var synchronous = true;
      var result = util.tryCatch(then).call(x, resolveFromThenable, rejectFromThenable, progressFromThenable);
      synchronous = false;
      if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
      }
      function resolveFromThenable(value) {
        if (!promise)
          return;
        promise._resolveCallback(value);
        promise = null;
      }
      function rejectFromThenable(reason) {
        if (!promise)
          return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
      }
      function progressFromThenable(value) {
        if (!promise)
          return;
        if (typeof promise._progress === "function") {
          promise._progress(value);
        }
      }
      return ret;
    }
    return tryConvertToPromise;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/promise_array.js
var require_promise_array = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = require_util2();
    var isArray = util.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values) {
      var promise = this._promise = new Promise2(INTERNAL);
      var parent;
      if (values instanceof Promise2) {
        parent = values;
        promise._propagateFrom(parent, 1 | 4);
      }
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(undefined, -2);
    }
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        this._values = values;
        if (values._isFulfilled()) {
          values = values._value();
          if (!isArray(values)) {
            var err = new Promise2.TypeError(`expecting an array, a promise or a thenable

    See http://goo.gl/s8MMhc
`);
            this.__hardReject__(err);
            return;
          }
        } else if (values._isPending()) {
          values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
          return;
        } else {
          this._reject(values._reason());
          return;
        }
      } else if (!isArray(values)) {
        this._promise._reject(apiRejection(`expecting an array, a promise or a thenable

    See http://goo.gl/s8MMhc
`)._reason());
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var promise = this._promise;
      for (var i = 0;i < len; ++i) {
        var isResolved = this._isResolved();
        var maybePromise = tryConvertToPromise(values[i], promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          if (isResolved) {
            maybePromise._ignoreRejections();
          } else if (maybePromise._isPending()) {
            maybePromise._proxyPromiseArray(this, i);
          } else if (maybePromise._isFulfilled()) {
            this._promiseFulfilled(maybePromise._value(), i);
          } else {
            this._promiseRejected(maybePromise._reason(), i);
          }
        } else if (!isResolved) {
          this._promiseFulfilled(maybePromise, i);
        }
      }
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false, true);
    };
    PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
      this._promise._progress({
        index,
        value: progressValue
      });
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
      }
    };
    PromiseArray.prototype._promiseRejected = function(reason, index) {
      this._totalResolved++;
      this._reject(reason);
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/captured_trace.js
var require_captured_trace = __commonJS((exports, module) => {
  module.exports = function() {
    var async = require_async2();
    var util = require_util2();
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var warn;
    function CapturedTrace(parent) {
      this._parent = parent;
      var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32)
        this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2)
        return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node = this;node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
      }
      length = this._length = i;
      for (var i = length - 1;i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0;i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
          if (index > 0) {
            nodes[index - 1]._parent = undefined;
            nodes[index - 1]._length = 1;
          }
          nodes[i]._parent = undefined;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = undefined;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2;j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.parent = function() {
      return this._parent;
    };
    CapturedTrace.prototype.hasParent = function() {
      return this._parent !== undefined;
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
      if (error.__stackCleaned__)
        return;
      this.uncycle();
      var parsed = CapturedTrace.parseStackAndMessage(error);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split(`
`)));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
      util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    function reconstructStack(message, stacks) {
      for (var i = 0;i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join(`
`);
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join(`
`);
      }
      return message + `
` + stacks.join(`
`);
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0;i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1;i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1;j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint;j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = stackFramePattern.test(line) || line === "    (No stack trace)";
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error) {
      var stack = error.stack.replace(/\s+$/g, "").split(`
`);
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0) {
        stack = stack.slice(i);
      }
      return stack;
    }
    CapturedTrace.parseStackAndMessage = function(error) {
      var stack = error.stack;
      var message = error.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
      return {
        message,
        stack: cleanStack(stack)
      };
    };
    CapturedTrace.formatAndLogError = function(error, title) {
      if (typeof console !== "undefined") {
        var message;
        if (typeof error === "object" || typeof error === "function") {
          var stack = error.stack;
          message = title + formatStack(stack, error);
        } else {
          message = title + String(error);
        }
        if (typeof warn === "function") {
          warn(message);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    };
    CapturedTrace.unhandledRejection = function(reason) {
      CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
    };
    CapturedTrace.isSupported = function() {
      return typeof captureStackTrace === "function";
    };
    CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise);
          } else {
            localHandler(reason, promise);
          }
        }
      } catch (e) {
        async.throwLater(e);
      }
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent(name, reason, promise);
      } catch (e) {
        globalEventFired = true;
        async.throwLater(e);
      }
      var domEventFired = false;
      if (fireDomEvent) {
        try {
          domEventFired = fireDomEvent(name.toLowerCase(), {
            reason,
            promise
          });
        } catch (e) {
          domEventFired = true;
          async.throwLater(e);
        }
      }
      if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
      }
    };
    function formatNonError(obj2) {
      var str;
      if (typeof obj2 === "function") {
        str = "[function " + (obj2.name || "anonymous") + "]";
      } else {
        str = obj2.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj2);
            str = newStr;
          } catch (e) {}
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    CapturedTrace.setBounds = function(firstLineError, lastLineError) {
      if (!CapturedTrace.isSupported())
        return;
      var firstStackLines = firstLineError.stack.split(`
`);
      var lastStackLines = lastLineError.stack.split(`
`);
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0;i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0;i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line))
          return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if (error.name !== undefined && error.message !== undefined) {
          return error.toString();
        }
        return formatNonError(error);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit = Error.stackTraceLimit + 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit = Error.stackTraceLimit + 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
      }
      var err = new Error;
      if (typeof err.stack === "string" && err.stack.split(`
`)[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error;
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
          Error.stackTraceLimit = Error.stackTraceLimit + 6;
          try {
            throw new Error;
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
      }
      formatStack = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
          return error.toString();
        }
        return formatNonError(error);
      };
      return null;
    }([]);
    var fireDomEvent;
    var fireGlobalEvent = function() {
      if (util.isNode) {
        return function(name, reason, promise) {
          if (name === "rejectionHandled") {
            return process.emit(name, promise);
          } else {
            return process.emit(name, reason, promise);
          }
        };
      } else {
        var customEventWorks = false;
        var anyEventWorks = true;
        try {
          var ev = new self.CustomEvent("test");
          customEventWorks = ev instanceof CustomEvent;
        } catch (e) {}
        if (!customEventWorks) {
          try {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            self.dispatchEvent(event);
          } catch (e) {
            anyEventWorks = false;
          }
        }
        if (anyEventWorks) {
          fireDomEvent = function(type, detail) {
            var event2;
            if (customEventWorks) {
              event2 = new self.CustomEvent(type, {
                detail,
                bubbles: false,
                cancelable: true
              });
            } else if (self.dispatchEvent) {
              event2 = document.createEvent("CustomEvent");
              event2.initCustomEvent(type, false, true, detail);
            }
            return event2 ? !self.dispatchEvent(event2) : false;
          };
        }
        var toWindowMethodNameMap = {};
        toWindowMethodNameMap["unhandledRejection"] = ("on" + "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" + "rejectionHandled").toLowerCase();
        return function(name, reason, promise) {
          var methodName = toWindowMethodNameMap[name];
          var method = self[methodName];
          if (!method)
            return false;
          if (name === "rejectionHandled") {
            method.call(self, promise);
          } else {
            method.call(self, reason, promise);
          }
          return true;
        };
      }
    }();
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      warn = function(message) {
        console.warn(message);
      };
      if (util.isNode && process.stderr.isTTY) {
        warn = function(message) {
          process.stderr.write("\x1B[31m" + message + `\x1B[39m
`);
        };
      } else if (!util.isNode && typeof new Error().stack === "string") {
        warn = function(message) {
          console.warn("%c" + message, "color: red");
        };
      }
    }
    return CapturedTrace;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/debuggability.js
var require_debuggability = __commonJS((exports, module) => {
  module.exports = function(Promise2, CapturedTrace) {
    var getDomain = Promise2._getDomain;
    var async = require_async2();
    var Warning = require_errors3().Warning;
    var util = require_util2();
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var debugging = util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || process.env["NODE_ENV"] === "development");
    if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0)
      debugging = false;
    if (debugging) {
      async.disableTrampolineIfNecessary();
    }
    Promise2.prototype._ignoreRejections = function() {
      this._unsetRejectionIsUnhandled();
      this._bitField = this._bitField | 16777216;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 16777216) !== 0)
        return;
      this._setRejectionIsUnhandled();
      async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      CapturedTrace.fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._getCarriedStackTrace() || this._settledValue;
        this._setUnhandledRejectionIsNotified();
        CapturedTrace.fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 524288;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & ~524288;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 524288) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 2097152;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & ~2097152;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 2097152) > 0;
    };
    Promise2.prototype._setCarriedStackTrace = function(capturedTrace) {
      this._bitField = this._bitField | 1048576;
      this._fulfillmentHandler0 = capturedTrace;
    };
    Promise2.prototype._isCarryingStackTrace = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._getCarriedStackTrace = function() {
      return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : undefined;
    };
    Promise2.prototype._captureStackTrace = function() {
      if (debugging) {
        this._trace = new CapturedTrace(this._peekContext());
      }
      return this;
    };
    Promise2.prototype._attachExtraTrace = function(error, ignoreSelf) {
      if (debugging && canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
          if (ignoreSelf)
            trace = trace._parent;
        }
        if (trace !== undefined) {
          trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
          var parsed = CapturedTrace.parseStackAndMessage(error);
          util.notEnumerableProp(error, "stack", parsed.message + `
` + parsed.stack.join(`
`));
          util.notEnumerableProp(error, "__stackCleaned__", true);
        }
      }
    };
    Promise2.prototype._warn = function(message) {
      var warning = new Warning(message);
      var ctx = this._peekContext();
      if (ctx) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = CapturedTrace.parseStackAndMessage(warning);
        warning.stack = parsed.message + `
` + parsed.stack.join(`
`);
      }
      CapturedTrace.formatAndLogError(warning, "");
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : undefined;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : undefined;
    };
    Promise2.longStackTraces = function() {
      if (async.haveItemsQueued() && debugging === false) {
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/DT1qyG
`);
      }
      debugging = CapturedTrace.isSupported();
      if (debugging) {
        async.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return debugging && CapturedTrace.isSupported();
    };
    if (!CapturedTrace.isSupported()) {
      Promise2.longStackTraces = function() {};
      debugging = false;
    }
    return function() {
      return debugging;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/context.js
var require_context = __commonJS((exports, module) => {
  module.exports = function(Promise2, CapturedTrace, isDebugging) {
    var contextStack = [];
    function Context() {
      this._trace = new CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (!isDebugging())
        return;
      if (this._trace !== undefined) {
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (!isDebugging())
        return;
      if (this._trace !== undefined) {
        contextStack.pop();
      }
    };
    function createContext() {
      if (isDebugging())
        return new Context;
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return;
    }
    Promise2.prototype._peekContext = peekContext;
    Promise2.prototype._pushContext = Context.prototype._pushContext;
    Promise2.prototype._popContext = Context.prototype._popContext;
    return createContext;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/catch_filter.js
var require_catch_filter = __commonJS((exports, module) => {
  module.exports = function(NEXT_FILTER) {
    var util = require_util2();
    var errors = require_errors3();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var keys = require_es5().keys;
    var TypeError2 = errors.TypeError;
    function CatchFilter(instances, callback, promise) {
      this._instances = instances;
      this._callback = callback;
      this._promise = promise;
    }
    function safePredicate(predicate, e) {
      var safeObject = {};
      var retfilter = tryCatch(predicate).call(safeObject, e);
      if (retfilter === errorObj)
        return retfilter;
      var safeKeys = keys(safeObject);
      if (safeKeys.length) {
        errorObj.e = new TypeError2(`Catch filter must inherit from Error or be a simple predicate function

    See http://goo.gl/o84o68
`);
        return errorObj;
      }
      return retfilter;
    }
    CatchFilter.prototype.doFilter = function(e) {
      var cb = this._callback;
      var promise = this._promise;
      var boundTo = promise._boundValue();
      for (var i = 0, len = this._instances.length;i < len; ++i) {
        var item = this._instances[i];
        var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
        if (itemIsErrorType && e instanceof item) {
          var ret = tryCatch(cb).call(boundTo, e);
          if (ret === errorObj) {
            NEXT_FILTER.e = ret.e;
            return NEXT_FILTER;
          }
          return ret;
        } else if (typeof item === "function" && !itemIsErrorType) {
          var shouldHandle = safePredicate(item, e);
          if (shouldHandle === errorObj) {
            e = errorObj.e;
            break;
          } else if (shouldHandle) {
            var ret = tryCatch(cb).call(boundTo, e);
            if (ret === errorObj) {
              NEXT_FILTER.e = ret.e;
              return NEXT_FILTER;
            }
            return ret;
          }
        }
      }
      NEXT_FILTER.e = e;
      return NEXT_FILTER;
    };
    return CatchFilter;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/promise_resolver.js
var require_promise_resolver = __commonJS((exports, module) => {
  var util = require_util2();
  var maybeWrapAsError = util.maybeWrapAsError;
  var errors = require_errors3();
  var TimeoutError = errors.TimeoutError;
  var OperationalError = errors.OperationalError;
  var haveGetters = util.haveGetters;
  var es5 = require_es5();
  function isUntypedError(obj2) {
    return obj2 instanceof Error && es5.getPrototypeOf(obj2) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj2) {
    var ret;
    if (isUntypedError(obj2)) {
      ret = new OperationalError(obj2);
      ret.name = obj2.name;
      ret.message = obj2.message;
      ret.stack = obj2.stack;
      var keys = es5.keys(obj2);
      for (var i = 0;i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj2[key];
        }
      }
      return ret;
    }
    util.markAsOriginatingFromRejection(obj2);
    return obj2;
  }
  function nodebackForPromise(promise) {
    return function(err, value) {
      if (promise === null)
        return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise._attachExtraTrace(wrapped);
        promise._reject(wrapped);
      } else if (arguments.length > 2) {
        var $_len = arguments.length;
        var args = new Array($_len - 1);
        for (var $_i = 1;$_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise._fulfill(args);
      } else {
        promise._fulfill(value);
      }
      promise = null;
    };
  }
  var PromiseResolver;
  if (!haveGetters) {
    PromiseResolver = function(promise) {
      this.promise = promise;
      this.asCallback = nodebackForPromise(promise);
      this.callback = this.asCallback;
    };
  } else {
    PromiseResolver = function(promise) {
      this.promise = promise;
    };
  }
  if (haveGetters) {
    prop = {
      get: function() {
        return nodebackForPromise(this.promise);
      }
    };
    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
  }
  var prop;
  PromiseResolver._nodebackForPromise = nodebackForPromise;
  PromiseResolver.prototype.toString = function() {
    return "[object PromiseResolver]";
  };
  PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
    if (!(this instanceof PromiseResolver)) {
      throw new TypeError(`Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.

    See http://goo.gl/sdkXL9
`);
    }
    this.promise._resolveCallback(value);
  };
  PromiseResolver.prototype.reject = function(reason) {
    if (!(this instanceof PromiseResolver)) {
      throw new TypeError(`Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.

    See http://goo.gl/sdkXL9
`);
    }
    this.promise._rejectCallback(reason);
  };
  PromiseResolver.prototype.progress = function(value) {
    if (!(this instanceof PromiseResolver)) {
      throw new TypeError(`Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.

    See http://goo.gl/sdkXL9
`);
    }
    this.promise._progress(value);
  };
  PromiseResolver.prototype.cancel = function(err) {
    this.promise.cancel(err);
  };
  PromiseResolver.prototype.timeout = function() {
    this.reject(new TimeoutError("timeout"));
  };
  PromiseResolver.prototype.isResolved = function() {
    return this.promise.isResolved();
  };
  PromiseResolver.prototype.toJSON = function() {
    return this.promise.toJSON();
  };
  module.exports = PromiseResolver;
});

// node_modules/stream-length/node_modules/bluebird/js/main/progress.js
var require_progress = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray) {
    var util = require_util2();
    var async = require_async2();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    Promise2.prototype.progressed = function(handler) {
      return this._then(undefined, undefined, handler, undefined, undefined);
    };
    Promise2.prototype._progress = function(progressValue) {
      if (this._isFollowingOrFulfilledOrRejected())
        return;
      this._target()._progressUnchecked(progressValue);
    };
    Promise2.prototype._progressHandlerAt = function(index) {
      return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
    };
    Promise2.prototype._doProgressWith = function(progression) {
      var progressValue = progression.value;
      var handler = progression.handler;
      var promise = progression.promise;
      var receiver = progression.receiver;
      var ret = tryCatch(handler).call(receiver, progressValue);
      if (ret === errorObj) {
        if (ret.e != null && ret.e.name !== "StopProgressPropagation") {
          var trace = util.canAttachTrace(ret.e) ? ret.e : new Error(util.toString(ret.e));
          promise._attachExtraTrace(trace);
          promise._progress(ret.e);
        }
      } else if (ret instanceof Promise2) {
        ret._then(promise._progress, null, null, promise, undefined);
      } else {
        promise._progress(ret);
      }
    };
    Promise2.prototype._progressUnchecked = function(progressValue) {
      var len = this._length();
      var progress = this._progress;
      for (var i = 0;i < len; i++) {
        var handler = this._progressHandlerAt(i);
        var promise = this._promiseAt(i);
        if (!(promise instanceof Promise2)) {
          var receiver = this._receiverAt(i);
          if (typeof handler === "function") {
            handler.call(receiver, progressValue, promise);
          } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
            receiver._promiseProgressed(progressValue, promise);
          }
          continue;
        }
        if (typeof handler === "function") {
          async.invoke(this._doProgressWith, this, {
            handler,
            promise,
            receiver: this._receiverAt(i),
            value: progressValue
          });
        } else {
          async.invoke(progress, promise, progressValue);
        }
      }
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/method.js
var require_method = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = require_util2();
    var tryCatch = util.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError(`fn must be a function

    See http://goo.gl/916lJJ
`);
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn, args, ctx) {
      if (typeof fn !== "function") {
        return apiRejection(`fn must be a function

    See http://goo.gl/916lJJ
`);
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value = util.isArray(args) ? tryCatch(fn).apply(ctx, args) : tryCatch(fn).call(ctx, args);
      ret._popContext();
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util.errorObj) {
        this._rejectCallback(value.e, false, true);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/bind.js
var require_bind = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise) {
    var rejectThis = function(_, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context) {
      context.promiseRejectionQueued = true;
      context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context) {
      if (this._isPending()) {
        this._resolveCallback(context.target);
      }
    };
    var bindingRejected = function(e, context) {
      if (!context.promiseRejectionQueued)
        this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
        maybePromise._then(bindingResolved, bindingRejected, ret._progress, ret, context);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj2) {
      if (obj2 !== undefined) {
        this._bitField = this._bitField | 131072;
        this._boundTo = obj2;
      } else {
        this._bitField = this._bitField & ~131072;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 131072) === 131072;
    };
    Promise2.bind = function(thisArg, value) {
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        maybePromise._then(function() {
          ret._resolveCallback(value);
        }, ret._reject, ret._progress, ret, null);
      } else {
        ret._resolveCallback(value);
      }
      return ret;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/finally.js
var require_finally = __commonJS((exports, module) => {
  module.exports = function(Promise2, NEXT_FILTER, tryConvertToPromise) {
    var util = require_util2();
    var isPrimitive = util.isPrimitive;
    var thrower = util.thrower;
    function returnThis() {
      return this;
    }
    function throwThis() {
      throw this;
    }
    function return$(r) {
      return function() {
        return r;
      };
    }
    function throw$(r) {
      return function() {
        throw r;
      };
    }
    function promisedFinally(ret, reasonOrValue, isFulfilled) {
      var then;
      if (isPrimitive(reasonOrValue)) {
        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
      } else {
        then = isFulfilled ? returnThis : throwThis;
      }
      return ret._then(then, thrower, undefined, reasonOrValue, undefined);
    }
    function finallyHandler(reasonOrValue) {
      var promise = this.promise;
      var handler = this.handler;
      var ret = promise._isBound() ? handler.call(promise._boundValue()) : handler();
      if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());
        }
      }
      if (promise.isRejected()) {
        NEXT_FILTER.e = reasonOrValue;
        return NEXT_FILTER;
      } else {
        return reasonOrValue;
      }
    }
    function tapHandler(value) {
      var promise = this.promise;
      var handler = this.handler;
      var ret = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
      if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          return promisedFinally(maybePromise, value, true);
        }
      }
      return value;
    }
    Promise2.prototype._passThroughHandler = function(handler, isFinally) {
      if (typeof handler !== "function")
        return this.then();
      var promiseAndHandler = {
        promise: this,
        handler
      };
      return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : undefined, undefined, promiseAndHandler, undefined);
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThroughHandler(handler, true);
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThroughHandler(handler, false);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/direct_resolve.js
var require_direct_resolve = __commonJS((exports, module) => {
  var util = require_util2();
  var isPrimitive = util.isPrimitive;
  module.exports = function(Promise2) {
    var returner = function() {
      return this;
    };
    var thrower = function() {
      throw this;
    };
    var returnUndefined = function() {};
    var throwUndefined = function() {
      throw undefined;
    };
    var wrapper = function(value, action) {
      if (action === 1) {
        return function() {
          throw value;
        };
      } else if (action === 2) {
        return function() {
          return value;
        };
      }
    };
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value === undefined)
        return this.then(returnUndefined);
      if (isPrimitive(value)) {
        return this._then(wrapper(value, 2), undefined, undefined, undefined, undefined);
      } else if (value instanceof Promise2) {
        value._ignoreRejections();
      }
      return this._then(returner, undefined, undefined, value, undefined);
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      if (reason === undefined)
        return this.then(throwUndefined);
      if (isPrimitive(reason)) {
        return this._then(wrapper(reason, 1), undefined, undefined, undefined, undefined);
      }
      return this._then(thrower, undefined, undefined, reason, undefined);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/synchronous_inspection.js
var require_synchronous_inspection = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    function PromiseInspection(promise) {
      if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValue = promise._settledValue;
      } else {
        this._bitField = 0;
        this._settledValue = undefined;
      }
    }
    PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/hc1DLj
`);
      }
      return this._settledValue;
    };
    PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/hPuiwB
`);
      }
      return this._settledValue;
    };
    PromiseInspection.prototype.isFulfilled = Promise2.prototype._isFulfilled = function() {
      return (this._bitField & 268435456) > 0;
    };
    PromiseInspection.prototype.isRejected = Promise2.prototype._isRejected = function() {
      return (this._bitField & 134217728) > 0;
    };
    PromiseInspection.prototype.isPending = Promise2.prototype._isPending = function() {
      return (this._bitField & 402653184) === 0;
    };
    PromiseInspection.prototype.isResolved = Promise2.prototype._isResolved = function() {
      return (this._bitField & 402653184) > 0;
    };
    Promise2.prototype.isPending = function() {
      return this._target()._isPending();
    };
    Promise2.prototype.isRejected = function() {
      return this._target()._isRejected();
    };
    Promise2.prototype.isFulfilled = function() {
      return this._target()._isFulfilled();
    };
    Promise2.prototype.isResolved = function() {
      return this._target()._isResolved();
    };
    Promise2.prototype._value = function() {
      return this._settledValue;
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue;
    };
    Promise2.prototype.value = function() {
      var target = this._target();
      if (!target.isFulfilled()) {
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/hc1DLj
`);
      }
      return target._settledValue;
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      if (!target.isRejected()) {
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/hPuiwB
`);
      }
      target._unsetRejectionIsUnhandled();
      return target._settledValue;
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/join.js
var require_join = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL) {
    var util = require_util2();
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    if (true) {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", `                             
            'use strict';                                                    
            holder.pIndex = value;                                           
            holder.checkFulfillment(this);                                   
            `.replace(/Index/g, i2));
        };
        var caller = function(count) {
          var values = [];
          for (var i2 = 1;i2 <= count; ++i2)
            values.push("holder.p" + i2);
          return new Function("holder", `                                      
            'use strict';                                                    
            var callback = holder.fn;                                        
            return callback(values);                                         
            `.replace(/values/g, values.join(", ")));
        };
        var thenCallbacks = [];
        var callers = [undefined];
        for (var i = 1;i <= 5; ++i) {
          thenCallbacks.push(thenCallback(i));
          callers.push(caller(i));
        }
        var Holder = function(total, fn) {
          this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
          this.fn = fn;
          this.total = total;
          this.now = 0;
        };
        Holder.prototype.callers = callers;
        Holder.prototype.checkFulfillment = function(promise) {
          var now = this.now;
          now++;
          var total = this.total;
          if (now >= total) {
            var handler = this.callers[total];
            promise._pushContext();
            var ret = tryCatch(handler)(this);
            promise._popContext();
            if (ret === errorObj) {
              promise._rejectCallback(ret.e, false, true);
            } else {
              promise._resolveCallback(ret);
            }
          } else {
            this.now = now;
          }
        };
        var reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (true) {
          if (last < 6 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var holder = new Holder(last, fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0;i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  maybePromise._then(callbacks[i2], reject, undefined, ret, holder);
                } else if (maybePromise._isFulfilled()) {
                  callbacks[i2].call(ret, maybePromise._value(), holder);
                } else {
                  ret._reject(maybePromise._reason());
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0;$_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn)
        args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== undefined ? ret.spread(fn) : ret;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/map.js
var require_map = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
    var getDomain = Promise2._getDomain;
    var async = require_async2();
    var util = require_util2();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var PENDING = {};
    var EMPTY_ARRAY = [];
    function MappingPromiseArray(promises, fn, limit, _filter) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : domain.bind(fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
      async.invoke(init, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    function init() {
      this._init$(undefined, -2);
    }
    MappingPromiseArray.prototype._init = function() {};
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (values[index] === PENDING) {
        values[index] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved())
            return;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values[index] = value;
          this._queue.push(index);
          return;
        }
        if (preservedValues !== null)
          preservedValues[index] = value;
        var callback = this._callback;
        var receiver = this._promise._boundValue();
        this._promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        this._promise._popContext();
        if (ret === errorObj)
          return this._reject(ret.e);
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          if (maybePromise._isPending()) {
            if (limit >= 1)
              this._inFlight++;
            values[index] = PENDING;
            return maybePromise._proxyPromiseArray(this, index);
          } else if (maybePromise._isFulfilled()) {
            ret = maybePromise._value();
          } else {
            return this._reject(maybePromise._reason());
          }
        }
        values[index] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
      }
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue = this._queue;
      var limit = this._limit;
      var values = this._values;
      while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved())
          return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0;i < len; ++i) {
        if (booleans[i])
          ret[j++] = values[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map(promises, fn, options, _filter) {
      var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises, fn, limit, _filter);
    }
    Promise2.prototype.map = function(fn, options) {
      if (typeof fn !== "function")
        return apiRejection(`fn must be a function

    See http://goo.gl/916lJJ
`);
      return map(this, fn, options, null).promise();
    };
    Promise2.map = function(promises, fn, options, _filter) {
      if (typeof fn !== "function")
        return apiRejection(`fn must be a function

    See http://goo.gl/916lJJ
`);
      return map(promises, fn, options, _filter).promise();
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/cancel.js
var require_cancel = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var errors = require_errors3();
    var async = require_async2();
    var CancellationError = errors.CancellationError;
    Promise2.prototype._cancel = function(reason) {
      if (!this.isCancellable())
        return this;
      var parent;
      var promiseToReject = this;
      while ((parent = promiseToReject._cancellationParent) !== undefined && parent.isCancellable()) {
        promiseToReject = parent;
      }
      this._unsetCancellable();
      promiseToReject._target()._rejectCallback(reason, false, true);
    };
    Promise2.prototype.cancel = function(reason) {
      if (!this.isCancellable())
        return this;
      if (reason === undefined)
        reason = new CancellationError;
      async.invokeLater(this._cancel, this, reason);
      return this;
    };
    Promise2.prototype.cancellable = function() {
      if (this._cancellable())
        return this;
      async.enableTrampoline();
      this._setCancellable();
      this._cancellationParent = undefined;
      return this;
    };
    Promise2.prototype.uncancellable = function() {
      var ret = this.then();
      ret._unsetCancellable();
      return ret;
    };
    Promise2.prototype.fork = function(didFulfill, didReject, didProgress) {
      var ret = this._then(didFulfill, didReject, didProgress, undefined, undefined);
      ret._setCancellable();
      ret._cancellationParent = undefined;
      return ret;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/using.js
var require_using = __commonJS((exports, module) => {
  module.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext) {
    var TypeError2 = require_errors3().TypeError;
    var inherits = require_util2().inherits;
    var PromiseInspection = Promise2.PromiseInspection;
    function inspectionMapper(inspections) {
      var len = inspections.length;
      for (var i = 0;i < len; ++i) {
        var inspection = inspections[i];
        if (inspection.isRejected()) {
          return Promise2.reject(inspection.error());
        }
        inspections[i] = inspection._settledValue;
      }
      return inspections;
    }
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = Promise2.defer();
      function iterator() {
        if (i >= len)
          return ret.resolve();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(iterator, thrower, null, null, null);
          }
        }
        iterator();
      }
      iterator();
      return ret.promise;
    }
    function disposerSuccess(value) {
      var inspection = new PromiseInspection;
      inspection._settledValue = value;
      inspection._bitField = 268435456;
      return dispose(this, inspection).thenReturn(value);
    }
    function disposerFail(reason) {
      var inspection = new PromiseInspection;
      inspection._settledValue = reason;
      inspection._bitField = 134217728;
      return dispose(this, inspection).thenThrow(reason);
    }
    function Disposer(data, promise, context) {
      this._data = data;
      this._promise = promise;
      this._context = context;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return null;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context = this._context;
      if (context !== undefined)
        context._pushContext();
      var ret = resource !== null ? this.doDispose(resource, inspection) : null;
      if (context !== undefined)
        context._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise, context) {
      this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2)
        return apiRejection("you must pass at least 2 arguments to Promise.using");
      var fn = arguments[len - 1];
      if (typeof fn !== "function")
        return apiRejection(`fn must be a function

    See http://goo.gl/916lJJ
`);
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new Array(len);
      for (var i = 0;i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, undefined);
          }
        }
        resources[i] = resource;
      }
      var promise = Promise2.settle(resources).then(inspectionMapper).then(function(vals) {
        promise._pushContext();
        var ret;
        try {
          ret = spreadArgs ? fn.apply(undefined, vals) : fn.call(undefined, vals);
        } finally {
          promise._popContext();
        }
        return ret;
      })._then(disposerSuccess, disposerFail, undefined, resources, undefined);
      resources.promise = promise;
      return promise;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 262144;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & ~262144;
      this._disposer = undefined;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/generators.js
var require_generators = __commonJS((exports, module) => {
  module.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise) {
    var errors = require_errors3();
    var TypeError2 = errors.TypeError;
    var util = require_util2();
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0;i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2)
          return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      var promise = this._promise = new Promise2(INTERNAL);
      promise._captureStackTrace();
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = undefined;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
    }
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = undefined;
      this._next(undefined);
    };
    PromiseSpawn.prototype._continue = function(result) {
      if (result === errorObj) {
        return this._promise._rejectCallback(result.e, false, true);
      }
      var value = result.value;
      if (result.done === true) {
        this._promise._resolveCallback(value);
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
          if (maybePromise === null) {
            this._throw(new TypeError2(`A value %s was yielded that could not be treated as a promise

    See http://goo.gl/4Y4pDk

`.replace("%s", value) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)));
            return;
          }
        }
        maybePromise._then(this._next, this._throw, undefined, this, null);
      }
    };
    PromiseSpawn.prototype._throw = function(reason) {
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._next = function(value) {
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2(`generatorFunction must be a function

    See http://goo.gl/6Vqhm0
`);
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
        spawn._generator = generator;
        spawn._next(undefined);
        return spawn.promise();
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError2(`fn must be a function

    See http://goo.gl/916lJJ
`);
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      if (typeof generatorFunction !== "function") {
        return apiRejection(`generatorFunction must be a function

    See http://goo.gl/6Vqhm0
`);
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/nodeify.js
var require_nodeify = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var util = require_util2();
    var async = require_async2();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function spreadAdapter(val, nodeback) {
      var promise = this;
      if (!util.isArray(val))
        return successAdapter.call(promise, val, nodeback);
      var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback) {
      var promise = this;
      var receiver = promise._boundValue();
      var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback) {
      var promise = this;
      if (!reason) {
        var target = promise._target();
        var newReason = target._getCarriedStackTrace();
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
      if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(adapter, errorAdapter, undefined, this, nodeback);
      }
      return this;
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/call_get.js
var require_call_get = __commonJS((exports, module) => {
  var cr = Object.create;
  if (cr) {
    callerCache = cr(null);
    getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  var callerCache;
  var getterCache;
  module.exports = function(Promise2) {
    var util = require_util2();
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    var getMethodCaller;
    var getGetter;
    if (true) {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", `                                    
        return function(obj) {                                               
            'use strict'                                                     
            var len = this.length;                                           
            ensureMethod(obj, 'methodName');                                 
            switch(len) {                                                    
                case 1: return obj.methodName(this[0]);                      
                case 2: return obj.methodName(this[0], this[1]);             
                case 3: return obj.methodName(this[0], this[1], this[2]);    
                case 0: return obj.methodName();                             
                default:                                                     
                    return obj.methodName.apply(obj, this);                  
            }                                                                
        };                                                                   
        `.replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", `                                             
        'use strict';                                                        
        return obj.propertyName;                                             
        `.replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0;i < 256; ++i)
              delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj2, methodName) {
      var fn;
      if (obj2 != null)
        fn = obj2[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj2) {
      var methodName = this.pop();
      var fn = ensureMethod(obj2, methodName);
      return fn.apply(obj2, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array($_len - 1);
      for (var $_i = 1;$_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      if (true) {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(maybeCaller, undefined, undefined, args, undefined);
          }
        }
      }
      args.push(methodName);
      return this._then(caller, undefined, undefined, args, undefined);
    };
    function namedGetter(obj2) {
      return obj2[this];
    }
    function indexedGetter(obj2) {
      var index = +this;
      if (index < 0)
        index = Math.max(0, index + obj2.length);
      return obj2[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, undefined, undefined, propertyName, undefined);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/props.js
var require_props = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util = require_util2();
    var isObject = util.isObject;
    var es5 = require_es5();
    function PropertiesPromiseArray(obj2) {
      var keys = es5.keys(obj2);
      var len = keys.length;
      var values = new Array(len * 2);
      for (var i = 0;i < len; ++i) {
        var key = keys[i];
        values[i] = obj2[key];
        values[i + len] = key;
      }
      this.constructor$(values);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
      this._init$(undefined, -3);
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val = {};
        var keyOffset = this.length();
        for (var i = 0, len = this.length();i < len; ++i) {
          val[this._values[i + keyOffset]] = this._values[i];
        }
        this._resolve(val);
      }
    };
    PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
      this._promise._progress({
        key: this._values[index + this.length()],
        value
      });
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject(castValue)) {
        return apiRejection(`cannot await properties of a non-object

    See http://goo.gl/OsFKC8
`);
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(Promise2.props, undefined, undefined, undefined, undefined);
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 4);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props(this);
    };
    Promise2.props = function(promises) {
      return props(promises);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/race.js
var require_race = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var isArray = require_util2().isArray;
    var raceLater = function(promise) {
      return promise.then(function(array) {
        return race(array, promise);
      });
    };
    function race(promises, parent) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else if (!isArray(promises)) {
        return apiRejection(`expecting an array, a promise or a thenable

    See http://goo.gl/s8MMhc
`);
      }
      var ret = new Promise2(INTERNAL);
      if (parent !== undefined) {
        ret._propagateFrom(parent, 4 | 1);
      }
      var fulfill = ret._fulfill;
      var reject = ret._reject;
      for (var i = 0, len = promises.length;i < len; ++i) {
        var val = promises[i];
        if (val === undefined && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, undefined, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race(promises, undefined);
    };
    Promise2.prototype.race = function() {
      return race(this, undefined);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/reduce.js
var require_reduce = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
    var getDomain = Promise2._getDomain;
    var async = require_async2();
    var util = require_util2();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function ReductionPromiseArray(promises, fn, accum, _each) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      this._preservedValues = _each === INTERNAL ? [] : null;
      this._zerothIsAccum = accum === undefined;
      this._gotAccum = false;
      this._reducingIndex = this._zerothIsAccum ? 1 : 0;
      this._valuesPhase = undefined;
      var maybePromise = tryConvertToPromise(accum, this._promise);
      var rejected = false;
      var isPromise = maybePromise instanceof Promise2;
      if (isPromise) {
        maybePromise = maybePromise._target();
        if (maybePromise._isPending()) {
          maybePromise._proxyPromiseArray(this, -1);
        } else if (maybePromise._isFulfilled()) {
          accum = maybePromise._value();
          this._gotAccum = true;
        } else {
          this._reject(maybePromise._reason());
          rejected = true;
        }
      }
      if (!(isPromise || this._zerothIsAccum))
        this._gotAccum = true;
      var domain = getDomain();
      this._callback = domain === null ? fn : domain.bind(fn);
      this._accum = accum;
      if (!rejected)
        async.invoke(init, this, undefined);
    }
    function init() {
      this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._init = function() {};
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      if (this._gotAccum || this._zerothIsAccum) {
        this._resolve(this._preservedValues !== null ? [] : this._accum);
      }
    };
    ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values = this._values;
      values[index] = value;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var isEach = preservedValues !== null;
      var gotAccum = this._gotAccum;
      var valuesPhase = this._valuesPhase;
      var valuesPhaseIndex;
      if (!valuesPhase) {
        valuesPhase = this._valuesPhase = new Array(length);
        for (valuesPhaseIndex = 0;valuesPhaseIndex < length; ++valuesPhaseIndex) {
          valuesPhase[valuesPhaseIndex] = 0;
        }
      }
      valuesPhaseIndex = valuesPhase[index];
      if (index === 0 && this._zerothIsAccum) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
        valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;
      } else if (index === -1) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
      } else {
        if (valuesPhaseIndex === 0) {
          valuesPhase[index] = 1;
        } else {
          valuesPhase[index] = 2;
          this._accum = value;
        }
      }
      if (!gotAccum)
        return;
      var callback = this._callback;
      var receiver = this._promise._boundValue();
      var ret;
      for (var i = this._reducingIndex;i < length; ++i) {
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) {
          this._reducingIndex = i + 1;
          continue;
        }
        if (valuesPhaseIndex !== 1)
          return;
        value = values[i];
        this._promise._pushContext();
        if (isEach) {
          preservedValues.push(value);
          ret = tryCatch(callback).call(receiver, value, i, length);
        } else {
          ret = tryCatch(callback).call(receiver, this._accum, value, i, length);
        }
        this._promise._popContext();
        if (ret === errorObj)
          return this._reject(ret.e);
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          if (maybePromise._isPending()) {
            valuesPhase[i] = 4;
            return maybePromise._proxyPromiseArray(this, i);
          } else if (maybePromise._isFulfilled()) {
            ret = maybePromise._value();
          } else {
            return this._reject(maybePromise._reason());
          }
        }
        this._reducingIndex = i + 1;
        this._accum = ret;
      }
      this._resolve(isEach ? preservedValues : this._accum);
    };
    function reduce(promises, fn, initialValue, _each) {
      if (typeof fn !== "function")
        return apiRejection(`fn must be a function

    See http://goo.gl/916lJJ
`);
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce(promises, fn, initialValue, _each);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/settle.js
var require_settle = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util = require_util2();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
      }
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret = new PromiseInspection;
      ret._bitField = 268435456;
      ret._settledValue = value;
      this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret = new PromiseInspection;
      ret._bitField = 134217728;
      ret._settledValue = reason;
      this._promiseResolved(index, ret);
    };
    Promise2.settle = function(promises) {
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return new SettledPromiseArray(this).promise();
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/some.js
var require_some = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection) {
    var util = require_util2();
    var RangeError2 = require_errors3().RangeError;
    var AggregateError = require_errors3().AggregateError;
    var isArray = util.isArray;
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(undefined, -5);
      var isArrayResolved = isArray(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
      }
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError;
        for (var i = this.length();i < this._values.length; ++i) {
          e.push(this._values[i]);
        }
        this._reject(e);
      }
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection(`expecting a positive integer

    See http://goo.gl/1wAmHx
`);
      }
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise;
    }
    Promise2.some = function(promises, howMany) {
      return some(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/promisify.js
var require_promisify = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var THIS = {};
    var util = require_util2();
    var nodebackForPromise = require_promise_resolver()._nodebackForPromise;
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError2 = require_errors3().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj2, key, suffix) {
      var val = util.getDataPropertyOrDefault(obj2, key + suffix, defaultPromisified);
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0;i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0;j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/iWrZbw
`.replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
      var keys = util.inheritedDataKeys(obj2);
      var ret = [];
      for (var i = 0;i < keys.length; ++i) {
        var key = keys[i];
        var value = obj2[key];
        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    if (true) {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1;i >= min; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1;i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util.filledRange(Math.max(parameterCount2, 3), "_arg", "");
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = `ret = callback.call(this, {{args}}, nodeback); break;
`;
          } else {
            ret = receiver === undefined ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`;
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0;i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += `                                                             
        default:                                                             
            var args = new Array(len + 1);                                   
            var i = 0;                                                       
            for (var i = 0; i < len; ++i) {                                  
               args[i] = arguments[i];                                       
            }                                                                
            args[i] = nodeback;                                              
            [CodeForCall]                                                    
            break;                                                           
        `.replace("[CodeForCall]", shouldProxyThis ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`);
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", `'use strict';                            
        var ret = function (Parameters) {                                    
            'use strict';                                                    
            var len = arguments.length;                                      
            var promise = new Promise(INTERNAL);                             
            promise._captureStackTrace();                                    
            var nodeback = nodebackForPromise(promise);                      
            var ret;                                                         
            var callback = tryCatch([GetFunctionCode]);                      
            switch(len) {                                                    
                [CodeForSwitchCase]                                          
            }                                                                
            if (ret === errorObj) {                                          
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
            }                                                                
            return promise;                                                  
        };                                                                   
        notEnumerableProp(ret, '__isPromisified__', true);                   
        return ret;                                                          
        `.replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode))(Promise2, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _, fn) {
      var defaultThis = function() {
        return this;
      }();
      var method = callback;
      if (typeof method === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS)
          _receiver = this;
        var promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
        var fn2 = nodebackForPromise(promise);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        return promise;
      }
      util.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj2, suffix, filter, promisifier) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
      for (var i = 0, len = methods.length;i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(key, THIS, key, fn, suffix);
          });
          util.notEnumerableProp(promisified, "__isPromisified__", true);
          obj2[promisifiedKey] = promisified;
        }
      }
      util.toFastProperties(obj2);
      return obj2;
    }
    function promisify(callback, receiver) {
      return makeNodePromisified(callback, receiver, undefined, callback);
    }
    Promise2.promisify = function(fn, receiver) {
      if (typeof fn !== "function") {
        throw new TypeError2(`fn must be a function

    See http://goo.gl/916lJJ
`);
      }
      if (isPromisified(fn)) {
        return fn;
      }
      var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
      util.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2(`the target of promisifyAll must be an object or a function

    See http://goo.gl/9ITlV0
`);
      }
      options = Object(options);
      var suffix = options.suffix;
      if (typeof suffix !== "string")
        suffix = defaultSuffix;
      var filter = options.filter;
      if (typeof filter !== "function")
        filter = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function")
        promisifier = makeNodePromisified;
      if (!util.isIdentifier(suffix)) {
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/8FZo5V
`);
      }
      var keys = util.inheritedDataKeys(target);
      for (var i = 0;i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util.isClass(value)) {
          promisifyAll(value.prototype, suffix, filter, promisifier);
          promisifyAll(value, suffix, filter, promisifier);
        }
      }
      return promisifyAll(target, suffix, filter, promisifier);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/any.js
var require_any = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any(promises) {
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise;
    }
    Promise2.any = function(promises) {
      return any(promises);
    };
    Promise2.prototype.any = function() {
      return any(this);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/each.js
var require_each = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, null, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, null, INTERNAL);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/timers.js
var require_timers = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var util = require_util2();
    var TimeoutError = Promise2.TimeoutError;
    var afterTimeout = function(promise, message) {
      if (!promise.isPending())
        return;
      var err;
      if (!util.isPrimitive(message) && message instanceof Error) {
        err = message;
      } else {
        if (typeof message !== "string") {
          message = "operation timed out";
        }
        err = new TimeoutError(message);
      }
      util.markAsOriginatingFromRejection(err);
      promise._attachExtraTrace(err);
      promise._cancel(err);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(value, ms) {
      if (ms === undefined) {
        ms = value;
        value = undefined;
        var ret = new Promise2(INTERNAL);
        setTimeout(function() {
          ret._fulfill();
        }, ms);
        return ret;
      }
      ms = +ms;
      return Promise2.resolve(value)._then(afterValue, null, null, ms, undefined);
    };
    Promise2.prototype.delay = function(ms) {
      return delay(this, ms);
    };
    function successClear(value) {
      var handle = this;
      if (handle instanceof Number)
        handle = +handle;
      clearTimeout(handle);
      return value;
    }
    function failureClear(reason) {
      var handle = this;
      if (handle instanceof Number)
        handle = +handle;
      clearTimeout(handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret = this.then().cancellable();
      ret._cancellationParent = this;
      var handle = setTimeout(function timeoutTimeout() {
        afterTimeout(ret, message);
      }, ms);
      return ret._then(successClear, failureClear, undefined, handle, undefined);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/filter.js
var require_filter = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/promise.js
var require_promise = __commonJS((exports, module) => {
  module.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2(`circular promise resolution chain

    See http://goo.gl/LhFpo0
`);
    };
    var reflect = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
      return Promise2.reject(new TypeError2(msg));
    };
    var util = require_util2();
    var getDomain;
    if (util.isNode) {
      getDomain = function() {
        var ret = process.domain;
        if (ret === undefined)
          ret = null;
        return ret;
      };
    } else {
      getDomain = function() {
        return null;
      };
    }
    util.notEnumerableProp(Promise2, "_getDomain", getDomain);
    var UNDEFINED_BINDING = {};
    var async = require_async2();
    var errors = require_errors3();
    var TypeError2 = Promise2.TypeError = errors.TypeError;
    Promise2.RangeError = errors.RangeError;
    Promise2.CancellationError = errors.CancellationError;
    Promise2.TimeoutError = errors.TimeoutError;
    Promise2.OperationalError = errors.OperationalError;
    Promise2.RejectionError = errors.OperationalError;
    Promise2.AggregateError = errors.AggregateError;
    var INTERNAL = function() {};
    var APPLY = {};
    var NEXT_FILTER = { e: null };
    var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
    var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    var CapturedTrace = require_captured_trace()();
    var isDebugging = require_debuggability()(Promise2, CapturedTrace);
    var createContext = require_context()(Promise2, CapturedTrace, isDebugging);
    var CatchFilter = require_catch_filter()(NEXT_FILTER);
    var PromiseResolver = require_promise_resolver();
    var nodebackForPromise = PromiseResolver._nodebackForPromise;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError2(`the promise constructor requires a resolver function

    See http://goo.gl/EC22Yn
`);
      }
      if (this.constructor !== Promise2) {
        throw new TypeError2(`the promise constructor cannot be invoked directly

    See http://goo.gl/KsIlge
`);
      }
      this._bitField = 0;
      this._fulfillmentHandler0 = undefined;
      this._rejectionHandler0 = undefined;
      this._progressHandler0 = undefined;
      this._promise0 = undefined;
      this._receiver0 = undefined;
      this._settledValue = undefined;
      if (resolver !== INTERNAL)
        this._resolveFromResolver(resolver);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0;i < len - 1; ++i) {
          var item = arguments[i];
          if (typeof item === "function") {
            catchInstances[j++] = item;
          } else {
            return Promise2.reject(new TypeError2(`Catch filter must inherit from Error or be a simple predicate function

    See http://goo.gl/o84o68
`));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        var catchFilter = new CatchFilter(catchInstances, fn, this);
        return this._then(undefined, catchFilter.doFilter, undefined, catchFilter, undefined);
      }
      return this._then(undefined, fn, undefined, undefined, undefined);
    };
    Promise2.prototype.reflect = function() {
      return this._then(reflect, reflect, undefined, this, undefined);
    };
    Promise2.prototype.then = function(didFulfill, didReject, didProgress) {
      if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
        if (arguments.length > 1) {
          msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
      }
      return this._then(didFulfill, didReject, didProgress, undefined, undefined);
    };
    Promise2.prototype.done = function(didFulfill, didReject, didProgress) {
      var promise = this._then(didFulfill, didReject, didProgress, undefined, undefined);
      promise._setIsFinal();
    };
    Promise2.prototype.spread = function(didFulfill, didReject) {
      return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
    };
    Promise2.prototype.isCancellable = function() {
      return !this.isResolved() && this._cancellable();
    };
    Promise2.prototype.toJSON = function() {
      var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
      };
      if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
      } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
      }
      return ret;
    };
    Promise2.prototype.all = function() {
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = function(fn) {
      var ret = new Promise2(INTERNAL);
      var result = tryCatch(fn)(nodebackForPromise(ret));
      if (result === errorObj) {
        ret._rejectCallback(result.e, true, true);
      }
      return ret;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.defer = Promise2.pending = function() {
      var promise = new Promise2(INTERNAL);
      return new PromiseResolver(promise);
    };
    Promise2.cast = function(obj2) {
      var ret = tryConvertToPromise(obj2);
      if (!(ret instanceof Promise2)) {
        var val = ret;
        ret = new Promise2(INTERNAL);
        ret._fulfillUnchecked(val);
      }
      return ret;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._rejectCallback(reason, true);
      return ret;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError2(`fn must be a function

    See http://goo.gl/916lJJ
`);
      var prev = async._schedule;
      async._schedule = fn;
      return prev;
    };
    Promise2.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
      var haveInternalData = internalData !== undefined;
      var ret = haveInternalData ? internalData : new Promise2(INTERNAL);
      if (!haveInternalData) {
        ret._propagateFrom(this, 4 | 1);
        ret._captureStackTrace();
      }
      var target = this._target();
      if (target !== this) {
        if (receiver === undefined)
          receiver = this._boundTo;
        if (!haveInternalData)
          ret._setIsMigrated();
      }
      var callbackIndex = target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver, getDomain());
      if (target._isResolved() && !target._isSettlePromisesQueued()) {
        async.invoke(target._settlePromiseAtPostResolution, target, callbackIndex);
      }
      return ret;
    };
    Promise2.prototype._settlePromiseAtPostResolution = function(index) {
      if (this._isRejectionUnhandled())
        this._unsetRejectionIsUnhandled();
      this._settlePromiseAt(index);
    };
    Promise2.prototype._length = function() {
      return this._bitField & 131071;
    };
    Promise2.prototype._isFollowingOrFulfilledOrRejected = function() {
      return (this._bitField & 939524096) > 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 536870912) === 536870912;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -131072 | len & 131071;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 134217728;
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 536870912;
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 33554432;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 33554432) > 0;
    };
    Promise2.prototype._cancellable = function() {
      return (this._bitField & 67108864) > 0;
    };
    Promise2.prototype._setCancellable = function() {
      this._bitField = this._bitField | 67108864;
    };
    Promise2.prototype._unsetCancellable = function() {
      this._bitField = this._bitField & ~67108864;
    };
    Promise2.prototype._setIsMigrated = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._unsetIsMigrated = function() {
      this._bitField = this._bitField & ~4194304;
    };
    Promise2.prototype._isMigrated = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._receiverAt = function(index) {
      var ret = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
      if (ret === UNDEFINED_BINDING) {
        return;
      } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
      }
      return ret;
    };
    Promise2.prototype._promiseAt = function(index) {
      return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index) {
      return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index) {
      return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
    };
    Promise2.prototype._boundValue = function() {
      var ret = this._boundTo;
      if (ret !== undefined) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return;
          }
        }
      }
      return ret;
    };
    Promise2.prototype._migrateCallbacks = function(follower, index) {
      var fulfill = follower._fulfillmentHandlerAt(index);
      var reject = follower._rejectionHandlerAt(index);
      var progress = follower._progressHandlerAt(index);
      var promise = follower._promiseAt(index);
      var receiver = follower._receiverAt(index);
      if (promise instanceof Promise2)
        promise._setIsMigrated();
      if (receiver === undefined)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject, progress, promise, receiver, domain) {
      var index = this._length();
      if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
      }
      if (index === 0) {
        this._promise0 = promise;
        if (receiver !== undefined)
          this._receiver0 = receiver;
        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
          this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
          this._rejectionHandler0 = domain === null ? reject : domain.bind(reject);
        }
        if (typeof progress === "function") {
          this._progressHandler0 = domain === null ? progress : domain.bind(progress);
        }
      } else {
        var base = index * 5 - 5;
        this[base + 3] = promise;
        this[base + 4] = receiver;
        if (typeof fulfill === "function") {
          this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
          this[base + 1] = domain === null ? reject : domain.bind(reject);
        }
        if (typeof progress === "function") {
          this[base + 2] = domain === null ? progress : domain.bind(progress);
        }
      }
      this._setLength(index + 1);
      return index;
    };
    Promise2.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
      var index = this._length();
      if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
      }
      if (index === 0) {
        this._promise0 = promiseSlotValue;
        this._receiver0 = receiver;
      } else {
        var base = index * 5 - 5;
        this[base + 3] = promiseSlotValue;
        this[base + 4] = receiver;
      }
      this._setLength(index + 1);
    };
    Promise2.prototype._proxyPromiseArray = function(promiseArray, index) {
      this._setProxyHandlers(promiseArray, index);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if (this._isFollowingOrFulfilledOrRejected())
        return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false, true);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2))
        return this._fulfill(value);
      var propagationFlags = 1 | (shouldBind ? 4 : 0);
      this._propagateFrom(maybePromise, propagationFlags);
      var promise = maybePromise._target();
      if (promise._isPending()) {
        var len = this._length();
        for (var i = 0;i < len; ++i) {
          promise._migrateCallbacks(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
      } else if (promise._isFulfilled()) {
        this._fulfillUnchecked(promise._value());
      } else {
        this._rejectUnchecked(promise._reason(), promise._getCarriedStackTrace());
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
      if (!shouldNotMarkOriginatingFromRejection) {
        util.markAsOriginatingFromRejection(reason);
      }
      var trace = util.ensureErrorObject(reason);
      var hasStack = trace === reason;
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason, hasStack ? undefined : trace);
    };
    Promise2.prototype._resolveFromResolver = function(resolver) {
      var promise = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = tryCatch(resolver)(function(value) {
        if (promise === null)
          return;
        promise._resolveCallback(value);
        promise = null;
      }, function(reason) {
        if (promise === null)
          return;
        promise._rejectCallback(reason, synchronous);
        promise = null;
      });
      synchronous = false;
      this._popContext();
      if (r !== undefined && r === errorObj && promise !== null) {
        promise._rejectCallback(r.e, true, true);
        promise = null;
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
      if (promise._isRejected())
        return;
      promise._pushContext();
      var x;
      if (receiver === APPLY && !this._isRejected()) {
        x = tryCatch(handler).apply(this._boundValue(), value);
      } else {
        x = tryCatch(handler).call(receiver, value);
      }
      promise._popContext();
      if (x === errorObj || x === promise || x === NEXT_FILTER) {
        var err = x === promise ? makeSelfResolutionError() : x.e;
        promise._rejectCallback(err, false, true);
      } else {
        promise._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret = this;
      while (ret._isFollowing())
        ret = ret._followee();
      return ret;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise) {
      this._rejectionHandler0 = promise;
    };
    Promise2.prototype._cleanValues = function() {
      if (this._cancellable()) {
        this._cancellationParent = undefined;
      }
    };
    Promise2.prototype._propagateFrom = function(parent, flags) {
      if ((flags & 1) > 0 && parent._cancellable()) {
        this._setCancellable();
        this._cancellationParent = parent;
      }
      if ((flags & 4) > 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    };
    Promise2.prototype._fulfill = function(value) {
      if (this._isFollowingOrFulfilledOrRejected())
        return;
      this._fulfillUnchecked(value);
    };
    Promise2.prototype._reject = function(reason, carriedStackTrace) {
      if (this._isFollowingOrFulfilledOrRejected())
        return;
      this._rejectUnchecked(reason, carriedStackTrace);
    };
    Promise2.prototype._settlePromiseAt = function(index) {
      var promise = this._promiseAt(index);
      var isPromise = promise instanceof Promise2;
      if (isPromise && promise._isMigrated()) {
        promise._unsetIsMigrated();
        return async.invoke(this._settlePromiseAt, this, index);
      }
      var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
      var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
      var value = this._settledValue;
      var receiver = this._receiverAt(index);
      this._clearCallbackDataAtIndex(index);
      if (typeof handler === "function") {
        if (!isPromise) {
          handler.call(receiver, value, promise);
        } else {
          this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
      } else if (receiver instanceof PromiseArray) {
        if (!receiver._isResolved()) {
          if (this._isFulfilled()) {
            receiver._promiseFulfilled(value, promise);
          } else {
            receiver._promiseRejected(value, promise);
          }
        }
      } else if (isPromise) {
        if (this._isFulfilled()) {
          promise._fulfill(value);
        } else {
          promise._reject(value, carriedStackTrace);
        }
      }
      if (index >= 4 && (index & 31) === 4)
        async.invokeLater(this._setLength, this, 0);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index) {
      if (index === 0) {
        if (!this._isCarryingStackTrace()) {
          this._fulfillmentHandler0 = undefined;
        }
        this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = undefined;
      } else {
        var base = index * 5 - 5;
        this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = undefined;
      }
    };
    Promise2.prototype._isSettlePromisesQueued = function() {
      return (this._bitField & -1073741824) === -1073741824;
    };
    Promise2.prototype._setSettlePromisesQueued = function() {
      this._bitField = this._bitField | -1073741824;
    };
    Promise2.prototype._unsetSettlePromisesQueued = function() {
      this._bitField = this._bitField & ~-1073741824;
    };
    Promise2.prototype._queueSettlePromises = function() {
      async.settlePromises(this);
      this._setSettlePromisesQueued();
    };
    Promise2.prototype._fulfillUnchecked = function(value) {
      if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err, undefined);
      }
      this._setFulfilled();
      this._settledValue = value;
      this._cleanValues();
      if (this._length() > 0) {
        this._queueSettlePromises();
      }
    };
    Promise2.prototype._rejectUncheckedCheckError = function(reason) {
      var trace = util.ensureErrorObject(reason);
      this._rejectUnchecked(reason, trace === reason ? undefined : trace);
    };
    Promise2.prototype._rejectUnchecked = function(reason, trace) {
      if (reason === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err);
      }
      this._setRejected();
      this._settledValue = reason;
      this._cleanValues();
      if (this._isFinal()) {
        async.throwLater(function(e) {
          if ("stack" in e) {
            async.invokeFirst(CapturedTrace.unhandledRejection, undefined, e);
          }
          throw e;
        }, trace === undefined ? reason : trace);
        return;
      }
      if (trace !== undefined && trace !== reason) {
        this._setCarriedStackTrace(trace);
      }
      if (this._length() > 0) {
        this._queueSettlePromises();
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._settlePromises = function() {
      this._unsetSettlePromisesQueued();
      var len = this._length();
      for (var i = 0;i < len; i++) {
        this._settlePromiseAt(i);
      }
    };
    util.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
    require_progress()(Promise2, PromiseArray);
    require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    require_bind()(Promise2, INTERNAL, tryConvertToPromise);
    require_finally()(Promise2, NEXT_FILTER, tryConvertToPromise);
    require_direct_resolve()(Promise2);
    require_synchronous_inspection()(Promise2);
    require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL);
    Promise2.version = "2.11.0";
    Promise2.Promise = Promise2;
    require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
    require_cancel()(Promise2);
    require_using()(Promise2, apiRejection, tryConvertToPromise, createContext);
    require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise);
    require_nodeify()(Promise2);
    require_call_get()(Promise2);
    require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
    require_settle()(Promise2, PromiseArray);
    require_some()(Promise2, PromiseArray, apiRejection);
    require_promisify()(Promise2, INTERNAL);
    require_any()(Promise2);
    require_each()(Promise2, INTERNAL);
    require_timers()(Promise2, INTERNAL);
    require_filter()(Promise2, INTERNAL);
    util.toFastProperties(Promise2);
    util.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._progressHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
      p._settledValue = value;
    }
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function() {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
    return Promise2;
  };
});

// node_modules/stream-length/node_modules/bluebird/js/main/bluebird.js
var require_bluebird = __commonJS((exports, module) => {
  var old;
  if (typeof Promise !== "undefined")
    old = Promise;
  function noConflict() {
    try {
      if (Promise === bluebird)
        Promise = old;
    } catch (e) {}
    return bluebird;
  }
  var bluebird = require_promise()();
  bluebird.noConflict = noConflict;
  module.exports = bluebird;
});

// node_modules/stream-length/lib/stream-length.js
var require_stream_length = __commonJS((exports, module) => {
  var Promise2;
  var createRetrieverPromise;
  var fs;
  var nodeifyWrapper;
  var retrieveBuffer;
  var retrieveCombinedStream;
  var retrieveCoreHttpStream;
  var retrieveFilesystemStream;
  var retrieveRequestHttpStream;
  Promise2 = require_bluebird();
  fs = Promise2.promisifyAll(__require("fs"));
  nodeifyWrapper = function(callback, func) {
    return func().nodeify(callback);
  };
  createRetrieverPromise = function(stream, retriever) {
    return new Promise2(function(resolve, reject) {
      return retriever(stream, function(result) {
        if (result != null) {
          if (result instanceof Error) {
            return reject(result);
          } else {
            return resolve(result);
          }
        } else {
          return reject(new Error("Could not find a length using this lengthRetriever."));
        }
      });
    });
  };
  retrieveBuffer = function(stream, callback) {
    if (stream instanceof Buffer) {
      return callback(stream.length);
    } else {
      return callback(null);
    }
  };
  retrieveFilesystemStream = function(stream, callback) {
    var _ref;
    if (stream.hasOwnProperty("fd")) {
      if (stream.end !== undefined && stream.end !== Infinity && stream.start !== undefined) {
        return callback(stream.end + 1 - ((_ref = stream.start) != null ? _ref : 0));
      } else {
        return Promise2["try"](function() {
          return fs.statAsync(stream.path);
        }).then(function(stat) {
          var _ref1;
          return callback(stat.size - ((_ref1 = stream.start) != null ? _ref1 : 0));
        })["catch"](function(err) {
          return callback(err);
        });
      }
    } else {
      return callback(null);
    }
  };
  retrieveCoreHttpStream = function(stream, callback) {
    if (stream.hasOwnProperty("httpVersion") && stream.headers["content-length"] != null) {
      return callback(parseInt(stream.headers["content-length"]));
    } else {
      return callback(null);
    }
  };
  retrieveRequestHttpStream = function(stream, callback) {
    if (stream.hasOwnProperty("httpModule")) {
      return stream.on("response", function(response) {
        if (response.headers["content-length"] != null) {
          return callback(parseInt(response.headers["content-length"]));
        } else {
          return callback(null);
        }
      });
    } else {
      return callback(null);
    }
  };
  retrieveCombinedStream = function(stream, callback) {
    if (stream.getCombinedStreamLength != null) {
      return stream.getCombinedStreamLength().then(function(length) {
        return callback(length);
      })["catch"](function(err) {
        return callback(err);
      });
    } else {
      return callback(null);
    }
  };
  module.exports = function(stream, options, callback) {
    if (options == null) {
      options = {};
    }
    return nodeifyWrapper(callback, function() {
      var retriever, retrieverPromises, _i, _j, _len, _len1, _ref, _ref1;
      retrieverPromises = [];
      if (options.lengthRetrievers != null) {
        _ref = options.lengthRetrievers;
        for (_i = 0, _len = _ref.length;_i < _len; _i++) {
          retriever = _ref[_i];
          retrieverPromises.push(createRetrieverPromise(stream, retriever));
        }
      }
      _ref1 = [retrieveBuffer, retrieveFilesystemStream, retrieveCoreHttpStream, retrieveRequestHttpStream, retrieveCombinedStream];
      for (_j = 0, _len1 = _ref1.length;_j < _len1; _j++) {
        retriever = _ref1[_j];
        retrieverPromises.push(createRetrieverPromise(stream, retriever));
      }
      return Promise2.any(retrieverPromises);
    });
  };
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS((exports, module) => {
  module.exports = isTypedArray;
  isTypedArray.strict = isStrictTypedArray;
  isTypedArray.loose = isLooseTypedArray;
  var toString = Object.prototype.toString;
  var names = {
    "[object Int8Array]": true,
    "[object Int16Array]": true,
    "[object Int32Array]": true,
    "[object Uint8Array]": true,
    "[object Uint8ClampedArray]": true,
    "[object Uint16Array]": true,
    "[object Uint32Array]": true,
    "[object Float32Array]": true,
    "[object Float64Array]": true
  };
  function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS((exports, module) => {
  exports = module.exports = stringify;
  exports.getSerialize = serializer;
  function stringify(obj2, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj2, serializer(replacer, cycleReplacer), spaces);
  }
  function serializer(replacer, cycleReplacer) {
    var stack = [], keys = [];
    if (cycleReplacer == null)
      cycleReplacer = function(key, value) {
        if (stack[0] === value)
          return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
    return function(key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
        if (~stack.indexOf(value))
          value = cycleReplacer.call(this, key, value);
      } else
        stack.push(value);
      return replacer == null ? value : replacer.call(this, key, value);
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/postman-request/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  var jsonSafeStringify = require_stringify();
  var crypto = __require("crypto");
  var Buffer2 = require_safe_buffer().Buffer;
  var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
  function safeStringify(obj2, replacer) {
    var ret;
    try {
      ret = JSON.stringify(obj2, replacer);
    } catch (e) {
      ret = jsonSafeStringify(obj2, replacer);
    }
    return ret;
  }
  function md5(str) {
    return crypto.createHash("md5").update(str).digest("hex");
  }
  function isReadStream(rs) {
    return rs.readable && rs.path && rs.mode;
  }
  function toBase64(str) {
    return Buffer2.from(str || "", "utf8").toString("base64");
  }
  function copy(obj2) {
    var o = {};
    Object.keys(obj2).forEach(function(i) {
      o[i] = obj2[i];
    });
    return o;
  }
  function version() {
    var numbers = process.version.replace("v", "").split(".");
    return {
      major: parseInt(numbers[0], 10),
      minor: parseInt(numbers[1], 10),
      patch: parseInt(numbers[2], 10)
    };
  }
  exports.safeStringify = safeStringify;
  exports.md5 = md5;
  exports.isReadStream = isReadStream;
  exports.toBase64 = toBase64;
  exports.copy = copy;
  exports.version = version;
  exports.defer = defer;
});

// node_modules/postman-request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS((exports, module) => {
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, ".").toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    var zoneParts = zone.split(":", 2);
    var zoneHost = formatHostname(zoneParts[0]);
    var zonePort = zoneParts[1];
    var hasPort = zone.indexOf(":") > -1;
    return { hostname: zoneHost, port: zonePort, hasPort };
  }
  function uriInNoProxy(uri, noProxy) {
    var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
    var hostname = formatHostname(uri.hostname);
    var noProxyList = noProxy.split(",");
    return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
      var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
    if (noProxy === "*") {
      return null;
    }
    if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === "http:") {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === "https:") {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    return null;
  }
  module.exports = getProxyFromURI;
});

// node_modules/postman-request/node_modules/qs/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var hexTable = function() {
    var array = [];
    for (var i = 0;i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    var obj2;
    while (queue.length) {
      var item = queue.pop();
      obj2 = item.obj[item.prop];
      if (Array.isArray(obj2)) {
        var compacted = [];
        for (var j = 0;j < obj2.length; ++j) {
          if (typeof obj2[j] !== "undefined") {
            compacted.push(obj2[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
    return obj2;
  };
  var arrayToObject = function arrayToObject(source, options) {
    var obj2 = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0;i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj2[i] = source[i];
      }
    }
    return obj2;
  };
  var merge = function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (Array.isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (Array.isArray(target) && Array.isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str) {
    try {
      return decodeURIComponent(str.replace(/\+/g, " "));
    } catch (e) {
      return str;
    }
  };
  var encode = function encode(str) {
    if (str.length === 0) {
      return str;
    }
    var string = typeof str === "string" ? str : String(str);
    var out = "";
    for (var i = 0;i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0;i < queue.length; ++i) {
      var item = queue[i];
      var obj2 = item.obj[item.prop];
      var keys = Object.keys(obj2);
      for (var j = 0;j < keys.length; ++j) {
        var key = keys[j];
        var val = obj2[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj: obj2, prop: key });
          refs.push(val);
        }
      }
    }
    return compactQueue(queue);
  };
  var isRegExp = function isRegExp(obj2) {
    return Object.prototype.toString.call(obj2) === "[object RegExp]";
  };
  var isBuffer = function isBuffer(obj2) {
    if (obj2 === null || typeof obj2 === "undefined") {
      return false;
    }
    return !!(obj2.constructor && obj2.constructor.isBuffer && obj2.constructor.isBuffer(obj2));
  };
  module.exports = {
    arrayToObject,
    assign,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    merge
  };
});

// node_modules/postman-request/node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports, module) => {
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  module.exports = {
    default: "RFC3986",
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
});

// node_modules/postman-request/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
  var utils = require_utils3();
  var formats = require_formats();
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaults = {
    delimiter: "&",
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
    var obj2 = object;
    if (typeof filter === "function") {
      obj2 = filter(prefix, obj2);
    } else if (obj2 instanceof Date) {
      obj2 = serializeDate(obj2);
    }
    if (obj2 === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
      }
      obj2 = "";
    }
    if (typeof obj2 === "string" || typeof obj2 === "number" || typeof obj2 === "boolean" || utils.isBuffer(obj2)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
        return [formatter(keyValue) + "=" + formatter(encoder(obj2, defaults.encoder))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj2))];
    }
    var values = [];
    if (typeof obj2 === "undefined") {
      return values;
    }
    var objKeys;
    if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj2);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj2[key] === null) {
        continue;
      }
      if (isArray(obj2)) {
        pushToArray(values, stringify(obj2[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
      } else {
        pushToArray(values, stringify(obj2[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
      }
    }
    return values;
  };
  module.exports = function(object, opts) {
    var obj2 = object;
    var options = opts ? utils.assign({}, opts) : {};
    if (options.encoder !== null && typeof options.encoder !== "undefined" && typeof options.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === "boolean" ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === "function" ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === "function" ? options.sort : null;
    var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === "function" ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === "boolean" ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === "undefined") {
      options.format = formats["default"];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj2 = filter("", obj2);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj2 !== "object" || obj2 === null) {
      return "";
    }
    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ("indices" in options) {
      arrayFormat = options.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj2);
    }
    if (sort) {
      objKeys.sort(sort);
    }
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj2[key] === null) {
        continue;
      }
      pushToArray(keys, stringify(obj2[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
    }
    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    return joined.length > 0 ? prefix + joined : "";
  };
});

// node_modules/postman-request/node_modules/qs/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var utils = require_utils3();
  var has = Object.prototype.hasOwnProperty;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
  };
  var parseValues = function parseQueryStringValues(str, options) {
    var obj2 = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    for (var i = 0;i < parts.length; ++i) {
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder);
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder);
        val = options.decoder(part.slice(pos + 1), defaults.decoder);
      }
      if (has.call(obj2, key)) {
        obj2[key] = [].concat(obj2[key]).concat(val);
      } else {
        obj2[key] = val;
      }
    }
    return obj2;
  };
  var parseObject = function(chain, val, options) {
    var leaf = val;
    for (var i = chain.length - 1;i >= 0; --i) {
      var obj2;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj2 = [].concat(leaf);
      } else {
        obj2 = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj2 = { 0: leaf };
        } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj2 = [];
          obj2[index] = leaf;
        } else if (cleanRoot !== "__proto__") {
          obj2[cleanRoot] = leaf;
        }
      }
      leaf = obj2;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options);
  };
  module.exports = function(str, opts) {
    var options = opts ? utils.assign({}, opts) : {};
    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === "string" || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj2 = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options);
      obj2 = utils.merge(obj2, newObj, options);
    }
    return utils.compact(obj2);
  };
});

// node_modules/postman-request/node_modules/qs/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var stringify = require_stringify2();
  var parse = require_parse();
  var formats = require_formats();
  module.exports = {
    formats,
    parse,
    stringify
  };
});

// node_modules/postman-request/lib/querystring.js
var require_querystring = __commonJS((exports) => {
  var qs = require_lib4();
  var querystring = __require("querystring");
  function Querystring(request) {
    this.request = request;
    this.lib = null;
    this.useQuerystring = null;
    this.parseOptions = null;
    this.stringifyOptions = null;
  }
  Querystring.prototype.init = function(options) {
    if (this.lib) {
      return;
    }
    this.useQuerystring = options.useQuerystring;
    this.lib = this.useQuerystring ? querystring : qs;
    this.parseOptions = options.qsParseOptions || {};
    this.stringifyOptions = options.qsStringifyOptions || {};
  };
  Querystring.prototype.stringify = function(obj2) {
    return this.useQuerystring ? this.rfc3986(this.lib.stringify(obj2, this.stringifyOptions.sep || null, this.stringifyOptions.eq || null, this.stringifyOptions)) : this.lib.stringify(obj2, this.stringifyOptions);
  };
  Querystring.prototype.parse = function(str) {
    return this.useQuerystring ? this.lib.parse(str, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions) : this.lib.parse(str, this.parseOptions);
  };
  Querystring.prototype.rfc3986 = function(str) {
    return str.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };
  Querystring.prototype.unescape = querystring.unescape;
  exports.Querystring = Querystring;
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
  })(exports, function(exports2) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0;_key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1;x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj2) {
      return obj2 !== undefined && obj2 !== null ? obj2 instanceof Array ? obj2 : typeof obj2.length !== "number" || obj2.split || obj2.setInterval || obj2.call ? [obj2] : Array.prototype.slice.call(obj2) : [];
    }
    function assign(target, source) {
      var obj2 = target;
      if (source) {
        for (var key in source) {
          obj2[key] = source[key];
        }
      }
      return obj2;
    }
    function buildExps(isIRI2) {
      var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;
        try {
          for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (;delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0;j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base;; k += base) {
          if (index >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;
      try {
        for (var _iterator = input[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q2 = delta;
              for (var k = base;; k += base) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q2 < t) {
                  break;
                }
                var qMinusT = q2 - t;
                var baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      version: "2.1.0",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = undefined;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== undefined)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== undefined)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== undefined)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== undefined)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== undefined)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0;x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = undefined;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || undefined;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
          components.reference = "same-document";
        } else if (components.scheme === undefined) {
          components.reference = "relative";
        } else if (components.fragment === undefined) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== undefined) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : undefined;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== undefined) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === undefined) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== undefined) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== undefined || base2.host !== undefined || base2.port !== undefined) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = undefined;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
      },
      serialize: function serialize(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = undefined;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = undefined;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path && path !== "/" ? path : undefined;
          wsComponents.query = query;
          wsComponents.resourceName = undefined;
        }
        wsComponents.fragment = undefined;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var isIRI = true;
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", "[\\\"]", VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length;x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length;_x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length;_x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length;x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = undefined;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve;
    exports2.normalize = normalize;
    exports2.equal = equal;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS((exports, module) => {
  module.exports = function ucs2length(str) {
    var length = 0, len = str.length, pos = 0, value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320)
          pos++;
      }
    }
    return length;
  };
});

// node_modules/ajv/lib/compile/util.js
var require_util3 = __commonJS((exports, module) => {
  module.exports = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: require_fast_deep_equal(),
    ucs2length: require_ucs2length(),
    varOccurences,
    varReplace,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer
  };
  function copy(o, to) {
    to = to || {};
    for (var key in o)
      to[key] = o[key];
    return to;
  }
  function checkDataType(dataType, data, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch (dataType) {
      case "null":
        return data + EQUAL + "null";
      case "array":
        return OK + "Array.isArray(" + data + ")";
      case "object":
        return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
      case "integer":
        return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
      case "number":
        return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
      default:
        return "typeof " + data + EQUAL + '"' + dataType + '"';
    }
  }
  function checkDataTypes(dataTypes, data, strictNumbers) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data, strictNumbers, true);
      default:
        var code = "";
        var types = toHash(dataTypes);
        if (types.array && types.object) {
          code = types.null ? "(" : "(!" + data + " || ";
          code += "typeof " + data + ' !== "object")';
          delete types.null;
          delete types.array;
          delete types.object;
        }
        if (types.number)
          delete types.integer;
        for (var t in types)
          code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
        return code;
    }
  }
  var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types = [];
      for (var i = 0;i < dataTypes.length; i++) {
        var t = dataTypes[i];
        if (COERCE_TO_TYPES[t])
          types[types.length] = t;
        else if (optionCoerceTypes === "array" && t === "array")
          types[types.length] = t;
      }
      if (types.length)
        return types;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === "array" && dataTypes === "array") {
      return ["array"];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i = 0;i < arr.length; i++)
      hash[arr[i]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
  }
  function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
  }
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (var key in schema)
      if (rules[key])
        return true;
  }
  function schemaHasRulesExcept(schema, rules, exceptKeyword) {
    if (typeof schema == "boolean")
      return !schema && exceptKeyword != "not";
    for (var key in schema)
      if (key != exceptKeyword && rules[key])
        return true;
  }
  function schemaUnknownRules(schema, rules) {
    if (typeof schema == "boolean")
      return;
    for (var key in schema)
      if (!rules[key])
        return key;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up, jsonPointer, data, matches;
    if ($data === "")
      return "rootData";
    if ($data[0] == "/") {
      if (!JSON_POINTER.test($data))
        throw new Error("Invalid JSON-pointer: " + $data);
      jsonPointer = $data;
      data = "rootData";
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches)
        throw new Error("Invalid JSON-pointer: " + $data);
      up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == "#") {
        if (up >= lvl)
          throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
        return paths[lvl - up];
      }
      if (up > lvl)
        throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
      data = "data" + (lvl - up || "");
      if (!jsonPointer)
        return data;
    }
    var expr = data;
    var segments = jsonPointer.split("/");
    for (var i = 0;i < segments.length; i++) {
      var segment = segments[i];
      if (segment) {
        data += getProperty(unescapeJsonPointer(segment));
        expr += " && " + data;
      }
    }
    return expr;
  }
  function joinPaths(a, b) {
    if (a == '""')
      return b;
    return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS((exports, module) => {
  var util = require_util3();
  module.exports = SchemaObject;
  function SchemaObject(obj2) {
    util.copy(obj2, this);
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports, module) => {
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS((exports, module) => {
  var URI = require_uri_all();
  var equal = require_fast_deep_equal();
  var util = require_util3();
  var SchemaObject = require_schema_obj();
  var traverse = require_json_schema_traverse();
  module.exports = resolve;
  resolve.normalizeId = normalizeId;
  resolve.fullPath = getFullPath;
  resolve.url = resolveUrl;
  resolve.ids = resolveIds;
  resolve.inlineRef = inlineRef;
  resolve.schema = resolveSchema;
  function resolve(compile, root, ref) {
    var refVal = this._refs[ref];
    if (typeof refVal == "string") {
      if (this._refs[refVal])
        refVal = this._refs[refVal];
      else
        return resolve.call(this, compile, root, refVal);
    }
    refVal = refVal || this._schemas[ref];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root, ref);
    var schema, v, baseId;
    if (res) {
      schema = res.schema;
      root = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
    } else if (schema !== undefined) {
      v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
    }
    return v;
  }
  function resolveSchema(root, ref) {
    var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
      var id = normalizeId(refPath);
      var refVal = this._refs[id];
      if (typeof refVal == "string") {
        return resolveRecursive.call(this, root, refVal, p);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate)
          this._compile(refVal);
        root = refVal;
      } else {
        refVal = this._schemas[id];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          if (id == normalizeId(ref))
            return { schema: refVal, root, baseId };
          root = refVal;
        } else {
          return;
        }
      }
      if (!root.schema)
        return;
      baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p, baseId, root.schema, root);
  }
  function resolveRecursive(root, ref, parsedRef) {
    var res = resolveSchema.call(this, root, ref);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root = res.root;
      var id = this._getId(schema);
      if (id)
        baseId = resolveUrl(baseId, id);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
  }
  var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function getJsonPointer(parsedRef, baseId, schema, root) {
    parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/")
      return;
    var parts = parsedRef.fragment.split("/");
    for (var i = 1;i < parts.length; i++) {
      var part = parts[i];
      if (part) {
        part = util.unescapeFragment(part);
        schema = schema[part];
        if (schema === undefined)
          break;
        var id;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id = this._getId(schema);
          if (id)
            baseId = resolveUrl(baseId, id);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root, $ref);
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== undefined && schema !== root.schema)
      return { schema, root, baseId };
  }
  var SIMPLE_INLINED = util.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function inlineRef(schema, limit) {
    if (limit === false)
      return false;
    if (limit === undefined || limit === true)
      return checkNoRef(schema);
    else if (limit)
      return countKeys(schema) <= limit;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i = 0;i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item))
          return false;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref")
          return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item))
          return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) {
      for (var i = 0;i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object")
          count += countKeys(item);
        if (count == Infinity)
          return Infinity;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref")
          return Infinity;
        if (SIMPLE_INLINED[key]) {
          count++;
        } else {
          item = schema[key];
          if (typeof item == "object")
            count += countKeys(item) + 1;
          if (count == Infinity)
            return Infinity;
        }
      }
    }
    return count;
  }
  function getFullPath(id, normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
  }
  function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = { "": schemaId };
    var fullPaths = { "": getFullPath(schemaId, false) };
    var localRefs = {};
    var self2 = this;
    traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (jsonPtr === "")
        return;
      var id = self2._getId(sch);
      var baseId = baseIds[parentJsonPtr];
      var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
      if (keyIndex !== undefined)
        fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
      if (typeof id == "string") {
        id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
        var refVal = self2._refs[id];
        if (typeof refVal == "string")
          refVal = self2._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(sch, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == "#") {
            if (localRefs[id] && !equal(sch, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = sch;
          } else {
            self2._refs[id] = fullPath;
          }
        }
      }
      baseIds[jsonPtr] = baseId;
      fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS((exports, module) => {
  var resolve = require_resolve();
  module.exports = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
  };
  function ValidationError(errors) {
    this.message = "validation failed";
    this.errors = errors;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function(baseId, ref) {
    return "can't resolve reference " + ref + " from id " + baseId;
  };
  function MissingRefError(baseId, ref, message) {
    this.message = message || MissingRefError.message(baseId, ref);
    this.missingRef = resolve.url(baseId, ref);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports, module) => {
  module.exports = function(data, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = { cmp: opts };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f2) {
      return function(node) {
        return function(a, b) {
          var aobj = { key: a, value: node[a] };
          var bobj = { key: b, value: node[b] };
          return f2(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === undefined)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object")
        return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0;i < node.length; i++) {
          if (i)
            out += ",";
          out += stringify(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0;i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node[key]);
        if (!value)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data);
  };
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate2 = __commonJS((exports, module) => {
  module.exports = function generate_validate(it, $keyword, $ruleType) {
    var out = "";
    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
      var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
      if ($unknownKwd) {
        var $keywordsMsg = "unknown keyword: " + $unknownKwd;
        if (it.opts.strictKeywords === "log")
          it.logger.warn($keywordsMsg);
        else
          throw new Error($keywordsMsg);
      }
    }
    if (it.isTop) {
      out += " var validate = ";
      if ($async) {
        it.async = true;
        out += "async ";
      }
      out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id && (it.opts.sourceCode || it.opts.processCode)) {
        out += " " + ("/*# sourceURL=" + $id + " */") + " ";
      }
    }
    if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
      var $keyword = "false schema";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      if (it.schema === false) {
        if (it.isTop) {
          $breakOnError = true;
        } else {
          out += " var " + $valid + " = false; ";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        if (it.isTop) {
          if ($async) {
            out += " return data; ";
          } else {
            out += " validate.errors = null; return true; ";
          }
        } else {
          out += " var " + $valid + " = true; ";
        }
      }
      if (it.isTop) {
        out += " }; return validate; ";
      }
      return out;
    }
    if (it.isTop) {
      var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
      it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
      it.baseId = it.baseId || it.rootId;
      delete it.isTop;
      it.dataPathArr = [""];
      if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
        var $defaultMsg = "default is ignored in the schema root";
        if (it.opts.strictDefaults === "log")
          it.logger.warn($defaultMsg);
        else
          throw new Error($defaultMsg);
      }
      out += " var vErrors = null; ";
      out += " var errors = 0;     ";
      out += " if (rootData === undefined) rootData = data; ";
    } else {
      var { level: $lvl, dataLevel: $dataLvl } = it, $data = "data" + ($dataLvl || "");
      if ($id)
        it.baseId = it.resolve.url(it.baseId, $id);
      if ($async && !it.async)
        throw new Error("async schema in sync schema");
      out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf("null") == -1)
          $typeSchema = $typeSchema.concat("null");
      } else if ($typeSchema != "null") {
        $typeSchema = [$typeSchema, "null"];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
      if (it.opts.extendRefs == "fail") {
        throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
      } else if (it.opts.extendRefs !== true) {
        $refKeywords = false;
        it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
      }
    }
    if (it.schema.$comment && it.opts.$comment) {
      out += " " + it.RULES.all.$comment.code(it, "$comment");
    }
    if ($typeSchema) {
      if (it.opts.coerceTypes) {
        var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
      }
      var $rulesGroup = it.RULES.types[$typeSchema];
      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
        out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
        if ($coerceToTypes) {
          var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
          out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
          if (it.opts.coerceTypes == "array") {
            out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
          }
          out += " if (" + $coerced + " !== undefined) ; ";
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $type = arr1[$i += 1];
              if ($type == "string") {
                out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
              } else if ($type == "number" || $type == "integer") {
                out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                if ($type == "integer") {
                  out += " && !(" + $data + " % 1)";
                }
                out += ")) " + $coerced + " = +" + $data + "; ";
              } else if ($type == "boolean") {
                out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
              } else if ($type == "null") {
                out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
              } else if (it.opts.coerceTypes == "array" && $type == "array") {
                out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
              }
            }
          }
          out += " else {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } if (" + $coerced + " !== undefined) {  ";
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " " + $data + " = " + $coerced + "; ";
          if (!$dataLvl) {
            out += "if (" + $parentData + " !== undefined)";
          }
          out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        }
        out += " } ";
      }
    }
    if (it.schema.$ref && !$refKeywords) {
      out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
      if ($breakOnError) {
        out += " } if (errors === ";
        if ($top) {
          out += "0";
        } else {
          out += "errs_" + $lvl;
        }
        out += ") { ";
        $closingBraces2 += "}";
      }
    } else {
      var arr2 = it.RULES;
      if (arr2) {
        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[i2 += 1];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
            }
            if (it.opts.useDefaults) {
              if ($rulesGroup.type == "object" && it.schema.properties) {
                var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[i3 += 1];
                    var $sch = $schema[$propertyKey];
                    if ($sch.default !== undefined) {
                      var $passData = $data + it.util.getProperty($propertyKey);
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log")
                            it.logger.warn($defaultMsg);
                          else
                            throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                var arr4 = it.schema.items;
                if (arr4) {
                  var $sch, $i = -1, l4 = arr4.length - 1;
                  while ($i < l4) {
                    $sch = arr4[$i += 1];
                    if ($sch.default !== undefined) {
                      var $passData = $data + "[" + $i + "]";
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log")
                            it.logger.warn($defaultMsg);
                          else
                            throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule, i5 = -1, l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[i5 += 1];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += " " + $code + " ";
                    if ($breakOnError) {
                      $closingBraces1 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces1 + " ";
              $closingBraces1 = "";
            }
            if ($rulesGroup.type) {
              out += " } ";
              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                out += " else { ";
                var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
              }
            }
            if ($breakOnError) {
              out += " if (errors === ";
              if ($top) {
                out += "0";
              } else {
                out += "errs_" + $lvl;
              }
              out += ") { ";
              $closingBraces2 += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces2 + " ";
    }
    if ($top) {
      if ($async) {
        out += " if (errors === 0) return data;           ";
        out += " else throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; ";
        out += " return errors === 0;       ";
      }
      out += " }; return validate;";
    } else {
      out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules = $rulesGroup2.rules;
      for (var i = 0;i < rules.length; i++)
        if ($shouldUseRule(rules[i]))
          return true;
    }
    function $shouldUseRule($rule2) {
      return it.schema[$rule2.keyword] !== undefined || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i = 0;i < impl.length; i++)
        if (it.schema[impl[i]] !== undefined)
          return true;
    }
    return out;
  };
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS((exports, module) => {
  var resolve = require_resolve();
  var util = require_util3();
  var errorClasses = require_error_classes();
  var stableStringify = require_fast_json_stable_stringify();
  var validateGenerator = require_validate2();
  var ucs2length = util.ucs2length;
  var equal = require_fast_deep_equal();
  var ValidationError = errorClasses.Validation;
  module.exports = compile;
  function compile(schema, root, localRefs, baseId) {
    var self2 = this, opts = this._opts, refVal = [undefined], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
    root = root || { schema, refVal, refs };
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling)
      return compilation.callValidate = callValidate;
    var formats = this._formats;
    var RULES = this.RULES;
    try {
      var v = localCompile(schema, root, localRefs, baseId);
      compilation.validate = v;
      var cv = compilation.callValidate;
      if (cv) {
        cv.schema = v.schema;
        cv.errors = null;
        cv.refs = v.refs;
        cv.refVal = v.refVal;
        cv.root = v.root;
        cv.$async = v.$async;
        if (opts.sourceCode)
          cv.source = v.source;
      }
      return v;
    } finally {
      endCompiling.call(this, schema, root, baseId);
    }
    function callValidate() {
      var validate = compilation.validate;
      var result = validate.apply(this, arguments);
      callValidate.errors = validate.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || _root && _root.schema == _schema;
      if (_root.schema != root.schema)
        return compile.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util,
        resolve,
        resolveRef,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats,
        logger: self2.logger,
        self: self2
      });
      sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
      if (opts.processCode)
        sourceCode = opts.processCode(sourceCode, _schema);
      var validate;
      try {
        var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
        validate = makeValidate(self2, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
        refVal[0] = validate;
      } catch (e) {
        self2.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      }
      validate.schema = _schema;
      validate.errors = null;
      validate.refs = refs;
      validate.refVal = refVal;
      validate.root = isRoot ? validate : _root;
      if ($async)
        validate.$async = true;
      if (opts.sourceCode === true) {
        validate.source = {
          code: sourceCode,
          patterns,
          defaults
        };
      }
      return validate;
    }
    function resolveRef(baseId2, ref, isRoot) {
      ref = resolve.url(baseId2, ref);
      var refIndex = refs[ref];
      var _refVal, refCode;
      if (refIndex !== undefined) {
        _refVal = refVal[refIndex];
        refCode = "refVal[" + refIndex + "]";
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root.refs) {
        var rootRefId = root.refs[ref];
        if (rootRefId !== undefined) {
          _refVal = root.refVal[rootRefId];
          refCode = addLocalRef(ref, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref);
      var v2 = resolve.call(self2, localCompile, root, ref);
      if (v2 === undefined) {
        var localSchema = localRefs && localRefs[ref];
        if (localSchema) {
          v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
        }
      }
      if (v2 === undefined) {
        removeLocalRef(ref);
      } else {
        replaceLocalRef(ref, v2);
        return resolvedRef(v2, refCode);
      }
    }
    function addLocalRef(ref, v2) {
      var refId = refVal.length;
      refVal[refId] = v2;
      refs[ref] = refId;
      return "refVal" + refId;
    }
    function removeLocalRef(ref) {
      delete refs[ref];
    }
    function replaceLocalRef(ref, v2) {
      var refId = refs[ref];
      refVal[refId] = v2;
    }
    function resolvedRef(refVal2, code) {
      return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
    }
    function usePattern(regexStr) {
      var index = patternsHash[regexStr];
      if (index === undefined) {
        index = patternsHash[regexStr] = patterns.length;
        patterns[index] = regexStr;
      }
      return "pattern" + index;
    }
    function useDefault(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
          return "" + value;
        case "string":
          return util.toQuotedString(value);
        case "object":
          if (value === null)
            return "null";
          var valueStr = stableStringify(value);
          var index = defaultsHash[valueStr];
          if (index === undefined) {
            index = defaultsHash[valueStr] = defaults.length;
            defaults[index] = value;
          }
          return "default" + index;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (deps && !deps.every(function(keyword) {
          return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
        }))
          throw new Error("parent schema must have all required keywords: " + deps.join(","));
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log")
              self2.logger.error(message);
            else
              throw new Error(message);
          }
        }
      }
      var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
      var validate;
      if (compile2) {
        validate = compile2.call(self2, schema2, parentSchema, it);
      } else if (macro) {
        validate = macro.call(self2, schema2, parentSchema, it);
        if (opts.validateSchema !== false)
          self2.validateSchema(validate, true);
      } else if (inline) {
        validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
      } else {
        validate = rule.definition.validate;
        if (!validate)
          return;
      }
      if (validate === undefined)
        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
      var index = customRules.length;
      customRules[index] = validate;
      return {
        code: "customRule" + index,
        validate
      };
    }
  }
  function checkCompiling(schema, root, baseId) {
    var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0)
      return { index, compiling: true };
    index = this._compilations.length;
    this._compilations[index] = {
      schema,
      root,
      baseId
    };
    return { index, compiling: false };
  }
  function endCompiling(schema, root, baseId) {
    var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0)
      this._compilations.splice(i, 1);
  }
  function compIndex(schema, root, baseId) {
    for (var i = 0;i < this._compilations.length; i++) {
      var c = this._compilations[i];
      if (c.schema == schema && c.root == root && c.baseId == baseId)
        return i;
    }
    return -1;
  }
  function patternCode(i, patterns) {
    return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
  }
  function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
  }
  function refValCode(i, refVal) {
    return refVal[i] === undefined ? "" : "var refVal" + i + " = refVal[" + i + "];";
  }
  function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
  }
  function vars(arr, statement) {
    if (!arr.length)
      return "";
    var code = "";
    for (var i = 0;i < arr.length; i++)
      code += statement(i, arr);
    return code;
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS((exports, module) => {
  var Cache = module.exports = function Cache() {
    this._cache = {};
  };
  Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
  };
  Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
  };
  Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
});

// node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS((exports, module) => {
  var util = require_util3();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  module.exports = formats;
  function formats(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util.copy(formats[mode]);
  }
  formats.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL2,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  formats.full = {
    date,
    time,
    "date-time": date_time,
    uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL2,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date(str) {
    var matches = str.match(DATE);
    if (!matches)
      return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function time(str, full) {
    var matches = str.match(TIME);
    if (!matches)
      return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = function generate_ref(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema == "#" || $schema == "#/") {
      if (it.isRoot) {
        $async = it.async;
        $refCode = "validate";
      } else {
        $async = it.root.schema.$async === true;
        $refCode = "root.refVal[0]";
      }
    } else {
      var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
      if ($refVal === undefined) {
        var $message = it.MissingRefError.message(it.baseId, $schema);
        if (it.opts.missingRefs == "fail") {
          it.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + "$ref" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          if ($breakOnError) {
            out += " if (false) { ";
          }
        } else if (it.opts.missingRefs == "ignore") {
          it.logger.warn($message);
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          throw new it.MissingRefError(it.baseId, $schema, $message);
        }
      } else if ($refVal.inline) {
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = "";
        $it.errSchemaPath = $schema;
        var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += " " + $code + " ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
        }
      } else {
        $async = $refVal.$async === true || it.async && $refVal.$async !== false;
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.opts.passContext) {
        out += " " + $refCode + ".call(this, ";
      } else {
        out += " " + $refCode + "( ";
      }
      out += " " + $data + ", (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it.async)
          throw new Error("async schema referenced by sync schema");
        if ($breakOnError) {
          out += " var " + $valid + "; ";
        }
        out += " try { await " + __callValidate + "; ";
        if ($breakOnError) {
          out += " " + $valid + " = true; ";
        }
        out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
        if ($breakOnError) {
          out += " " + $valid + " = false; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " if (" + $valid + ") { ";
        }
      } else {
        out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS((exports, module) => {
  module.exports = function generate_allOf(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += " if (true) { ";
      } else {
        out += " " + $closingBraces.slice(0, -1) + " ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS((exports, module) => {
  module.exports = function generate_anyOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema.every(function($sch2) {
      return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
          $closingBraces += "}";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + "anyOf" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS((exports, module) => {
  module.exports = function generate_comment(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema);
    if (it.opts.$comment === true) {
      out += " console.log(" + $comment + ");";
    } else if (typeof it.opts.$comment == "function") {
      out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS((exports, module) => {
  module.exports = function generate_const(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!$isData) {
      out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "const" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS((exports, module) => {
  module.exports = function generate_contains(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      out += " if (" + $nextValid + ") break; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else {
      out += " if (" + $data + ".length == 0) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "contains" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else { ";
    if ($nonEmptySchema) {
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    }
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS((exports, module) => {
  module.exports = function generate_dependencies(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
    for ($property in $schema) {
      if ($property == "__proto__")
        continue;
      var $sch = $schema[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it.errorPath;
    out += "var missing" + $lvl + ";";
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        if ($breakOnError) {
          out += " && ( ";
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $propertyKey = arr1[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ")) {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + "dependencies" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += "property " + it.util.escapeQuotes($deps[0]);
              } else {
                out += "properties " + it.util.escapeQuotes($deps.join(", "));
              }
              out += " when property " + it.util.escapeQuotes($property) + " is present' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          out += " ) { ";
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[i2 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: '" + "dependencies" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
        out += " }   ";
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        out += ") { ";
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it.util.getProperty($property);
        $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
    if ($breakOnError) {
      out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS((exports, module) => {
  module.exports = function generate_enum(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) {
      out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + ";";
    if ($isData) {
      out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    }
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "enum" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS((exports, module) => {
  module.exports = function generate_format(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it.opts.format === false) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
      out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
      if (it.async) {
        out += " var async" + $lvl + " = " + $format + ".async; ";
      }
      out += " " + $format + " = " + $format + ".validate; } if (  ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " (";
      if ($unknownFormats != "ignore") {
        out += " (" + $schemaValue + " && !" + $format + " ";
        if ($allowUnknown) {
          out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
        }
        out += ") || ";
      }
      out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
      if (it.async) {
        out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
      } else {
        out += " " + $format + "(" + $data + ") ";
      }
      out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
      var $format = it.formats[$schema];
      if (!$format) {
        if ($unknownFormats == "ignore") {
          it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else {
          throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
        }
      }
      var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
      var $formatType = $isObject && $format.type || "string";
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      if ($async) {
        if (!it.async)
          throw new Error("async format in sync schema");
        var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
        out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
      } else {
        out += " if (! ";
        var $formatRef = "formats" + it.util.getProperty($schema);
        if ($isObject)
          $formatRef += ".validate";
        if (typeof $format == "function") {
          out += " " + $formatRef + "(" + $data + ") ";
        } else {
          out += " " + $formatRef + ".test(" + $data + ") ";
        }
        out += ") { ";
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "format" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS((exports, module) => {
  module.exports = function generate_if(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += " if (" + $nextValid + ") {  ";
        $it.schema = it.schema["then"];
        $it.schemaPath = it.schemaPath + ".then";
        $it.errSchemaPath = it.errSchemaPath + "/then";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += " } ";
        if ($elsePresent) {
          out += " else { ";
        }
      } else {
        out += " if (!" + $nextValid + ") { ";
      }
      if ($elsePresent) {
        $it.schema = it.schema["else"];
        $it.schemaPath = it.schemaPath + ".else";
        $it.errSchemaPath = it.errSchemaPath + "/else";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += " } ";
      }
      out += " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + "if" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " }   ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS((exports, module) => {
  module.exports = function generate_items(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema)) {
      var $additionalItems = it.schema.additionalItems;
      if ($additionalItems === false) {
        out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + "additionalItems" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have more than " + $schema.length + " items' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
            var $passData = $data + "[" + $i + "]";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
            $it.dataPathArr[$dataNxt] = $i;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
        $it.schema = $additionalItems;
        $it.schemaPath = it.schemaPath + ".additionalItems";
        $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " } }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limit.js
var require__limit = __commonJS((exports, module) => {
  module.exports = function generate__limit(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = undefined;
    if (!($isData || typeof $schema == "number" || $schema === undefined)) {
      throw new Error($keyword + " must be number");
    }
    if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
      throw new Error($exclusiveKeyword + " must be number or boolean");
    }
    if ($isDataExcl) {
      var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
      $schemaValueExcl = "schemaExcl" + $lvl;
      out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
      if ($schema === undefined) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
      } else {
        if ($exclIsNumber && $schema === undefined) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += "=";
        } else {
          if ($exclIsNumber)
            $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $notOp += "=";
          } else {
            $exclusive = false;
            $opStr += "=";
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + " ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require__limitItems = __commonJS((exports, module) => {
  module.exports = function generate__limitItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxItems") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " items' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require__limitLength = __commonJS((exports, module) => {
  module.exports = function generate__limitLength(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    if (it.opts.unicode === false) {
      out += " " + $data + ".length ";
    } else {
      out += " ucs2length(" + $data + ") ";
    }
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == "maxLength") {
          out += "longer";
        } else {
          out += "shorter";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " characters' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require__limitProperties = __commonJS((exports, module) => {
  module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxProperties") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " properties' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS((exports, module) => {
  module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    out += "var division" + $lvl + ";if (";
    if ($isData) {
      out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    }
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it.opts.multipleOfPrecision) {
      out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
    } else {
      out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    }
    out += " ) ";
    if ($isData) {
      out += "  )  ";
    }
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "multipleOf" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS((exports, module) => {
  module.exports = function generate_not(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += " " + it.validate($it) + " ";
      $it.createErrors = true;
      if ($allErrorsOption)
        $it.opts.allErrors = $allErrorsOption;
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (" + $nextValid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + "not" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      out += "  var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + "not" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if ($breakOnError) {
        out += " if (false) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS((exports, module) => {
  module.exports = function generate_oneOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
        } else {
          out += " var " + $nextValid + " = true; ";
        }
        if ($i) {
          out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
          $closingBraces += "}";
        }
        out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "oneOf" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS((exports, module) => {
  module.exports = function generate_pattern(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + "pattern" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS((exports, module) => {
  module.exports = function generate_properties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
      var $requiredHash = it.util.toHash($required);
    }
    function notProto(p) {
      return p !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined;";
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      if ($someProperties) {
        out += " var isAdditional" + $lvl + " = !(false ";
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[i1 += 1];
                out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $pProperty = arr2[$i += 1];
              out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
            }
          }
        }
        out += " ); if (isAdditional" + $lvl + ") { ";
      }
      if ($removeAdditional == "all") {
        out += " delete " + $data + "[" + $key + "]; ";
      } else {
        var $currentErrorPath = it.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            out += " " + $nextValid + " = false; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalProperties";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + "additionalProperties" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is an invalid additional property";
                } else {
                  out += "should NOT have additional properties";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += " break; ";
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == "failing") {
            out += " var " + $errs + " = errors;  ";
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
            it.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
          }
        }
        it.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += " } ";
      }
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[i3 += 1];
          var $sch = $schema[$propertyKey];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== undefined;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
            $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
            $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              $code = it.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += " var " + $nextData + " = " + $passData + "; ";
            }
            if ($hasDefault) {
              out += " " + $code + " ";
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = false; ";
                var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                $errSchemaPath = it.errSchemaPath + "/required";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: '" + "required" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                it.errorPath = $currentErrorPath;
                out += " } else { ";
              } else {
                if ($breakOnError) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = true; } else { ";
                } else {
                  out += " if (" + $useData + " !== undefined ";
                  if ($ownProperties) {
                    out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += " ) { ";
                }
              }
              out += " " + $code + " } ";
            }
          }
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty, i4 = -1, l4 = arr4.length - 1;
        while (i4 < l4) {
          $pProperty = arr4[i4 += 1];
          var $sch = $pProperties[$pProperty];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
            $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
            } else {
              out += " for (var " + $key + " in " + $data + ") { ";
            }
            out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else " + $nextValid + " = true; ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS((exports, module) => {
  module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined; ";
      }
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      out += " var startErrs" + $lvl + " = errors; ";
      var $passData = $key;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + "propertyNames" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
        if (it.opts.messages !== false) {
          out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      if ($breakOnError) {
        out += " break; ";
      }
      out += " } }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS((exports, module) => {
  module.exports = function generate_required(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
      if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
        var $required = [];
        var arr1 = $schema;
        if (arr1) {
          var $property, i1 = -1, l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[i1 += 1];
            var $propertySch = it.schema.properties[$property];
            if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
      if ($breakOnError) {
        out += " var missing" + $lvl + "; ";
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          out += " var " + $valid + " = true; ";
          if ($isData) {
            out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
          if ($ownProperties) {
            out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += "; if (!" + $valid + ") break; } ";
          if ($isData) {
            out += "  }  ";
          }
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + "required" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        } else {
          out += " if ( ";
          var arr2 = $required;
          if (arr2) {
            var $propertyKey, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $propertyKey = arr2[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ") {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + "required" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          if ($isData) {
            out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: '" + "required" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
          if ($ownProperties) {
            out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += ") {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + "required" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
          if ($isData) {
            out += "  }  ";
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: '" + "required" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
      }
      it.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += " if (true) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS((exports, module) => {
  module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (($schema || $isData) && it.opts.uniqueItems !== false) {
      if ($isData) {
        out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
      }
      out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
      var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
      if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
        out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
      } else {
        out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
        var $method = "checkDataType" + ($typeIsArray ? "s" : "");
        out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      out += " } ";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + "uniqueItems" + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS((exports, module) => {
  module.exports = {
    $ref: require_ref(),
    allOf: require_allOf(),
    anyOf: require_anyOf(),
    $comment: require_comment(),
    const: require_const(),
    contains: require_contains(),
    dependencies: require_dependencies(),
    enum: require_enum(),
    format: require_format(),
    if: require_if(),
    items: require_items(),
    maximum: require__limit(),
    minimum: require__limit(),
    maxItems: require__limitItems(),
    minItems: require__limitItems(),
    maxLength: require__limitLength(),
    minLength: require__limitLength(),
    maxProperties: require__limitProperties(),
    minProperties: require__limitProperties(),
    multipleOf: require_multipleOf(),
    not: require_not(),
    oneOf: require_oneOf(),
    pattern: require_pattern(),
    properties: require_properties(),
    propertyNames: require_propertyNames(),
    required: require_required(),
    uniqueItems: require_uniqueItems(),
    validate: require_validate2()
  };
});

// node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS((exports, module) => {
  var ruleModules = require_dotjs();
  var toHash = require_util3().toHash;
  module.exports = function rules() {
    var RULES = [
      {
        type: "number",
        rules: [
          { maximum: ["exclusiveMaximum"] },
          { minimum: ["exclusiveMinimum"] },
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          { properties: ["additionalProperties", "patternProperties"] }
        ]
      },
      { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
    ];
    var ALL = ["type", "$comment"];
    var KEYWORDS = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ];
    var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
      group.rules = group.rules.map(function(keyword) {
        var implKeywords;
        if (typeof keyword == "object") {
          var key = Object.keys(keyword)[0];
          implKeywords = keyword[key];
          keyword = key;
          implKeywords.forEach(function(k) {
            ALL.push(k);
            RULES.all[k] = true;
          });
        }
        ALL.push(keyword);
        var rule = RULES.all[keyword] = {
          keyword,
          code: ruleModules[keyword],
          implements: implKeywords
        };
        return rule;
      });
      RULES.all.$comment = {
        keyword: "$comment",
        code: ruleModules.$comment
      };
      if (group.type)
        RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS((exports, module) => {
  var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  module.exports = function(metaSchema, keywordsJsonPointers) {
    for (var i = 0;i < keywordsJsonPointers.length; i++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i].split("/");
      var keywords = metaSchema;
      var j;
      for (j = 1;j < segments.length; j++)
        keywords = keywords[segments[j]];
      for (j = 0;j < KEYWORDS.length; j++) {
        var key = KEYWORDS[j];
        var schema = keywords[key];
        if (schema) {
          keywords[key] = {
            anyOf: [
              schema,
              { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
      }
    }
    return metaSchema;
  };
});

// node_modules/ajv/lib/compile/async.js
var require_async3 = __commonJS((exports, module) => {
  var MissingRefError = require_error_classes().MissingRef;
  module.exports = compileAsync;
  function compileAsync(schema, meta, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
      callback = meta;
      meta = undefined;
    }
    var p = loadMetaSchemaOf(schema).then(function() {
      var schemaObj = self2._addSchema(schema, undefined, meta);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p.then(function(v) {
        callback(null, v);
      }, callback);
    }
    return p;
    function loadMetaSchemaOf(sch) {
      var $schema = sch.$schema;
      return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e) {
        if (e instanceof MissingRefError)
          return loadMissingSchema(e);
        throw e;
      }
      function loadMissingSchema(e) {
        var ref = e.missingSchema;
        if (added(ref))
          throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
        var schemaPromise = self2._loadingSchemas[ref];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise.then(function(sch) {
          if (!added(ref)) {
            return loadMetaSchemaOf(sch).then(function() {
              if (!added(ref))
                self2.addSchema(sch, ref, undefined, meta);
            });
          }
        }).then(function() {
          return _compileAsync(schemaObj);
        });
        function removePromise() {
          delete self2._loadingSchemas[ref];
        }
        function added(ref2) {
          return self2._refs[ref2] || self2._schemas[ref2];
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS((exports, module) => {
  module.exports = function generate_custom(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = "keywordValidate" + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
      $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
      if (!$ruleValidate)
        return;
      $schemaValue = "validate.schema" + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async)
      throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) {
      out += "" + $ruleErrs + " = null;";
    }
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
      $closingBraces += "}";
      out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
      if ($validateSchema) {
        $closingBraces += "}";
        out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += " " + $ruleValidate.validate + " ";
      } else {
        out += " " + $valid + " = " + $ruleValidate.validate + "; ";
      }
    } else if ($macro) {
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = "";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      out += "  " + $validateCode + ".call( ";
      if (it.opts.passContext) {
        out += "this";
      } else {
        out += "self";
      }
      if ($compile || $rDef.schema === false) {
        out += " , " + $data + " ";
      } else {
        out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
      }
      out += " , (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += " " + $valid + " = ";
        if ($asyncKeyword) {
          out += "await ";
        }
        out += "" + def_callRuleValidate + "; ";
      } else {
        if ($asyncKeyword) {
          $ruleErrs = "customErrors" + $lvl;
          out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else {
          out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
        }
      }
    }
    if ($rDef.modifying) {
      out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    }
    out += "" + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    } else {
      out += " if ( ";
      if ($rDef.valid === undefined) {
        out += " !";
        if ($macro) {
          out += "" + $nextValid;
        } else {
          out += "" + $valid;
        }
      } else {
        out += " " + !$rDef.valid + " ";
      }
      out += ") { ";
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != "full") {
            out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } ";
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } ";
          }
        }
      } else if ($macro) {
        out += "   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } else { " + def_customError + " } ";
        }
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          { $ref: "#/definitions/nonNegativeInteger" },
          { default: 0 }
        ]
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [
          { $ref: "#" },
          { $ref: "#/definitions/schemaArray" }
        ],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/stringArray" }
          ]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS((exports, module) => {
  var metaSchema = require_json_schema_draft_07();
  module.exports = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } }
    },
    properties: {
      type: metaSchema.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: {
        type: "array",
        items: { type: "string" }
      },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: {
        anyOf: [
          { type: "boolean" },
          { const: "full" }
        ]
      }
    }
  };
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS((exports, module) => {
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = require_custom();
  var definitionSchema = require_definition_schema();
  module.exports = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
  };
  function addKeyword(keyword, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword])
      throw new Error("Keyword " + keyword + " is already defined");
    if (!IDENTIFIER.test(keyword))
      throw new Error("Keyword " + keyword + " is not a valid identifier");
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType = definition.type;
      if (Array.isArray(dataType)) {
        for (var i = 0;i < dataType.length; i++)
          _addRule(keyword, dataType[i], definition);
      } else {
        _addRule(keyword, dataType, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword] = RULES.all[keyword] = true;
    function _addRule(keyword2, dataType2, definition2) {
      var ruleGroup;
      for (var i2 = 0;i2 < RULES.length; i2++) {
        var rg = RULES[i2];
        if (rg.type == dataType2) {
          ruleGroup = rg;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword2,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword2] = rule;
    }
    return this;
  }
  function getKeyword(keyword) {
    var rule = this.RULES.custom[keyword];
    return rule ? rule.definition : this.RULES.keywords[keyword] || false;
  }
  function removeKeyword(keyword) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword];
    delete RULES.all[keyword];
    delete RULES.custom[keyword];
    for (var i = 0;i < RULES.length; i++) {
      var rules = RULES[i].rules;
      for (var j = 0;j < rules.length; j++) {
        if (rules[j].keyword == keyword) {
          rules.splice(j, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition))
      return true;
    validateKeyword.errors = v.errors;
    if (throwError)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else
      return false;
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON Schema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [
          { format: "relative-json-pointer" },
          { format: "json-pointer" }
        ]
      }
    },
    additionalProperties: false
  };
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS((exports, module) => {
  var compileSchema = require_compile();
  var resolve = require_resolve();
  var Cache = require_cache();
  var SchemaObject = require_schema_obj();
  var stableStringify = require_fast_json_stable_stringify();
  var formats = require_formats2();
  var rules = require_rules();
  var $dataMetaSchema = require_data();
  var util = require_util3();
  module.exports = Ajv;
  Ajv.prototype.validate = validate;
  Ajv.prototype.compile = compile;
  Ajv.prototype.addSchema = addSchema;
  Ajv.prototype.addMetaSchema = addMetaSchema;
  Ajv.prototype.validateSchema = validateSchema;
  Ajv.prototype.getSchema = getSchema;
  Ajv.prototype.removeSchema = removeSchema;
  Ajv.prototype.addFormat = addFormat;
  Ajv.prototype.errorsText = errorsText;
  Ajv.prototype._addSchema = _addSchema;
  Ajv.prototype._compile = _compile;
  Ajv.prototype.compileAsync = require_async3();
  var customKeyword = require_keyword();
  Ajv.prototype.addKeyword = customKeyword.add;
  Ajv.prototype.getKeyword = customKeyword.get;
  Ajv.prototype.removeKeyword = customKeyword.remove;
  Ajv.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = require_error_classes();
  Ajv.ValidationError = errorClasses.Validation;
  Ajv.MissingRefError = errorClasses.MissingRef;
  Ajv.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
  var META_SUPPORT_DATA = ["/properties"];
  function Ajv(opts) {
    if (!(this instanceof Ajv))
      return new Ajv(opts);
    opts = this._opts = util.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache;
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property")
      opts._errorDataPathProperty = true;
    if (opts.serialize === undefined)
      opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats)
      addInitialFormats(this);
    if (opts.keywords)
      addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object")
      this.addMetaSchema(opts.meta);
    if (opts.nullable)
      this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
    addInitialSchemas(this);
  }
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == "string") {
      v = this.getSchema(schemaKeyRef);
      if (!v)
        throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data);
    if (v.$async !== true)
      this.errors = v.errors;
    return valid;
  }
  function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, undefined, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i = 0;i < schema.length; i++)
        this.addSchema(schema[i], undefined, _skipValidation, _meta);
      return this;
    }
    var id = this._getId(schema);
    if (id !== undefined && typeof id != "string")
      throw new Error("schema id must be string");
    key = resolve.normalizeId(key || id);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema;
    if ($schema !== undefined && typeof $schema != "string")
      throw new Error("$schema must be a string");
    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema) {
      this.logger.warn("meta-schema not available");
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
      var message = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log")
        this.logger.error(message);
      else
        throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta = self2._opts.meta;
    self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case "object":
        return schemaObj.validate || this._compile(schemaObj);
      case "string":
        return this.getSchema(schemaObj);
      case "undefined":
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref) {
    var res = resolve.schema.call(self2, { schema: {} }, ref);
    if (res) {
      var { schema, root, baseId } = res;
      var v = compileSchema.call(self2, schema, root, undefined, baseId);
      self2._fragments[ref] = new SchemaObject({
        ref,
        fragment: true,
        schema,
        root,
        baseId,
        validate: v
      });
      return v;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case "undefined":
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case "string":
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj)
          this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case "object":
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id = this._getId(schemaKeyRef);
        if (id) {
          id = resolve.normalizeId(id);
          delete this._schemas[id];
          delete this._refs[id];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean")
      throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached)
      return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema)
      checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
      this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id,
      schema,
      localRefs,
      cacheKey,
      meta
    });
    if (id[0] != "#" && shouldAddSchema)
      this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta)
      this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v;
    try {
      v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
      delete schemaObj.validate;
      throw e;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta)
        this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case "auto":
        return _get$IdOrId;
      case "id":
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id)
      this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id)
      this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
  }
  function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors)
      return "No errors";
    options = options || {};
    var separator = options.separator === undefined ? ", " : options.separator;
    var dataVar = options.dataVar === undefined ? "data" : options.dataVar;
    var text = "";
    for (var i = 0;i < errors.length; i++) {
      var e = errors[i];
      if (e)
        text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name, format) {
    if (typeof format == "string")
      format = new RegExp(format);
    this._formats[name] = format;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require_data2();
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false)
      return;
    var metaSchema = require_json_schema_draft_07();
    if (self2._opts.$data)
      metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      self2.addSchema(optsSchemas);
    else
      for (var key in optsSchemas)
        self2.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats(self2) {
    for (var name in self2._opts.formats) {
      var format = self2._opts.formats[name];
      self2.addFormat(name, format);
    }
  }
  function addInitialKeywords(self2) {
    for (var name in self2._opts.keywords) {
      var keyword = self2._opts.keywords[name];
      self2.addKeyword(name, keyword);
    }
  }
  function checkUnique(self2, id) {
    if (self2._schemas[id] || self2._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util.copy(self2._opts);
    for (var i = 0;i < META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = { log: noop, warn: noop, error: noop };
    } else {
      if (logger === undefined)
        logger = console;
      if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
        throw new Error("logger must implement log, warn and error methods");
      self2.logger = logger;
    }
  }
  function noop() {}
});

// node_modules/har-validator/lib/error.js
var require_error = __commonJS((exports, module) => {
  function HARError(errors) {
    var message = "validation failed";
    this.name = "HARError";
    this.message = message;
    this.errors = errors;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
  HARError.prototype = Error.prototype;
  module.exports = HARError;
});

// node_modules/har-schema/lib/afterRequest.json
var require_afterRequest = __commonJS((exports, module) => {
  module.exports = {
    $id: "afterRequest.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "lastAccess",
      "eTag",
      "hitCount"
    ],
    properties: {
      expires: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      lastAccess: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      eTag: {
        type: "string"
      },
      hitCount: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/beforeRequest.json
var require_beforeRequest = __commonJS((exports, module) => {
  module.exports = {
    $id: "beforeRequest.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "lastAccess",
      "eTag",
      "hitCount"
    ],
    properties: {
      expires: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      lastAccess: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      eTag: {
        type: "string"
      },
      hitCount: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/browser.json
var require_browser2 = __commonJS((exports, module) => {
  module.exports = {
    $id: "browser.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "version"
    ],
    properties: {
      name: {
        type: "string"
      },
      version: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/cache.json
var require_cache2 = __commonJS((exports, module) => {
  module.exports = {
    $id: "cache.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    properties: {
      beforeRequest: {
        oneOf: [
          { type: "null" },
          { $ref: "beforeRequest.json#" }
        ]
      },
      afterRequest: {
        oneOf: [
          { type: "null" },
          { $ref: "afterRequest.json#" }
        ]
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/content.json
var require_content = __commonJS((exports, module) => {
  module.exports = {
    $id: "content.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "size",
      "mimeType"
    ],
    properties: {
      size: {
        type: "integer"
      },
      compression: {
        type: "integer"
      },
      mimeType: {
        type: "string"
      },
      text: {
        type: "string"
      },
      encoding: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/cookie.json
var require_cookie2 = __commonJS((exports, module) => {
  module.exports = {
    $id: "cookie.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "value"
    ],
    properties: {
      name: {
        type: "string"
      },
      value: {
        type: "string"
      },
      path: {
        type: "string"
      },
      domain: {
        type: "string"
      },
      expires: {
        type: ["string", "null"],
        format: "date-time"
      },
      httpOnly: {
        type: "boolean"
      },
      secure: {
        type: "boolean"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/creator.json
var require_creator = __commonJS((exports, module) => {
  module.exports = {
    $id: "creator.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "version"
    ],
    properties: {
      name: {
        type: "string"
      },
      version: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/entry.json
var require_entry = __commonJS((exports, module) => {
  module.exports = {
    $id: "entry.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "startedDateTime",
      "time",
      "request",
      "response",
      "cache",
      "timings"
    ],
    properties: {
      pageref: {
        type: "string"
      },
      startedDateTime: {
        type: "string",
        format: "date-time",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
      },
      time: {
        type: "number",
        min: 0
      },
      request: {
        $ref: "request.json#"
      },
      response: {
        $ref: "response.json#"
      },
      cache: {
        $ref: "cache.json#"
      },
      timings: {
        $ref: "timings.json#"
      },
      serverIPAddress: {
        type: "string",
        oneOf: [
          { format: "ipv4" },
          { format: "ipv6" }
        ]
      },
      connection: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/har.json
var require_har = __commonJS((exports, module) => {
  module.exports = {
    $id: "har.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "log"
    ],
    properties: {
      log: {
        $ref: "log.json#"
      }
    }
  };
});

// node_modules/har-schema/lib/header.json
var require_header = __commonJS((exports, module) => {
  module.exports = {
    $id: "header.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "value"
    ],
    properties: {
      name: {
        type: "string"
      },
      value: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/log.json
var require_log = __commonJS((exports, module) => {
  module.exports = {
    $id: "log.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "version",
      "creator",
      "entries"
    ],
    properties: {
      version: {
        type: "string"
      },
      creator: {
        $ref: "creator.json#"
      },
      browser: {
        $ref: "browser.json#"
      },
      pages: {
        type: "array",
        items: {
          $ref: "page.json#"
        }
      },
      entries: {
        type: "array",
        items: {
          $ref: "entry.json#"
        }
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/page.json
var require_page = __commonJS((exports, module) => {
  module.exports = {
    $id: "page.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "startedDateTime",
      "id",
      "title",
      "pageTimings"
    ],
    properties: {
      startedDateTime: {
        type: "string",
        format: "date-time",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
      },
      id: {
        type: "string",
        unique: true
      },
      title: {
        type: "string"
      },
      pageTimings: {
        $ref: "pageTimings.json#"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/pageTimings.json
var require_pageTimings = __commonJS((exports, module) => {
  module.exports = {
    $id: "pageTimings.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    properties: {
      onContentLoad: {
        type: "number",
        min: -1
      },
      onLoad: {
        type: "number",
        min: -1
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/postData.json
var require_postData = __commonJS((exports, module) => {
  module.exports = {
    $id: "postData.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "mimeType"
    ],
    properties: {
      mimeType: {
        type: "string"
      },
      text: {
        type: "string"
      },
      params: {
        type: "array",
        required: [
          "name"
        ],
        properties: {
          name: {
            type: "string"
          },
          value: {
            type: "string"
          },
          fileName: {
            type: "string"
          },
          contentType: {
            type: "string"
          },
          comment: {
            type: "string"
          }
        }
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/query.json
var require_query = __commonJS((exports, module) => {
  module.exports = {
    $id: "query.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "value"
    ],
    properties: {
      name: {
        type: "string"
      },
      value: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/request.json
var require_request = __commonJS((exports, module) => {
  module.exports = {
    $id: "request.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "method",
      "url",
      "httpVersion",
      "cookies",
      "headers",
      "queryString",
      "headersSize",
      "bodySize"
    ],
    properties: {
      method: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      },
      httpVersion: {
        type: "string"
      },
      cookies: {
        type: "array",
        items: {
          $ref: "cookie.json#"
        }
      },
      headers: {
        type: "array",
        items: {
          $ref: "header.json#"
        }
      },
      queryString: {
        type: "array",
        items: {
          $ref: "query.json#"
        }
      },
      postData: {
        $ref: "postData.json#"
      },
      headersSize: {
        type: "integer"
      },
      bodySize: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/response.json
var require_response = __commonJS((exports, module) => {
  module.exports = {
    $id: "response.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "status",
      "statusText",
      "httpVersion",
      "cookies",
      "headers",
      "content",
      "redirectURL",
      "headersSize",
      "bodySize"
    ],
    properties: {
      status: {
        type: "integer"
      },
      statusText: {
        type: "string"
      },
      httpVersion: {
        type: "string"
      },
      cookies: {
        type: "array",
        items: {
          $ref: "cookie.json#"
        }
      },
      headers: {
        type: "array",
        items: {
          $ref: "header.json#"
        }
      },
      content: {
        $ref: "content.json#"
      },
      redirectURL: {
        type: "string"
      },
      headersSize: {
        type: "integer"
      },
      bodySize: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/timings.json
var require_timings = __commonJS((exports, module) => {
  module.exports = {
    $id: "timings.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    required: [
      "send",
      "wait",
      "receive"
    ],
    properties: {
      dns: {
        type: "number",
        min: -1
      },
      connect: {
        type: "number",
        min: -1
      },
      blocked: {
        type: "number",
        min: -1
      },
      send: {
        type: "number",
        min: -1
      },
      wait: {
        type: "number",
        min: -1
      },
      receive: {
        type: "number",
        min: -1
      },
      ssl: {
        type: "number",
        min: -1
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  module.exports = {
    afterRequest: require_afterRequest(),
    beforeRequest: require_beforeRequest(),
    browser: require_browser2(),
    cache: require_cache2(),
    content: require_content(),
    cookie: require_cookie2(),
    creator: require_creator(),
    entry: require_entry(),
    har: require_har(),
    header: require_header(),
    log: require_log(),
    page: require_page(),
    pageTimings: require_pageTimings(),
    postData: require_postData(),
    query: require_query(),
    request: require_request(),
    response: require_response(),
    timings: require_timings()
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-06.json
var require_json_schema_draft_06 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-06/schema#",
    $id: "http://json-schema.org/draft-06/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          { $ref: "#/definitions/nonNegativeInteger" },
          { default: 0 }
        ]
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: {},
      examples: {
        type: "array",
        items: {}
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [
          { $ref: "#" },
          { $ref: "#/definitions/schemaArray" }
        ],
        default: {}
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/stringArray" }
          ]
        }
      },
      propertyNames: { $ref: "#" },
      const: {},
      enum: {
        type: "array",
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: {}
  };
});

// node_modules/har-validator/lib/promise.js
var require_promise2 = __commonJS((exports) => {
  var Ajv = require_ajv();
  var HARError = require_error();
  var schemas = require_lib5();
  var ajv;
  function createAjvInstance() {
    var ajv2 = new Ajv({
      allErrors: true
    });
    ajv2.addMetaSchema(require_json_schema_draft_06());
    ajv2.addSchema(schemas);
    return ajv2;
  }
  function validate(name, data) {
    data = data || {};
    ajv = ajv || createAjvInstance();
    var validate2 = ajv.getSchema(name + ".json");
    return new Promise(function(resolve, reject) {
      var valid = validate2(data);
      !valid ? reject(new HARError(validate2.errors)) : resolve(data);
    });
  }
  exports.afterRequest = function(data) {
    return validate("afterRequest", data);
  };
  exports.beforeRequest = function(data) {
    return validate("beforeRequest", data);
  };
  exports.browser = function(data) {
    return validate("browser", data);
  };
  exports.cache = function(data) {
    return validate("cache", data);
  };
  exports.content = function(data) {
    return validate("content", data);
  };
  exports.cookie = function(data) {
    return validate("cookie", data);
  };
  exports.creator = function(data) {
    return validate("creator", data);
  };
  exports.entry = function(data) {
    return validate("entry", data);
  };
  exports.har = function(data) {
    return validate("har", data);
  };
  exports.header = function(data) {
    return validate("header", data);
  };
  exports.log = function(data) {
    return validate("log", data);
  };
  exports.page = function(data) {
    return validate("page", data);
  };
  exports.pageTimings = function(data) {
    return validate("pageTimings", data);
  };
  exports.postData = function(data) {
    return validate("postData", data);
  };
  exports.query = function(data) {
    return validate("query", data);
  };
  exports.request = function(data) {
    return validate("request", data);
  };
  exports.response = function(data) {
    return validate("response", data);
  };
  exports.timings = function(data) {
    return validate("timings", data);
  };
});

// node_modules/postman-request/lib/har.js
var require_har2 = __commonJS((exports) => {
  var fs = __require("fs");
  var qs = __require("querystring");
  var validate = require_promise2();
  var extend = require_extend();
  function Har(request) {
    this.request = request;
  }
  Har.prototype.reducer = function(obj2, pair) {
    if (obj2[pair.name] === undefined) {
      obj2[pair.name] = pair.value;
      return obj2;
    }
    var arr = [
      obj2[pair.name],
      pair.value
    ];
    obj2[pair.name] = arr;
    return obj2;
  };
  Har.prototype.prep = function(data) {
    data.queryObj = {};
    data.headersObj = {};
    data.postData.jsonObj = false;
    data.postData.paramsObj = false;
    if (data.queryString && data.queryString.length) {
      data.queryObj = data.queryString.reduce(this.reducer, {});
    }
    if (data.headers && data.headers.length) {
      data.headersObj = data.headers.reduceRight(function(headers, header) {
        headers[header.name] = header.value;
        return headers;
      }, {});
    }
    if (data.cookies && data.cookies.length) {
      var cookies = data.cookies.map(function(cookie) {
        return cookie.name + "=" + cookie.value;
      });
      if (cookies.length) {
        data.headersObj.cookie = cookies.join("; ");
      }
    }
    function some(arr) {
      return arr.some(function(type) {
        return data.postData.mimeType.indexOf(type) === 0;
      });
    }
    if (some([
      "multipart/mixed",
      "multipart/related",
      "multipart/form-data",
      "multipart/alternative"
    ])) {
      data.postData.mimeType = "multipart/form-data";
    } else if (some([
      "application/x-www-form-urlencoded"
    ])) {
      if (!data.postData.params) {
        data.postData.text = "";
      } else {
        data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});
        data.postData.text = qs.stringify(data.postData.paramsObj);
      }
    } else if (some([
      "text/json",
      "text/x-json",
      "application/json",
      "application/x-json"
    ])) {
      data.postData.mimeType = "application/json";
      if (data.postData.text) {
        try {
          data.postData.jsonObj = JSON.parse(data.postData.text);
        } catch (e) {
          this.request.debug(e);
          data.postData.mimeType = "text/plain";
        }
      }
    }
    return data;
  };
  Har.prototype.options = function(options) {
    if (!options.har) {
      return options;
    }
    var har = {};
    extend(har, options.har);
    if (har.log && har.log.entries) {
      har = har.log.entries[0];
    }
    har.url = har.url || options.url || options.uri || options.baseUrl || "/";
    har.httpVersion = har.httpVersion || "HTTP/1.1";
    har.queryString = har.queryString || [];
    har.headers = har.headers || [];
    har.cookies = har.cookies || [];
    har.postData = har.postData || {};
    har.postData.mimeType = har.postData.mimeType || "application/octet-stream";
    har.bodySize = 0;
    har.headersSize = 0;
    har.postData.size = 0;
    if (!validate.request(har)) {
      return options;
    }
    var req = this.prep(har);
    if (req.url) {
      options.url = req.url;
    }
    if (req.method) {
      options.method = req.method;
    }
    if (Object.keys(req.queryObj).length) {
      options.qs = req.queryObj;
    }
    if (Object.keys(req.headersObj).length) {
      options.headers = req.headersObj;
    }
    function test(type) {
      return req.postData.mimeType.indexOf(type) === 0;
    }
    if (test("application/x-www-form-urlencoded")) {
      options.form = req.postData.paramsObj;
    } else if (test("application/json")) {
      if (req.postData.jsonObj) {
        options.body = req.postData.jsonObj;
        options.json = true;
      }
    } else if (test("multipart/form-data")) {
      options.formData = {};
      req.postData.params.forEach(function(param) {
        var attachment = {};
        if (!param.fileName && !param.contentType) {
          options.formData[param.name] = param.value;
          return;
        }
        if (param.fileName && !param.value) {
          attachment.value = fs.createReadStream(param.fileName);
        } else if (param.value) {
          attachment.value = param.value;
        }
        if (param.fileName) {
          attachment.options = {
            filename: param.fileName,
            contentType: param.contentType ? param.contentType : null
          };
        }
        options.formData[param.name] = attachment;
      });
    } else {
      if (req.postData.text) {
        options.body = req.postData.text;
      }
    }
    return options;
  };
  exports.Har = Har;
});

// node_modules/postman-request/lib/auth.js
var require_auth = __commonJS((exports) => {
  var caseless = require_caseless();
  var uuid = require_v4();
  var helpers = require_helpers();
  var md5 = helpers.md5;
  var toBase64 = helpers.toBase64;
  function Auth(request) {
    this.request = request;
    this.hasAuth = false;
    this.sentAuth = false;
    this.bearerToken = null;
    this.user = null;
    this.pass = null;
  }
  Auth.prototype.basic = function(user, pass, sendImmediately) {
    var self2 = this;
    if (typeof user !== "string" || pass !== undefined && typeof pass !== "string") {
      self2.request.emit("error", new Error("auth() received invalid user or password"));
    }
    self2.user = user;
    self2.pass = pass;
    self2.hasAuth = true;
    var header = user + ":" + (pass || "");
    if (sendImmediately || typeof sendImmediately === "undefined") {
      var authHeader = "Basic " + toBase64(header);
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.bearer = function(bearer, sendImmediately) {
    var self2 = this;
    self2.bearerToken = bearer;
    self2.hasAuth = true;
    if (sendImmediately || typeof sendImmediately === "undefined") {
      if (typeof bearer === "function") {
        bearer = bearer();
      }
      var authHeader = "Bearer " + (bearer || "");
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.digest = function(method, path, authHeader) {
    var self2 = this;
    var challenge = {};
    var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
    while (true) {
      var match = re.exec(authHeader);
      if (!match) {
        break;
      }
      challenge[match[1]] = match[2] || match[3];
    }
    var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
      var ha12 = md5(user + ":" + realm + ":" + pass);
      if (algorithm && algorithm.toLowerCase() === "md5-sess") {
        return md5(ha12 + ":" + nonce + ":" + cnonce2);
      } else {
        return ha12;
      }
    };
    var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
    var nc = qop && "00000001";
    var cnonce = qop && uuid().replace(/-/g, "");
    var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
    var ha2 = md5(method + ":" + path);
    var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
    var authValues = {
      username: self2.user,
      realm: challenge.realm,
      nonce: challenge.nonce,
      uri: path,
      qop,
      response: digestResponse,
      nc,
      cnonce,
      algorithm: challenge.algorithm,
      opaque: challenge.opaque
    };
    authHeader = [];
    for (var k in authValues) {
      if (authValues[k]) {
        if (k === "qop" || k === "nc" || k === "algorithm") {
          authHeader.push(k + "=" + authValues[k]);
        } else {
          authHeader.push(k + '="' + authValues[k] + '"');
        }
      }
    }
    authHeader = "Digest " + authHeader.join(", ");
    self2.sentAuth = true;
    return authHeader;
  };
  Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    var request = self2.request;
    var authHeader;
    if (bearer === undefined && user === undefined) {
      self2.request.emit("error", new Error("no auth mechanism defined"));
    } else if (bearer !== undefined) {
      authHeader = self2.bearer(bearer, sendImmediately);
    } else {
      authHeader = self2.basic(user, pass, sendImmediately);
    }
    if (authHeader) {
      request.setHeader("authorization", authHeader);
    }
  };
  Auth.prototype.onResponse = function(response) {
    var self2 = this;
    var request = self2.request;
    if (!self2.hasAuth || self2.sentAuth) {
      return null;
    }
    var c = caseless(response.headers);
    var authHeader = c.get("www-authenticate");
    var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
    request.debug("reauth", authVerb);
    switch (authVerb) {
      case "basic":
        return self2.basic(self2.user, self2.pass, true);
      case "bearer":
        return self2.bearer(self2.bearerToken, true);
      case "digest":
        return self2.digest(request.method, request.path, authHeader);
    }
  };
  exports.Auth = Auth;
});

// node_modules/oauth-sign/index.js
var require_oauth_sign = __commonJS((exports) => {
  var crypto = __require("crypto");
  function sha(key, body, algorithm) {
    return crypto.createHmac(algorithm, key).update(body).digest("base64");
  }
  function rsa(key, body) {
    return crypto.createSign("RSA-SHA1").update(body).sign(key, "base64");
  }
  function rfc3986(str) {
    return encodeURIComponent(str).replace(/!/g, "%21").replace(/\*/g, "%2A").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27");
  }
  function map(obj2) {
    var key, val, arr = [];
    for (key in obj2) {
      val = obj2[key];
      if (Array.isArray(val))
        for (var i = 0;i < val.length; i++)
          arr.push([key, val[i]]);
      else if (typeof val === "object")
        for (var prop in val)
          arr.push([key + "[" + prop + "]", val[prop]]);
      else
        arr.push([key, val]);
    }
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  function generateBase(httpMethod, base_uri, params) {
    var normalized = map(params).map(function(p) {
      return [rfc3986(p[0]), rfc3986(p[1] || "")];
    }).sort(function(a, b) {
      return compare(a[0], b[0]) || compare(a[1], b[1]);
    }).map(function(p) {
      return p.join("=");
    }).join("&");
    var base = [
      rfc3986(httpMethod ? httpMethod.toUpperCase() : "GET"),
      rfc3986(base_uri),
      rfc3986(normalized)
    ].join("&");
    return base;
  }
  function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return sha(key, base, "sha1");
  }
  function hmacsign256(httpMethod, base_uri, params, consumer_secret, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return sha(key, base, "sha256");
  }
  function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = private_key || "";
    return rsa(key, base);
  }
  function plaintext(consumer_secret, token_secret) {
    var key = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return key;
  }
  function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
    var method;
    var skipArgs = 1;
    switch (signMethod) {
      case "RSA-SHA1":
        method = rsasign;
        break;
      case "HMAC-SHA1":
        method = hmacsign;
        break;
      case "HMAC-SHA256":
        method = hmacsign256;
        break;
      case "PLAINTEXT":
        method = plaintext;
        skipArgs = 4;
        break;
      default:
        throw new Error("Signature method not supported: " + signMethod);
    }
    return method.apply(null, [].slice.call(arguments, skipArgs));
  }
  exports.hmacsign = hmacsign;
  exports.hmacsign256 = hmacsign256;
  exports.rsasign = rsasign;
  exports.plaintext = plaintext;
  exports.sign = sign;
  exports.rfc3986 = rfc3986;
  exports.generateBase = generateBase;
});

// node_modules/postman-request/lib/oauth.js
var require_oauth = __commonJS((exports) => {
  var url = __require("url");
  var qs = require_lib4();
  var caseless = require_caseless();
  var uuid = require_v4();
  var oauth = require_oauth_sign();
  var crypto = __require("crypto");
  var Buffer2 = require_safe_buffer().Buffer;
  function OAuth(request) {
    this.request = request;
    this.params = null;
  }
  OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
    var oa = {};
    for (var i in _oauth) {
      oa["oauth_" + i] = _oauth[i];
    }
    if (!oa.oauth_version) {
      oa.oauth_version = "1.0";
    }
    if (!oa.oauth_timestamp) {
      oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString();
    }
    if (!oa.oauth_nonce) {
      oa.oauth_nonce = uuid().replace(/-/g, "");
    }
    if (!oa.oauth_signature_method) {
      oa.oauth_signature_method = "HMAC-SHA1";
    }
    var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key;
    delete oa.oauth_consumer_secret;
    delete oa.oauth_private_key;
    var token_secret = oa.oauth_token_secret;
    delete oa.oauth_token_secret;
    var realm = oa.oauth_realm;
    delete oa.oauth_realm;
    delete oa.oauth_transport_method;
    var baseurl = uri.protocol + "//" + uri.host + uri.pathname;
    var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join("&"));
    oa.oauth_signature = oauth.sign(oa.oauth_signature_method, method, baseurl, params, consumer_secret_or_private_key, token_secret);
    if (realm) {
      oa.realm = realm;
    }
    return oa;
  };
  OAuth.prototype.buildBodyHash = function(_oauth, body) {
    if (["HMAC-SHA1", "RSA-SHA1"].indexOf(_oauth.signature_method || "HMAC-SHA1") < 0) {
      this.request.emit("error", new Error("oauth: " + _oauth.signature_method + " signature_method not supported with body_hash signing."));
    }
    var shasum = crypto.createHash("sha1");
    shasum.update(body || "");
    var sha1 = shasum.digest("hex");
    return Buffer2.from(sha1, "hex").toString("base64");
  };
  OAuth.prototype.concatParams = function(oa, sep, wrap) {
    wrap = wrap || "";
    var params = Object.keys(oa).filter(function(i) {
      return i !== "realm" && i !== "oauth_signature";
    }).sort();
    if (oa.realm) {
      params.splice(0, 0, "realm");
    }
    params.push("oauth_signature");
    return params.map(function(i) {
      return i + "=" + wrap + oauth.rfc3986(oa[i]) + wrap;
    }).join(sep);
  };
  OAuth.prototype.onRequest = function(_oauth) {
    var self2 = this;
    self2.params = _oauth;
    var uri = self2.request.uri || {};
    var method = self2.request.method || "";
    var headers = caseless(self2.request.headers);
    var body = self2.request.body || "";
    var qsLib = self2.request.qsLib || qs;
    var form;
    var query;
    var contentType = headers.get("content-type") || "";
    var formContentType = "application/x-www-form-urlencoded";
    var transport = _oauth.transport_method || "header";
    if (contentType.slice(0, formContentType.length) === formContentType) {
      contentType = formContentType;
      form = body;
    }
    if (uri.query) {
      query = uri.query;
    }
    if (transport === "body" && (method !== "POST" || contentType !== formContentType)) {
      self2.request.emit("error", new Error("oauth: transport_method of body requires POST " + "and content-type " + formContentType));
    }
    if (!form && typeof _oauth.body_hash === "boolean") {
      _oauth.body_hash = self2.buildBodyHash(_oauth, self2.request.body.toString());
    }
    var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
    switch (transport) {
      case "header":
        self2.request.setHeader("Authorization", "OAuth " + self2.concatParams(oa, ",", '"'));
        break;
      case "query":
        var href = self2.request.uri.href += (query ? "&" : "?") + self2.concatParams(oa, "&");
        self2.request.uri = url.parse(href);
        self2.request.path = self2.request.uri.path;
        break;
      case "body":
        self2.request.body = (form ? form + "&" : "") + self2.concatParams(oa, "&");
        break;
      default:
        self2.request.emit("error", new Error("oauth: transport_method invalid"));
    }
  };
  exports.OAuth = OAuth;
});

// node_modules/postman-request/lib/hawk.js
var require_hawk = __commonJS((exports) => {
  var crypto = __require("crypto");
  function randomString(size) {
    var bits = (size + 1) * 6;
    var buffer = crypto.randomBytes(Math.ceil(bits / 8));
    var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return string.slice(0, size);
  }
  function calculatePayloadHash(payload, algorithm, contentType) {
    var hash = crypto.createHash(algorithm);
    hash.update(`hawk.1.payload
`);
    hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + `
`);
    hash.update(payload || "");
    hash.update(`
`);
    return hash.digest("base64");
  }
  exports.calculateMac = function(credentials, opts) {
    var normalized = `hawk.1.header
` + opts.ts + `
` + opts.nonce + `
` + (opts.method || "").toUpperCase() + `
` + opts.resource + `
` + opts.host.toLowerCase() + `
` + opts.port + `
` + (opts.hash || "") + `
`;
    if (opts.ext) {
      normalized = normalized + opts.ext.replace("\\", "\\\\").replace(`
`, "\\n");
    }
    normalized = normalized + `
`;
    if (opts.app) {
      normalized = normalized + opts.app + `
` + (opts.dlg || "") + `
`;
    }
    var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest("base64");
    return digest;
  };
  exports.header = function(uri, method, opts) {
    var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000);
    var credentials = opts.credentials;
    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
      return "";
    }
    if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
      return "";
    }
    var artifacts = {
      ts: timestamp,
      nonce: opts.nonce || randomString(6),
      method,
      resource: uri.pathname + (uri.search || ""),
      host: uri.hostname,
      port: uri.port || (uri.protocol === "http:" ? 80 : 443),
      hash: opts.hash,
      ext: opts.ext,
      app: opts.app,
      dlg: opts.dlg
    };
    if (!artifacts.hash && (opts.payload || opts.payload === "")) {
      artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
    }
    var mac = exports.calculateMac(credentials, artifacts);
    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== "";
    var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") : "") + '", mac="' + mac + '"';
    if (artifacts.app) {
      header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
    }
    return header;
  };
});

// node_modules/postman-request/lib/multipart.js
var require_multipart = __commonJS((exports) => {
  var uuid = require_v4();
  var CombinedStream = require_combined_stream();
  var isstream = require_isstream();
  var Buffer2 = require_safe_buffer().Buffer;
  function Multipart(request) {
    this.request = request;
    this.boundary = uuid();
    this.chunked = false;
    this.body = null;
  }
  Multipart.prototype.isChunked = function(options) {
    var self2 = this;
    var chunked = false;
    var parts = options.data || options;
    if (!parts.forEach) {
      self2.request.emit("error", new Error("Argument error, options.multipart."));
    }
    if (options.chunked !== undefined) {
      chunked = options.chunked;
    }
    if (self2.request.getHeader("transfer-encoding") === "chunked") {
      chunked = true;
    }
    if (!chunked) {
      parts.forEach(function(part) {
        if (typeof part.body === "undefined") {
          self2.request.emit("error", new Error("Body attribute missing in multipart."));
        }
        if (isstream(part.body)) {
          chunked = true;
        }
      });
    }
    return chunked;
  };
  Multipart.prototype.setHeaders = function(chunked) {
    var self2 = this;
    if (chunked && !self2.request.hasHeader("transfer-encoding")) {
      self2.request.setHeader("transfer-encoding", "chunked");
    }
    var header = self2.request.getHeader("content-type");
    if (!header || header.indexOf("multipart") === -1) {
      self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
    } else {
      if (header.indexOf("boundary") !== -1) {
        self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
      } else {
        self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
      }
    }
  };
  Multipart.prototype.build = function(parts, chunked) {
    var self2 = this;
    var body = chunked ? new CombinedStream : [];
    function add(part) {
      if (typeof part === "number") {
        part = part.toString();
      }
      return chunked ? body.append(part) : body.push(Buffer2.from(part));
    }
    if (self2.request.preambleCRLF) {
      add(`\r
`);
    }
    parts.forEach(function(part) {
      var preamble = "--" + self2.boundary + `\r
`;
      Object.keys(part).forEach(function(key) {
        if (key === "body") {
          return;
        }
        preamble += key + ": " + part[key] + `\r
`;
      });
      preamble += `\r
`;
      add(preamble);
      add(part.body);
      add(`\r
`);
    });
    add("--" + self2.boundary + "--");
    if (self2.request.postambleCRLF) {
      add(`\r
`);
    }
    return body;
  };
  Multipart.prototype.onRequest = function(options) {
    var self2 = this;
    var chunked = self2.isChunked(options);
    var parts = options.data || options;
    self2.setHeaders(chunked);
    self2.chunked = chunked;
    self2.body = self2.build(parts, chunked);
  };
  exports.Multipart = Multipart;
});

// node_modules/postman-request/lib/redirect.js
var require_redirect = __commonJS((exports) => {
  var url = __require("url");
  var fs = __require("fs");
  var isUrl = /^https?:/;
  function Redirect(request) {
    this.request = request;
    this.followRedirect = true;
    this.followRedirects = true;
    this.followAllRedirects = false;
    this.followOriginalHttpMethod = false;
    this.followAuthorizationHeader = false;
    this.allowRedirect = function() {
      return true;
    };
    this.maxRedirects = 10;
    this.redirects = [];
    this.redirectsFollowed = 0;
    this.removeRefererHeader = false;
  }
  Redirect.prototype.onRequest = function(options) {
    var self2 = this;
    if (options.maxRedirects !== undefined) {
      self2.maxRedirects = options.maxRedirects;
    }
    if (typeof options.followRedirect === "function") {
      self2.allowRedirect = options.followRedirect;
    }
    if (options.followRedirect !== undefined) {
      self2.followRedirects = !!options.followRedirect;
    }
    if (options.followAllRedirects !== undefined) {
      self2.followAllRedirects = options.followAllRedirects;
    }
    if (self2.followRedirects || self2.followAllRedirects) {
      self2.redirects = self2.redirects || [];
    }
    if (options.removeRefererHeader !== undefined) {
      self2.removeRefererHeader = options.removeRefererHeader;
    }
    if (options.followOriginalHttpMethod !== undefined) {
      self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
    }
    if (options.followAuthorizationHeader !== undefined) {
      self2.followAuthorizationHeader = options.followAuthorizationHeader;
    }
  };
  Redirect.prototype.redirectTo = function(response) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = null;
    if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has("location")) {
      var location = response.caseless.get("location");
      request.debug("redirect", location);
      if (self2.followAllRedirects) {
        redirectTo = location;
      } else if (self2.followRedirects) {
        switch (request.method) {
          case "PATCH":
          case "PUT":
          case "POST":
          case "DELETE":
            break;
          default:
            redirectTo = location;
            break;
        }
      }
    } else if (response.statusCode === 401) {
      var authHeader = request._auth.onResponse(response);
      if (authHeader) {
        request.setHeader("authorization", authHeader);
        redirectTo = request.uri;
      }
    }
    return redirectTo;
  };
  Redirect.prototype.onResponse = function(response) {
    var self2 = this;
    var request = self2.request;
    var options = {};
    var redirectTo = self2.redirectTo(response);
    if (!redirectTo || !self2.allowRedirect.call(request, response)) {
      return false;
    }
    request.debug("redirect to", redirectTo);
    if (response.resume) {
      response.resume();
    }
    if (self2.redirectsFollowed >= self2.maxRedirects) {
      request.emit("error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request.uri.href));
      return false;
    }
    self2.redirectsFollowed += 1;
    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(request.uri.href, redirectTo);
    }
    var uriPrev = request.uri;
    request.uri = url.parse(redirectTo);
    if (request.uri.protocol !== uriPrev.protocol) {
      delete request.agent;
    }
    self2.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });
    if (request.headers && uriPrev.hostname !== request.uri.hostname) {
      request.removeHeader("host");
      if (!self2.followAuthorizationHeader) {
        request.removeHeader("authorization");
      }
    }
    delete request.src;
    delete request.req;
    delete request._started;
    if (response.statusCode !== 401 && response.statusCode !== 307 && response.statusCode !== 308) {
      if (!self2.followOriginalHttpMethod && request.method !== "HEAD") {
        request.method = "GET";
      }
      delete request.body;
      delete request._form;
      if (request.headers) {
        request.removeHeader("host");
        request.removeHeader("content-type");
        request.removeHeader("content-length");
      }
    } else if (request.formData && request._form && request._form._released && request._form._streams && !request._form._streams.length) {
      delete request._form;
      request.removeHeader("content-type");
      request.removeHeader("content-length");
      var formData = [];
      var resetFormData = function(key, value, paramOptions) {
        if (typeof (value && value.pipe) === "function") {
          if (!(value.hasOwnProperty("fd") && value.path))
            return;
          value = fs.createReadStream(value.path);
        }
        formData.push({ key, value, options: paramOptions });
      };
      for (var i = 0, ii = request.formData.length;i < ii; i++) {
        var formParam = request.formData[i];
        if (!formParam) {
          continue;
        }
        resetFormData(formParam.key, formParam.value, formParam.options);
      }
      options.formData = formData;
    }
    if (!self2.removeRefererHeader) {
      request.setHeader("referer", uriPrev.href);
    }
    request.emit("redirect");
    request.init(options);
    return true;
  };
  exports.Redirect = Redirect;
});

// node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS((exports) => {
  var net = __require("net");
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var events = __require("events");
  var assert = __require("assert");
  var util = __require("util");
  var Buffer2 = require_safe_buffer().Buffer;
  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port) {
      for (var i = 0, len = self2.requests.length;i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === host && pending.port === port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
    var self2 = this;
    if (typeof options === "string") {
      options = {
        host: options,
        port: arguments[2],
        path: arguments[3]
      };
    }
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push({ host: options.host, port: options.port, request: req });
      return;
    }
    self2.createConnection({ host: options.host, port: options.port, request: req });
  };
  TunnelingAgent.prototype.createConnection = function createConnection(pending) {
    var self2 = this;
    self2.createSocket(pending, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      pending.request.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, pending.host, pending.port);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false
    });
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) {
        assert.equal(head.length, 0);
        debug("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        cb(socket);
      } else {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        var error = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
      error.code = "ECONNRESET";
      options.request.emit("error", error);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1)
      return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createConnection(pending);
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var secureSocket = tls.connect(0, mergeOptions({}, self2.options, {
        servername: options.host,
        socket
      }));
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length;i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {};
  }
  exports.debug = debug;
});

// node_modules/postman-request/lib/tunnel.js
var require_tunnel = __commonJS((exports) => {
  var url = __require("url");
  var tunnel = require_tunnel_agent();
  var defaultProxyHeaderWhiteList = [
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "cache-control",
    "content-encoding",
    "content-language",
    "content-location",
    "content-md5",
    "content-range",
    "content-type",
    "connection",
    "date",
    "expect",
    "max-forwards",
    "pragma",
    "referer",
    "te",
    "user-agent",
    "via"
  ];
  var defaultProxyHeaderExclusiveList = [
    "proxy-authorization"
  ];
  function constructProxyHost(uriObject) {
    var port = uriObject.port;
    var protocol = uriObject.protocol;
    var proxyHost = uriObject.hostname + ":";
    if (port) {
      proxyHost += port;
    } else if (protocol === "https:") {
      proxyHost += "443";
    } else {
      proxyHost += "80";
    }
    return proxyHost;
  }
  function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
    var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
      set[header.toLowerCase()] = true;
      return set;
    }, {});
    return Object.keys(headers).filter(function(header) {
      return whiteList[header.toLowerCase()];
    }).reduce(function(set, header) {
      set[header] = headers[header];
      return set;
    }, {});
  }
  function constructTunnelOptions(request, proxyHeaders) {
    var proxy = request.proxy;
    var tunnelOptions = {
      proxy: {
        host: proxy.hostname,
        port: +proxy.port,
        proxyAuth: proxy.auth,
        headers: proxyHeaders
      },
      headers: request.headers,
      ca: request.ca,
      cert: request.cert,
      key: request.key,
      passphrase: request.passphrase,
      pfx: request.pfx,
      ciphers: request.ciphers,
      rejectUnauthorized: request.rejectUnauthorized,
      secureOptions: request.secureOptions,
      secureProtocol: request.secureProtocol
    };
    return tunnelOptions;
  }
  function constructTunnelFnName(uri, proxy) {
    var uriProtocol = uri.protocol === "https:" ? "https" : "http";
    var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
    return [uriProtocol, proxyProtocol].join("Over");
  }
  function getTunnelFn(request) {
    var uri = request.uri;
    var proxy = request.proxy;
    var tunnelFnName = constructTunnelFnName(uri, proxy);
    return tunnel[tunnelFnName];
  }
  function Tunnel(request) {
    this.request = request;
    this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    this.proxyHeaderExclusiveList = [];
    if (typeof request.tunnel !== "undefined") {
      this.tunnelOverride = request.tunnel;
    }
  }
  Tunnel.prototype.isEnabled = function() {
    var self2 = this;
    var request = self2.request;
    if (typeof self2.tunnelOverride !== "undefined") {
      return self2.tunnelOverride;
    }
    if (request.uri.protocol === "https:") {
      return true;
    }
    return false;
  };
  Tunnel.prototype.setup = function(options) {
    var self2 = this;
    var request = self2.request;
    options = options || {};
    if (typeof request.proxy === "string") {
      request.proxy = url.parse(request.proxy);
    }
    if (!request.proxy || !request.tunnel) {
      return false;
    }
    if (options.proxyHeaderWhiteList) {
      self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
    }
    if (options.proxyHeaderExclusiveList) {
      self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
    }
    var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
    var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
    var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
    proxyHeaders.host = constructProxyHost(request.uri);
    proxyHeaderExclusiveList.forEach(request.removeHeader, request);
    var tunnelFn = getTunnelFn(request);
    var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
    request.agent = tunnelFn(tunnelOptions);
    return true;
  };
  Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
  Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
  exports.Tunnel = Tunnel;
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS((exports, module) => {
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }).call(exports);
});

// node_modules/postman-request/lib/inflate.js
var require_inflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var stream = __require("stream");
  var inherit = __require("util").inherits;
  var Inflate;
  Inflate = function(options) {
    this.options = options;
    this._stream = null;
    stream.Transform.call(this);
  };
  inherit(Inflate, stream.Transform);
  Inflate.prototype._transform = function(chunk, encoding, callback) {
    var self2 = this;
    if (!self2._stream) {
      if ((new Buffer(chunk, encoding)[0] & 15) === 8) {
        self2._stream = zlib.createInflate(self2.options);
      } else {
        self2._stream = zlib.createInflateRaw(self2.options);
      }
      self2._stream.on("error", function(error) {
        self2.emit("error", error);
      });
      self2.once("finish", function() {
        self2._stream.end();
      });
      self2._stream.on("data", function(chunk2) {
        self2.push(chunk2);
      });
      self2._stream.once("end", function() {
        self2._ended = true;
        self2.push(null);
      });
    }
    self2._stream.write(chunk, encoding, callback);
  };
  Inflate.prototype._flush = function(callback) {
    if (this._stream && !this._ended) {
      this._stream.once("end", callback);
    } else {
      callback();
    }
  };
  exports.createInflate = function(options) {
    return new Inflate(options);
  };
});

// node_modules/postman-url-encoder/index.js
var require_postman_url_encoder = __commonJS((exports, module) => {
  var PERCENT = "%";
  var ZERO = "0";
  module.exports = {
    percentEncode: function(c) {
      var hex = c.toString(16).toUpperCase();
      hex.length === 1 && (hex = ZERO + hex);
      return PERCENT + hex;
    },
    isPreEncoded: function(buffer, i) {
      return buffer[i] === 37 && (this.isPreEncodedCharacter(buffer[i + 1]) && this.isPreEncodedCharacter(buffer[i + 2]));
    },
    isPreEncodedCharacter: function(byte) {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    },
    charactersToPercentEncode: function(byte) {
      return byte < 35 || byte > 126 || byte === 60 || byte === 62 || byte === 40 || byte === 41 || byte === 37 || byte === 39 || byte === 42;
    },
    encode: function(value) {
      if (!value) {
        return "";
      }
      var buffer = new Buffer(value), ret = "", i;
      for (i = 0;i < buffer.length; ++i) {
        if (this.charactersToPercentEncode(buffer[i]) && !this.isPreEncoded(buffer, i)) {
          ret += this.percentEncode(buffer[i]);
        } else {
          ret += String.fromCodePoint(buffer[i]);
        }
      }
      return ret;
    }
  };
});

// node_modules/postman-request/lib/url-parse.js
var require_url_parse = __commonJS((exports, module) => {
  var url = __require("url");
  var urlEncoder = require_postman_url_encoder();
  var EMPTY = "";
  var STRING = "string";
  var AMPERSAND = "&";
  var EQUALS = "=";
  var QUESTION_MARK = "?";
  var stringify;
  var parse;
  parse = function(string) {
    var parts;
    if (typeof string === STRING) {
      parts = string.split(AMPERSAND);
      return parts.map(function(param, idx) {
        if (param === EMPTY && idx !== parts.length - 1) {
          return { key: null, value: null };
        }
        var index = typeof param === STRING ? param.indexOf(EQUALS) : -1;
        var paramObj = {};
        if (index < 0) {
          paramObj.key = param.substr(0, param.length);
          paramObj.value = null;
        } else {
          paramObj.key = param.substr(0, index);
          paramObj.value = param.substr(index + 1);
        }
        return paramObj;
      });
    }
    return [];
  };
  stringify = function(parameters) {
    return parameters ? parameters.map(function(param) {
      var key = param.key;
      var value = param.value;
      if (value === undefined) {
        return "";
      }
      if (key === null) {
        key = "";
      }
      if (value === null) {
        return urlEncoder.encode(key);
      }
      return urlEncoder.encode(key) + EQUALS + urlEncoder.encode(value);
    }).join(AMPERSAND) : "";
  };
  module.exports = function(str) {
    var parsed = url.parse(str);
    var rawQs;
    var search;
    var path;
    var qs;
    rawQs = parsed.query;
    if (rawQs && rawQs.length) {
      qs = stringify(parse(parsed.query));
      search = QUESTION_MARK + qs;
      path = parsed.pathname + search;
      parsed.query = qs;
      parsed.search = search;
      parsed.path = path;
      str = url.format(parsed);
    }
    return url.parse(str);
  };
  module.exports.parse = parse;
  module.exports.stringify = stringify;
});

// node_modules/postman-request/request.js
var require_request2 = __commonJS((exports, module) => {
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var url = __require("url");
  var util = __require("util");
  var stream = __require("stream");
  var zlib = __require("zlib");
  var aws2 = require_aws_sign2();
  var aws4 = require_aws4();
  var uuid = require_v4();
  var httpSignature = require_lib3();
  var mime = require_mime_types();
  var caseless = require_caseless();
  var ForeverAgent = require_forever_agent();
  var FormData = require_form_data();
  var extend = require_extend();
  var isstream = require_isstream();
  var streamLength = require_stream_length();
  var isTypedArray = require_is_typedarray().strict;
  var helpers = require_helpers();
  var cookies = require_cookies();
  var getProxyFromURI = require_getProxyFromURI();
  var Querystring = require_querystring().Querystring;
  var Har = require_har2().Har;
  var Auth = require_auth().Auth;
  var OAuth = require_oauth().OAuth;
  var hawk = require_hawk();
  var Multipart = require_multipart().Multipart;
  var Redirect = require_redirect().Redirect;
  var Tunnel = require_tunnel().Tunnel;
  var now = require_performance_now();
  var Buffer2 = require_safe_buffer().Buffer;
  var inflate = require_inflate();
  var urlParse = require_url_parse();
  var safeStringify = helpers.safeStringify;
  var isReadStream = helpers.isReadStream;
  var toBase64 = helpers.toBase64;
  var defer = helpers.defer;
  var copy = helpers.copy;
  var version = helpers.version;
  var globalCookieJar = cookies.jar();
  var globalPool = {};
  function filterForNonReserved(reserved, options) {
    var object = {};
    for (var i in options) {
      var notReserved = reserved.indexOf(i) === -1;
      if (notReserved) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function filterOutReservedFunctions(reserved, options) {
    var object = {};
    for (var i in options) {
      var isReserved = !(reserved.indexOf(i) === -1);
      var isFunction = typeof options[i] === "function";
      if (!(isReserved && isFunction)) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function transformFormData(formData) {
    var transformedFormData = [];
    var appendFormParam = function(key, param) {
      transformedFormData.push({
        key,
        value: param && param.hasOwnProperty("value") ? param.value : param,
        options: param && param.hasOwnProperty("options") ? param.options : undefined
      });
    };
    for (var formKey in formData) {
      if (formData.hasOwnProperty(formKey)) {
        var formValue = formData[formKey];
        if (Array.isArray(formValue)) {
          for (var j = 0;j < formValue.length; j++) {
            appendFormParam(formKey, formValue[j]);
          }
        } else {
          appendFormParam(formKey, formValue);
        }
      }
    }
    return transformedFormData;
  }
  function requestToJSON() {
    var self2 = this;
    return {
      uri: self2.uri,
      method: self2.method,
      headers: self2.headers
    };
  }
  function responseToJSON() {
    var self2 = this;
    return {
      statusCode: self2.statusCode,
      body: self2.body,
      headers: self2.headers,
      request: requestToJSON.call(self2.request)
    };
  }
  function Request(options) {
    var self2 = this;
    if (options.har) {
      self2._har = new Har(self2);
      options = self2._har.options(options);
    }
    if (options.formData && !Array.isArray(options.formData)) {
      options.formData = transformFormData(options.formData);
    }
    stream.Stream.call(self2);
    var reserved = Object.keys(Request.prototype);
    var nonReserved = filterForNonReserved(reserved, options);
    extend(self2, nonReserved);
    options = filterOutReservedFunctions(reserved, options);
    self2.readable = true;
    self2.writable = true;
    self2._debug = [];
    if (options.method) {
      self2.explicitMethod = true;
    }
    self2._qs = new Querystring(self2);
    self2._auth = new Auth(self2);
    self2._oauth = new OAuth(self2);
    self2._multipart = new Multipart(self2);
    self2._redirect = new Redirect(self2);
    self2._tunnel = new Tunnel(self2);
    self2.init(options);
  }
  util.inherits(Request, stream.Stream);
  Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
  function debug() {
    if (Request.debug) {
      console.error("REQUEST %s", util.format.apply(util, arguments));
    }
  }
  Request.prototype.debug = debug;
  Request.prototype.init = function(options) {
    var self2 = this;
    if (!options) {
      options = {};
    }
    self2.headers = self2.headers ? copy(self2.headers) : {};
    self2._reqResInfo = {};
    self2._debug.push(self2._reqResInfo);
    if (options.bindOn) {
      Object.keys(options.bindOn).forEach(function(eventName) {
        !Array.isArray(options.bindOn[eventName]) && (options.bindOn[eventName] = [options.bindOn[eventName]]);
        options.bindOn[eventName].forEach(function(listener) {
          self2.on(eventName, listener);
        });
      });
    }
    if (options.once) {
      Object.keys(options.once).forEach(function(eventName) {
        !Array.isArray(options.bindOnce[eventName]) && (options.bindOnce[eventName] = [options.bindOnce[eventName]]);
        options.bindOnce[eventName].forEach(function(listener) {
          self2.once(eventName, listener);
        });
      });
    }
    for (var headerName in self2.headers) {
      if (typeof self2.headers[headerName] === "undefined") {
        delete self2.headers[headerName];
      }
    }
    caseless.httpify(self2, self2.headers);
    if (!self2.method) {
      self2.method = options.method || "GET";
    }
    if (!self2.localAddress) {
      self2.localAddress = options.localAddress;
    }
    self2._qs.init(options);
    debug(options);
    if (!self2.pool && self2.pool !== false) {
      self2.pool = globalPool;
    }
    self2.dests = self2.dests || [];
    self2.__isRequestRequest = true;
    if (!self2._callback && self2.callback) {
      self2._callback = self2.callback;
      self2.callback = function(error, response, body) {
        if (self2._callbackCalled) {
          return;
        }
        self2._callbackCalled = true;
        self2._callback(error, response, body, self2._debug);
      };
      self2.on("error", self2.callback.bind());
      self2.on("complete", self2.callback.bind(self2, null));
    }
    if (!self2.uri && self2.url) {
      self2.uri = self2.url;
      delete self2.url;
    }
    if (self2.baseUrl) {
      if (typeof self2.baseUrl !== "string") {
        return self2.emit("error", new Error("options.baseUrl must be a string"));
      }
      if (typeof self2.uri !== "string") {
        return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
      }
      if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
        return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
      }
      var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
      var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
      if (baseUrlEndsWithSlash && uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri.slice(1);
      } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri;
      } else if (self2.uri === "") {
        self2.uri = self2.baseUrl;
      } else {
        self2.uri = self2.baseUrl + "/" + self2.uri;
      }
      delete self2.baseUrl;
    }
    if (!self2.uri) {
      return self2.emit("error", new Error("options.uri is a required argument"));
    }
    if (typeof self2.uri === "string") {
      self2.uri = url.parse(self2.uri);
    }
    if (!self2.uri.href) {
      self2.uri.href = url.format(self2.uri);
    }
    if (self2.uri.protocol === "unix:") {
      return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
    }
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    if (self2.strictSSL === false) {
      self2.rejectUnauthorized = false;
    }
    if (!self2.uri.pathname) {
      self2.uri.pathname = "/";
    }
    if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
      var faultyUri = url.format(self2.uri);
      var message = 'Invalid URI "' + faultyUri + '"';
      if (Object.keys(options).length === 0) {
        message += ". This can be caused by a crappy redirection.";
      }
      self2.abort();
      return self2.emit("error", new Error(message));
    }
    if (!self2.hasOwnProperty("proxy")) {
      self2.proxy = getProxyFromURI(self2.uri);
    }
    self2.tunnel = self2._tunnel.isEnabled();
    if (self2.proxy) {
      self2._tunnel.setup(options);
    }
    self2._redirect.onRequest(options);
    self2.setHost = false;
    if (!self2.hasHeader("host")) {
      var hostHeaderName = self2.originalHostHeaderName || "host";
      self2.setHeader(hostHeaderName, self2.uri.host);
      if (self2.uri.port) {
        if (self2.uri.port === "80" && self2.uri.protocol === "http:" || self2.uri.port === "443" && self2.uri.protocol === "https:") {
          self2.setHeader(hostHeaderName, self2.uri.hostname);
        }
      }
      self2.setHost = true;
    }
    self2.jar(self2._jar || options.jar);
    if (!self2.uri.port) {
      if (self2.uri.protocol === "http:") {
        self2.uri.port = 80;
      } else if (self2.uri.protocol === "https:") {
        self2.uri.port = 443;
      }
    }
    if (self2.proxy && !self2.tunnel) {
      self2.port = self2.proxy.port;
      self2.host = self2.proxy.hostname;
    } else {
      self2.port = self2.uri.port;
      self2.host = self2.uri.hostname;
    }
    if (options.form) {
      self2.form(options.form);
    }
    if (options.formData) {
      var formData = options.formData;
      var requestForm = self2.form();
      for (var i = 0, ii = formData.length;i < ii; i++) {
        var formParam = formData[i];
        if (!formParam) {
          continue;
        }
        if (formParam.options) {
          requestForm.append(formParam.key, formParam.value, formParam.options);
        } else {
          requestForm.append(formParam.key, formParam.value);
        }
      }
    }
    if (options.qs) {
      self2.qs(options.qs);
    }
    if (self2.uri.path) {
      self2.path = self2.uri.path;
    } else {
      self2.path = self2.uri.pathname + (self2.uri.search || "");
    }
    if (self2.path.length === 0) {
      self2.path = "/";
    }
    if (options.aws) {
      self2.aws(options.aws);
    }
    if (options.hawk) {
      self2.hawk(options.hawk);
    }
    if (options.httpSignature) {
      self2.httpSignature(options.httpSignature);
    }
    if (options.auth) {
      if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
        options.auth.user = options.auth.username;
      }
      if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
        options.auth.pass = options.auth.password;
      }
      self2.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer);
    }
    if (self2.gzip && !self2.hasHeader("accept-encoding")) {
      self2.setHeader("accept-encoding", "gzip, deflate");
    }
    if (self2.uri.auth && !self2.hasHeader("authorization")) {
      var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
    }
    if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
      var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
      self2.setHeader("proxy-authorization", authHeader);
    }
    if (self2.proxy && !self2.tunnel) {
      self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
    }
    if (options.json) {
      self2.json(options.json);
    }
    if (options.multipart) {
      self2.multipart(options.multipart);
    }
    if (options.time || options.verbose) {
      self2.timing = true;
      self2.elapsedTime = self2.elapsedTime || 0;
    }
    if (options.verbose) {
      self2.verbose = true;
    }
    function setContentLength() {
      if (isTypedArray(self2.body)) {
        self2.body = Buffer2.from(self2.body);
      }
      if (!self2.hasHeader("content-length")) {
        var length;
        if (typeof self2.body === "string") {
          length = Buffer2.byteLength(self2.body);
        } else if (Array.isArray(self2.body)) {
          length = self2.body.reduce(function(a, b) {
            return a + b.length;
          }, 0);
        } else {
          length = self2.body.length;
        }
        if (length) {
          self2.setHeader("content-length", length);
        } else {
          self2.emit("error", new Error("Argument error, options.body."));
        }
      }
    }
    if (self2.body && !isstream(self2.body)) {
      setContentLength();
    }
    if (options.oauth) {
      self2.oauth(options.oauth);
    } else if (self2._oauth.params && self2.hasHeader("authorization")) {
      self2.oauth(self2._oauth.params);
    }
    var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
    var defaultModules = { "http:": http, "https:": https };
    var httpModules = self2.httpModules || {};
    self2.httpModule = httpModules[protocol] || defaultModules[protocol];
    if (!self2.httpModule) {
      return self2.emit("error", new Error("Invalid protocol: " + protocol));
    }
    if (options.ca) {
      self2.ca = options.ca;
    }
    if (!self2.agent) {
      if (options.agentOptions) {
        self2.agentOptions = options.agentOptions;
      }
      if (options.agentClass) {
        self2.agentClass = options.agentClass;
      } else if (options.forever) {
        var v = version();
        if (v.major === 0 && v.minor <= 10) {
          self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
        } else {
          self2.agentClass = self2.httpModule.Agent;
          self2.agentOptions = self2.agentOptions || {};
          self2.agentOptions.keepAlive = true;
        }
      } else {
        self2.agentClass = self2.httpModule.Agent;
      }
    }
    if (self2.pool === false) {
      self2.agent = false;
    } else {
      self2.agent = self2.agent || self2.getNewAgent();
    }
    self2.on("pipe", function(src) {
      if (self2.ntick && self2._started) {
        self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
      }
      self2.src = src;
      if (isReadStream(src)) {
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", mime.lookup(src.path));
        }
      } else {
        if (src.headers) {
          for (var i2 in src.headers) {
            if (!self2.hasHeader(i2)) {
              self2.setHeader(i2, src.headers[i2]);
            }
          }
        }
        if (self2._json && !self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
        if (src.method && !self2.explicitMethod) {
          self2.method = src.method;
        }
      }
    });
    defer(function() {
      if (self2._aborted) {
        return;
      }
      var end = function() {
        if (self2._form) {
          if (!self2._auth.hasAuth || self2._auth.hasAuth && self2._auth.sentAuth) {
            try {
              self2._form.pipe(self2);
            } catch (err) {
              self2.abort();
              options.callback && options.callback(err);
              return;
            }
          }
        }
        if (self2._multipart && self2._multipart.chunked) {
          self2._multipart.body.pipe(self2);
        }
        if (self2.body) {
          if (isstream(self2.body)) {
            if (self2.hasHeader("content-length")) {
              self2.body.pipe(self2);
            } else {
              streamLength(self2.body, {}, function(err, len) {
                if (!(err || self2._started || self2.hasHeader("content-length") || len === null || len < 0)) {
                  self2.setHeader("content-length", len);
                }
                self2.body.pipe(self2);
              });
            }
          } else {
            setContentLength();
            if (Array.isArray(self2.body)) {
              self2.body.forEach(function(part) {
                self2.write(part);
              });
            } else {
              self2.write(self2.body);
            }
            self2.end();
          }
        } else if (self2.requestBodyStream) {
          console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
          self2.requestBodyStream.pipe(self2);
        } else if (!self2.src) {
          if (self2._auth.hasAuth && !self2._auth.sentAuth) {
            self2.end();
            return;
          }
          if (self2.method !== "GET" && typeof self2.method !== "undefined") {
            self2.setHeader("content-length", 0);
          }
          self2.end();
        }
      };
      if (self2._form && !self2.hasHeader("content-length")) {
        self2.setHeader(self2._form.getHeaders(), true);
        self2._form.getLength(function(err, length) {
          if (!err && !isNaN(length)) {
            self2.setHeader("content-length", length);
          }
          end();
        });
      } else {
        end();
      }
      self2.ntick = true;
    });
  };
  Request.prototype.getNewAgent = function() {
    var self2 = this;
    var Agent = self2.agentClass;
    var options = {};
    if (self2.agentOptions) {
      for (var i in self2.agentOptions) {
        options[i] = self2.agentOptions[i];
      }
    }
    if (self2.ca) {
      options.ca = self2.ca;
    }
    if (self2.extraCA) {
      options.extraCA = self2.extraCA;
    }
    if (self2.ciphers) {
      options.ciphers = self2.ciphers;
    }
    if (self2.secureProtocol) {
      options.secureProtocol = self2.secureProtocol;
    }
    if (self2.secureOptions) {
      options.secureOptions = self2.secureOptions;
    }
    if (typeof self2.rejectUnauthorized !== "undefined") {
      options.rejectUnauthorized = self2.rejectUnauthorized;
    }
    if (self2.cert && self2.key) {
      options.key = self2.key;
      options.cert = self2.cert;
    }
    if (self2.pfx) {
      options.pfx = self2.pfx;
    }
    if (self2.passphrase) {
      options.passphrase = self2.passphrase;
    }
    var poolKey = "";
    if (Agent !== self2.httpModule.Agent) {
      poolKey += Agent.name;
    }
    var proxy = self2.proxy;
    if (typeof proxy === "string") {
      proxy = url.parse(proxy);
    }
    var isHttps = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
    if (isHttps) {
      if (options.ca) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ca;
      }
      if (tls.__createSecureContext && options.extraCA) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.extraCA;
      }
      if (typeof options.rejectUnauthorized !== "undefined") {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.rejectUnauthorized;
      }
      if (options.cert) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
      }
      if (options.pfx) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.pfx.toString("ascii");
      }
      if (options.passphrase) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.passphrase;
      }
      if (options.ciphers) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ciphers;
      }
      if (options.secureProtocol) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureProtocol;
      }
      if (options.secureOptions) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureOptions;
      }
    }
    if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
      return self2.httpModule.globalAgent;
    }
    poolKey = self2.uri.protocol + poolKey;
    if (!self2.pool[poolKey]) {
      self2.pool[poolKey] = new Agent(options);
      if (self2.pool.maxSockets) {
        self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
      }
    }
    return self2.pool[poolKey];
  };
  Request.prototype.start = function() {
    var self2 = this;
    if (self2.timing) {
      var startTime = new Date().getTime();
      var startTimeNow = now();
    }
    if (self2._aborted) {
      return;
    }
    self2.emit("start");
    self2._started = true;
    self2.method = self2.method || "GET";
    self2.href = self2.uri.href;
    if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
      self2.setHeader("content-length", self2.src.stat.size);
    }
    if (self2._aws) {
      self2.aws(self2._aws, true);
    }
    self2._reqResInfo.request = {
      method: self2.method,
      href: self2.uri.href,
      proxy: self2.proxy && { href: self2.proxy.href } || undefined,
      httpVersion: "1.1"
    };
    var reqOptions = copy(self2);
    delete reqOptions.auth;
    if (!self2.proxy && !self2.uri.isUnix) {
      try {
        extend(reqOptions, urlParse(self2.uri.href));
      } catch (e) {}
    }
    debug("make request", self2.uri.href);
    delete reqOptions.timeout;
    try {
      self2.req = self2.httpModule.request(reqOptions);
    } catch (err) {
      self2.emit("error", err);
      return;
    }
    if (self2.timing) {
      self2.startTime = startTime;
      self2.startTimeNow = startTimeNow;
      self2.timings = {};
    }
    var timeout;
    if (self2.timeout && !self2.timeoutTimer) {
      if (self2.timeout < 0) {
        timeout = 0;
      } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
        timeout = self2.timeout;
      }
    }
    self2.req.on("response", self2.onRequestResponse.bind(self2));
    self2.req.on("error", self2.onRequestError.bind(self2));
    self2.req.on("drain", function() {
      self2.emit("drain");
    });
    self2.req.on("socket", function(socket) {
      if (self2.verbose) {
        var reusedSocket = Boolean(socket.__SESSION_ID && socket.__SESSION_DATA);
        if (!reusedSocket) {
          socket.__SESSION_ID = uuid();
          socket.__SESSION_DATA = {};
        }
        self2._reqResInfo.session = {
          id: socket.__SESSION_ID,
          reused: reusedSocket,
          data: socket.__SESSION_DATA
        };
      }
      var isConnecting = socket._connecting || socket.connecting;
      if (self2.timing) {
        self2.timings.socket = now() - self2.startTimeNow;
        if (isConnecting) {
          var onLookupTiming = function() {
            self2.timings.lookup = now() - self2.startTimeNow;
          };
          var onConnectTiming = function() {
            self2.timings.connect = now() - self2.startTimeNow;
            if (self2.verbose) {
              socket.__SESSION_DATA.addresses = {
                local: typeof socket.address === "function" && socket.address(),
                remote: {
                  address: socket.remoteAddress,
                  family: socket.remoteFamily,
                  port: socket.remotePort
                }
              };
            }
          };
          var onSecureConnectTiming = function() {
            self2.timings.secureConnect = now() - self2.startTimeNow;
            if (self2.verbose) {
              socket.__SESSION_DATA.tls = {
                reused: typeof socket.isSessionReused === "function" && socket.isSessionReused(),
                authorized: socket.authorized,
                authorizationError: socket.authorizationError,
                cipher: typeof socket.getCipher === "function" && socket.getCipher(),
                protocol: typeof socket.getProtocol === "function" && socket.getProtocol(),
                ephemeralKeyInfo: typeof socket.getEphemeralKeyInfo === "function" && socket.getEphemeralKeyInfo()
              };
              var peerCert = typeof socket.getPeerCertificate === "function" && (socket.getPeerCertificate() || {});
              socket.__SESSION_DATA.tls.peerCertificate = {
                subject: peerCert.subject && {
                  country: peerCert.subject.C,
                  stateOrProvince: peerCert.subject.ST,
                  locality: peerCert.subject.L,
                  organization: peerCert.subject.O,
                  organizationalUnit: peerCert.subject.OU,
                  commonName: peerCert.subject.CN,
                  alternativeNames: peerCert.subjectaltname
                },
                issuer: peerCert.issuer && {
                  country: peerCert.issuer.C,
                  stateOrProvince: peerCert.issuer.ST,
                  locality: peerCert.issuer.L,
                  organization: peerCert.issuer.O,
                  organizationalUnit: peerCert.issuer.OU,
                  commonName: peerCert.issuer.CN
                },
                validFrom: peerCert.valid_from && new Date(peerCert.valid_from),
                validTo: peerCert.valid_to && new Date(peerCert.valid_to),
                fingerprint: peerCert.fingerprint,
                serialNumber: peerCert.serialNumber
              };
            }
          };
          socket.once("lookup", onLookupTiming);
          socket.once("connect", onConnectTiming);
          socket.once("secureConnect", onSecureConnectTiming);
          self2.req.once("error", function() {
            socket.removeListener("lookup", onLookupTiming);
            socket.removeListener("connect", onConnectTiming);
          });
        }
      }
      var setReqTimeout = function() {
        self2.req.setTimeout(timeout, function() {
          if (self2.req) {
            self2.abort();
            var e = new Error("ESOCKETTIMEDOUT");
            e.code = "ESOCKETTIMEDOUT";
            e.connect = false;
            self2.emit("error", e);
          }
        });
      };
      if (timeout !== undefined) {
        if (isConnecting) {
          var onReqSockConnect = function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.clearTimeout();
            setReqTimeout();
          };
          socket.on("connect", onReqSockConnect);
          self2.req.on("error", function(err) {
            socket.removeListener("connect", onReqSockConnect);
          });
          self2.timeoutTimer = setTimeout(function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.abort();
            var e = new Error("ETIMEDOUT");
            e.code = "ETIMEDOUT";
            e.connect = true;
            self2.emit("error", e);
          }, timeout);
        } else {
          setReqTimeout();
        }
      }
      self2.emit("socket", socket);
    });
    self2.emit("request", self2.req);
  };
  Request.prototype.onRequestError = function(error) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (self2.req && self2.req._reusedSocket && error.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
      self2.agent = { addRequest: self2.agent.addRequestNoreuse.bind(self2.agent) };
      self2.start();
      self2.req.end();
      return;
    }
    self2.clearTimeout();
    self2.emit("error", error);
  };
  Request.prototype.onRequestResponse = function(response) {
    var self2 = this;
    if (self2.timing) {
      self2.timings.response = now() - self2.startTimeNow;
    }
    debug("onRequestResponse", self2.uri.href, response.statusCode, response.headers);
    response.on("end", function() {
      if (self2.timing) {
        self2.timings.end = now() - self2.startTimeNow;
        response.timingStart = self2.startTime;
        response.timingStartTimer = self2.startTimeNow;
        if (!self2.timings.socket) {
          self2.timings.socket = 0;
        }
        if (!self2.timings.lookup) {
          self2.timings.lookup = self2.timings.socket;
        }
        if (!self2.timings.connect) {
          self2.timings.connect = self2.timings.lookup;
        }
        if (!self2.timings.secureConnect && self2.httpModule === https) {
          self2.timings.secureConnect = self2.timings.connect;
        }
        if (!self2.timings.response) {
          self2.timings.response = self2.timings.connect;
        }
        debug("elapsed time", self2.timings.end);
        self2.elapsedTime += Math.round(self2.timings.end);
        response.elapsedTime = self2.elapsedTime;
        response.timings = self2.timings;
        response.timingPhases = {
          wait: self2.timings.socket,
          dns: self2.timings.lookup - self2.timings.socket,
          tcp: self2.timings.connect - self2.timings.lookup,
          firstByte: self2.timings.response - self2.timings.connect,
          download: self2.timings.end - self2.timings.response,
          total: self2.timings.end
        };
        if (self2.timings.secureConnect) {
          response.timingPhases.secureHandshake = self2.timings.secureConnect - self2.timings.connect;
          response.timingPhases.firstByte = self2.timings.response - self2.timings.secureConnect;
        }
      }
      debug("response end", self2.uri.href, response.statusCode, response.headers);
    });
    if (self2._aborted) {
      debug("aborted", self2.uri.href);
      response.resume();
      return;
    }
    self2._reqResInfo.response = {
      statusCode: response.statusCode,
      httpVersion: response.httpVersion
    };
    if (self2.timing) {
      self2._reqResInfo.timingStart = self2.startTime;
      self2._reqResInfo.timingStartTimer = self2.startTimeNow;
      self2._reqResInfo.timings = self2.timings;
    }
    self2.response = response;
    response.request = self2;
    response.toJSON = responseToJSON;
    if (self2.httpModule === https && self2.strictSSL && (!response.hasOwnProperty("socket") || !response.socket.authorized)) {
      debug("strict ssl error", self2.uri.href);
      var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self2.uri.href + " does not support SSL";
      self2.emit("error", new Error("SSL Error: " + sslErr));
      return;
    }
    self2.originalHost = self2.getHeader("host");
    if (!self2.originalHostHeaderName) {
      self2.originalHostHeaderName = self2.hasHeader("host");
    }
    if (self2.setHost) {
      self2.removeHeader("host");
    }
    self2.clearTimeout();
    var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
    var addCookie = function(cookie) {
      try {
        targetCookieJar.setCookie(cookie, self2.uri.href, { ignoreError: true });
      } catch (e) {
        self2.emit("error", e);
      }
    };
    response.caseless = caseless(response.headers);
    if (response.caseless.has("set-cookie") && !self2._disableCookies) {
      var headerName = response.caseless.has("set-cookie");
      if (Array.isArray(response.headers[headerName])) {
        response.headers[headerName].forEach(addCookie);
      } else {
        addCookie(response.headers[headerName]);
      }
    }
    if (self2._redirect.onResponse(response)) {
      return;
    } else {
      response.on("close", function() {
        if (!self2._ended) {
          self2.response.emit("end");
        }
      });
      response.once("end", function() {
        self2._ended = true;
      });
      var noBody = function(code) {
        return self2.method === "HEAD" || code >= 100 && code < 200 || code === 204 || code === 304;
      };
      var responseContent;
      if (self2.gzip && !noBody(response.statusCode)) {
        var contentEncoding = response.headers["content-encoding"] || "identity";
        contentEncoding = contentEncoding.trim().toLowerCase();
        var zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (contentEncoding === "gzip") {
          responseContent = zlib.createGunzip(zlibOptions);
          response.pipe(responseContent);
        } else if (contentEncoding === "deflate") {
          responseContent = inflate.createInflate(zlibOptions);
          response.pipe(responseContent);
        } else {
          if (contentEncoding !== "identity") {
            debug("ignoring unrecognized Content-Encoding " + contentEncoding);
          }
          responseContent = response;
        }
      } else {
        responseContent = response;
      }
      if (self2.encoding) {
        if (self2.dests.length !== 0) {
          console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
        } else {
          responseContent.setEncoding(self2.encoding);
        }
      }
      if (self2._paused) {
        responseContent.pause();
      }
      self2.responseContent = responseContent;
      self2.emit("response", response);
      self2.dests.forEach(function(dest) {
        self2.pipeDest(dest);
      });
      responseContent.on("data", function(chunk) {
        if (self2.timing && !self2.responseStarted) {
          self2.responseStartTime = new Date().getTime();
          response.responseStartTime = self2.responseStartTime;
        }
        self2._destdata = true;
        self2.emit("data", chunk);
      });
      responseContent.once("end", function(chunk) {
        self2.emit("end", chunk);
      });
      responseContent.on("error", function(error) {
        self2.emit("error", error);
      });
      responseContent.on("close", function() {
        self2.emit("close");
      });
      if (self2.callback) {
        self2.readResponseBody(response);
      } else {
        self2.on("end", function() {
          if (self2._aborted) {
            debug("aborted", self2.uri.href);
            return;
          }
          self2.emit("complete", response);
        });
      }
    }
    debug("finish init function", self2.uri.href);
  };
  Request.prototype.readResponseBody = function(response) {
    var self2 = this;
    debug("reading response's body");
    var buffers = [];
    var bufferLength = 0;
    var strings = [];
    self2.on("data", function(chunk) {
      if (!Buffer2.isBuffer(chunk)) {
        strings.push(chunk);
      } else if (chunk.length) {
        bufferLength += chunk.length;
        buffers.push(chunk);
      }
    });
    self2.on("end", function() {
      debug("end event", self2.uri.href);
      if (self2._aborted) {
        debug("aborted", self2.uri.href);
        buffers = [];
        bufferLength = 0;
        return;
      }
      if (bufferLength) {
        debug("has body", self2.uri.href, bufferLength);
        response.body = Buffer2.concat(buffers, bufferLength);
        if (self2.encoding !== null) {
          response.body = response.body.toString(self2.encoding);
        }
        buffers = [];
        bufferLength = 0;
      } else if (strings.length) {
        if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
          strings[0] = strings[0].substring(1);
        }
        response.body = strings.join("");
      }
      if (self2._json) {
        try {
          response.body = JSON.parse(response.body, self2._jsonReviver);
        } catch (e) {
          debug("invalid JSON received", self2.uri.href);
        }
      }
      debug("emitting complete", self2.uri.href);
      if (typeof response.body === "undefined" && !self2._json) {
        response.body = self2.encoding === null ? Buffer2.alloc(0) : "";
      }
      self2.emit("complete", response, response.body);
    });
  };
  Request.prototype.abort = function() {
    var self2 = this;
    self2._aborted = true;
    if (self2.req) {
      self2.req.abort();
    } else if (self2.response) {
      self2.response.destroy();
    }
    self2.clearTimeout();
    self2.emit("abort");
  };
  Request.prototype.pipeDest = function(dest) {
    var self2 = this;
    var response = self2.response;
    if (dest.headers && !dest.headersSent) {
      if (response.caseless.has("content-type")) {
        var ctname = response.caseless.has("content-type");
        if (dest.setHeader) {
          dest.setHeader(ctname, response.headers[ctname]);
        } else {
          dest.headers[ctname] = response.headers[ctname];
        }
      }
      if (response.caseless.has("content-length")) {
        var clname = response.caseless.has("content-length");
        if (dest.setHeader) {
          dest.setHeader(clname, response.headers[clname]);
        } else {
          dest.headers[clname] = response.headers[clname];
        }
      }
    }
    if (dest.setHeader && !dest.headersSent) {
      for (var i in response.headers) {
        if (!self2.gzip || i !== "content-encoding") {
          dest.setHeader(i, response.headers[i]);
        }
      }
      dest.statusCode = response.statusCode;
    }
    if (self2.pipefilter) {
      self2.pipefilter(response, dest);
    }
  };
  Request.prototype.qs = function(q2, clobber) {
    var self2 = this;
    var base;
    if (!clobber && self2.uri.query) {
      base = self2._qs.parse(self2.uri.query);
    } else {
      base = {};
    }
    for (var i in q2) {
      base[i] = q2[i];
    }
    var qs = self2._qs.stringify(base);
    if (qs === "") {
      return self2;
    }
    self2.uri = url.parse(self2.uri.href.split("?")[0] + "?" + qs);
    self2.url = self2.uri;
    self2.path = self2.uri.path;
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    return self2;
  };
  Request.prototype.form = function(form) {
    var self2 = this;
    if (form) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
        self2.setHeader("content-type", "application/x-www-form-urlencoded");
      }
      self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
      return self2;
    }
    self2._form = new FormData;
    self2._form.on("error", function(err) {
      err.message = "form-data: " + err.message;
      self2.emit("error", err);
      self2.abort();
    });
    return self2._form;
  };
  Request.prototype.multipart = function(multipart) {
    var self2 = this;
    self2._multipart.onRequest(multipart);
    if (!self2._multipart.chunked) {
      self2.body = self2._multipart.body;
    }
    return self2;
  };
  Request.prototype.json = function(val) {
    var self2 = this;
    if (!self2.hasHeader("accept")) {
      self2.setHeader("accept", "application/json");
    }
    if (typeof self2.jsonReplacer === "function") {
      self2._jsonReplacer = self2.jsonReplacer;
    }
    self2._json = true;
    if (typeof val === "boolean") {
      if (self2.body !== undefined) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.body = safeStringify(self2.body, self2._jsonReplacer);
        } else {
          self2.body = self2._qs.rfc3986(self2.body);
        }
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
    } else {
      self2.body = safeStringify(val, self2._jsonReplacer);
      if (!self2.hasHeader("content-type")) {
        self2.setHeader("content-type", "application/json");
      }
    }
    if (typeof self2.jsonReviver === "function") {
      self2._jsonReviver = self2.jsonReviver;
    }
    return self2;
  };
  Request.prototype.getHeader = function(name, headers) {
    var self2 = this;
    var result, re, match;
    if (!headers) {
      headers = self2.headers;
    }
    Object.keys(headers).forEach(function(key) {
      if (key.length !== name.length) {
        return;
      }
      re = new RegExp(name, "i");
      match = key.match(re);
      if (match) {
        result = headers[key];
      }
    });
    return result;
  };
  Request.prototype.enableUnixSocket = function() {
    var unixParts = this.uri.path.split(":");
    var host = unixParts[0];
    var path = unixParts[1];
    this.socketPath = host;
    this.uri.pathname = path;
    this.uri.path = path;
    this.uri.host = host;
    this.uri.hostname = host;
    this.uri.isUnix = true;
  };
  Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    self2._auth.onRequest(user, pass, sendImmediately, bearer);
    return self2;
  };
  Request.prototype.aws = function(opts, now2) {
    var self2 = this;
    if (!now2) {
      self2._aws = opts;
      return self2;
    }
    if (opts.sign_version === 4 || opts.sign_version === "4") {
      var options = {
        host: self2.uri.host,
        path: self2.uri.path,
        method: self2.method,
        headers: self2.headers,
        body: self2.body
      };
      if (opts.service) {
        options.service = opts.service;
      }
      var signRes = aws4.sign(options, {
        accessKeyId: opts.key,
        secretAccessKey: opts.secret,
        sessionToken: opts.session
      });
      self2.setHeader("authorization", signRes.headers.Authorization);
      self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
      if (signRes.headers["X-Amz-Security-Token"]) {
        self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
      }
    } else {
      var date = new Date;
      self2.setHeader("date", date.toUTCString());
      var auth = {
        key: opts.key,
        secret: opts.secret,
        verb: self2.method.toUpperCase(),
        date,
        contentType: self2.getHeader("content-type") || "",
        md5: self2.getHeader("content-md5") || "",
        amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
      };
      var path = self2.uri.path;
      if (opts.bucket && path) {
        auth.resource = "/" + opts.bucket + path;
      } else if (opts.bucket && !path) {
        auth.resource = "/" + opts.bucket;
      } else if (!opts.bucket && path) {
        auth.resource = path;
      } else if (!opts.bucket && !path) {
        auth.resource = "/";
      }
      auth.resource = aws2.canonicalizeResource(auth.resource);
      self2.setHeader("authorization", aws2.authorization(auth));
    }
    return self2;
  };
  Request.prototype.httpSignature = function(opts) {
    var self2 = this;
    httpSignature.signRequest({
      getHeader: function(header) {
        return self2.getHeader(header, self2.headers);
      },
      setHeader: function(header, value) {
        self2.setHeader(header, value);
      },
      method: self2.method,
      path: self2.path
    }, opts);
    debug("httpSignature authorization", self2.getHeader("authorization"));
    return self2;
  };
  Request.prototype.hawk = function(opts) {
    var self2 = this;
    self2.setHeader("Authorization", hawk.header(self2.uri, self2.method, opts));
  };
  Request.prototype.oauth = function(_oauth) {
    var self2 = this;
    self2._oauth.onRequest(_oauth);
    return self2;
  };
  Request.prototype.jar = function(jar) {
    var self2 = this;
    var cookies2;
    if (self2._redirect.redirectsFollowed === 0) {
      self2.originalCookieHeader = self2.getHeader("cookie");
    }
    if (!jar) {
      cookies2 = false;
      self2._disableCookies = true;
    } else {
      var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
      var urihref = self2.uri.href;
      if (targetCookieJar) {
        cookies2 = targetCookieJar.getCookieString(urihref);
      }
    }
    if (cookies2 && cookies2.length) {
      if (self2.originalCookieHeader) {
        self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies2);
      } else {
        self2.setHeader("cookie", cookies2);
      }
    }
    self2._jar = jar;
    return self2;
  };
  Request.prototype.pipe = function(dest, opts) {
    var self2 = this;
    if (self2.response) {
      if (self2._destdata) {
        self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
      } else if (self2._ended) {
        self2.emit("error", new Error("You cannot pipe after the response has been ended."));
      } else {
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        self2.pipeDest(dest);
        return dest;
      }
    } else {
      self2.dests.push(dest);
      stream.Stream.prototype.pipe.call(self2, dest, opts);
      return dest;
    }
  };
  Request.prototype.write = function() {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      return self2.req.write.apply(self2.req, arguments);
    }
  };
  Request.prototype.end = function(chunk) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (chunk) {
      self2.write(chunk);
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      self2.req.end();
    }
  };
  Request.prototype.pause = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = true;
    } else {
      self2.responseContent.pause.apply(self2.responseContent, arguments);
    }
  };
  Request.prototype.resume = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = false;
    } else {
      self2.responseContent.resume.apply(self2.responseContent, arguments);
    }
  };
  Request.prototype.destroy = function() {
    var self2 = this;
    this.clearTimeout();
    if (!self2._ended) {
      self2.end();
    } else if (self2.response) {
      self2.response.destroy();
    }
  };
  Request.prototype.clearTimeout = function() {
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
  };
  Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
  Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
  Request.prototype.toJSON = requestToJSON;
  module.exports = Request;
});

// node_modules/postman-request/index.js
var require_postman_request = __commonJS((exports, module) => {
  var tls = __require("tls");
  var extend = require_extend();
  var cookies = require_cookies();
  function initParams(uri, options, callback) {
    if (typeof options === "function") {
      callback = options;
    }
    var params = {};
    if (options !== null && typeof options === "object") {
      extend(params, options, { uri });
    } else if (typeof uri === "string") {
      extend(params, { uri });
    } else {
      extend(params, uri);
    }
    params.callback = callback || params.callback;
    return params;
  }
  function request(uri, options, callback) {
    if (typeof uri === "undefined") {
      throw new Error("undefined is not a valid uri or options object.");
    }
    var params = initParams(uri, options, callback);
    return new request.Request(params);
  }
  function verbFunc(verb) {
    var method = verb.toUpperCase();
    return function(uri, options, callback) {
      var params = initParams(uri, options, callback);
      params.method = method;
      return request(params, params.callback);
    };
  }
  request.get = verbFunc("get");
  request.head = verbFunc("head");
  request.options = verbFunc("options");
  request.post = verbFunc("post");
  request.put = verbFunc("put");
  request.patch = verbFunc("patch");
  request.del = verbFunc("delete");
  request["delete"] = verbFunc("delete");
  request.jar = function(store) {
    return cookies.jar(store);
  };
  request.cookie = function(str) {
    return cookies.parse(str);
  };
  function wrapRequestMethod(method, options, requester, verb) {
    return function(uri, opts, callback) {
      var params = initParams(uri, opts, callback);
      var target = {};
      extend(true, target, options, params);
      target.pool = params.pool || options.pool;
      if (verb) {
        target.method = verb.toUpperCase();
      }
      if (typeof requester === "function") {
        method = requester;
      }
      return method(target, target.callback);
    };
  }
  request.defaults = function(options, requester) {
    var self2 = this;
    options = options || {};
    if (typeof options === "function") {
      requester = options;
      options = {};
    }
    var defaults = wrapRequestMethod(self2, options, requester);
    var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
    verbs.forEach(function(verb) {
      defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
    });
    defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
    defaults.jar = self2.jar;
    defaults.defaults = self2.defaults;
    return defaults;
  };
  request.forever = function(agentOptions, optionsArg) {
    var options = {};
    if (optionsArg) {
      extend(options, optionsArg);
    }
    if (agentOptions) {
      options.agentOptions = agentOptions;
    }
    options.forever = true;
    return request.defaults(options);
  };
  request.enableNodeExtraCACerts = function(callback) {
    !callback && (callback = function() {});
    if (tls.__createSecureContext) {
      return callback();
    }
    try {
      var testContext = tls.createSecureContext();
      if (!(testContext && testContext.context && typeof testContext.context.addCACert === "function")) {
        return callback(new Error("SecureContext.addCACert is not a function"));
      }
    } catch (err) {
      return callback(err);
    }
    tls.__createSecureContext = tls.createSecureContext;
    tls.createSecureContext = function() {
      var secureContext = tls.__createSecureContext.apply(this, arguments);
      if (arguments[0] && arguments[0].extraCA) {
        secureContext.context.addCACert(arguments[0].extraCA);
      }
      return secureContext;
    };
    return callback();
  };
  request.disableNodeExtraCACerts = function() {
    if (typeof tls.__createSecureContext !== "function") {
      return;
    }
    tls.createSecureContext = tls.__createSecureContext;
    delete tls.__createSecureContext;
  };
  module.exports = request;
  request.Request = require_request2();
  request.initParams = initParams;
  Object.defineProperty(request, "debug", {
    enumerable: true,
    get: function() {
      return request.Request.debug;
    },
    set: function(debug) {
      request.Request.debug = debug;
    }
  });
});

// node_modules/node-vault/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var originalDebug = require_src()("node-vault");
  var originalTv4 = require_tv4();
  var originalCommands = require_commands();
  var originalMustache = require_mustache();
  var util = __require("util");
  var request = require_postman_request();

  class VaultError extends Error {
  }

  class ApiResponseError extends VaultError {
    constructor(message, response) {
      super(message);
      this.response = {
        statusCode: response.statusCode,
        body: response.body
      };
    }
  }
  module.exports = (config = {}) => {
    const debug = config.debug || originalDebug;
    const tv4 = config.tv4 || originalTv4;
    const commands = config.commands || originalCommands;
    const mustache = config.mustache || originalMustache;
    const rpDefaults = {
      json: true,
      resolveWithFullResponse: true,
      simple: false,
      strictSSL: !process.env.VAULT_SKIP_VERIFY
    };
    if (config.rpDefaults) {
      Object.keys(config.rpDefaults).forEach((key) => {
        rpDefaults[key] = config.rpDefaults[key];
      });
    }
    const rp = (() => {
      if (config["request-promise"])
        return config["request-promise"].defaults(rpDefaults);
      return util.promisify(request.defaults(rpDefaults));
    })();
    const client = {};
    function handleVaultResponse(response) {
      if (!response)
        return Promise.reject(new VaultError("No response passed"));
      debug(response.statusCode);
      if (response.statusCode !== 200 && response.statusCode !== 204) {
        if (response.request.path.match(/sys\/health/) !== null) {
          return Promise.resolve(response.body);
        }
        let message;
        if (response.body && response.body.errors && response.body.errors.length > 0) {
          message = response.body.errors[0];
        } else {
          message = `Status ${response.statusCode}`;
        }
        const error = new ApiResponseError(message, response);
        return Promise.reject(error);
      }
      return Promise.resolve(response.body);
    }
    client.handleVaultResponse = handleVaultResponse;
    client.apiVersion = config.apiVersion || "v1";
    client.endpoint = config.endpoint || process.env.VAULT_ADDR || "http://127.0.0.1:8200";
    client.pathPrefix = config.pathPrefix || process.env.VAULT_PREFIX || "";
    client.token = config.token || process.env.VAULT_TOKEN;
    client.noCustomHTTPVerbs = config.noCustomHTTPVerbs || false;
    client.namespace = config.namespace || process.env.VAULT_NAMESPACE;
    const requestSchema = {
      type: "object",
      properties: {
        path: {
          type: "string"
        },
        method: {
          type: "string"
        }
      },
      required: ["path", "method"]
    };
    client.request = (options = {}) => {
      const valid = tv4.validate(options, requestSchema);
      if (!valid)
        return Promise.reject(tv4.error);
      let uri = `${client.endpoint}/${client.apiVersion}${client.pathPrefix}${options.path}`;
      uri = uri.replace(/&#x2F;/g, "/");
      options.headers = options.headers || {};
      if (typeof client.token === "string" && client.token.length) {
        options.headers["X-Vault-Token"] = options.headers["X-Vault-Token"] || client.token;
      }
      if (typeof client.namespace === "string" && client.namespace.length) {
        options.headers["X-Vault-Namespace"] = client.namespace;
      }
      options.uri = uri;
      debug(options.method, uri);
      if (options.json)
        debug(options.json);
      return rp(options).then(client.handleVaultResponse);
    };
    client.help = (path, requestOptions) => {
      debug(`help for ${path}`);
      const options = { ...config.requestOptions, ...requestOptions };
      options.path = `/${path}?help=1`;
      options.method = "GET";
      return client.request(options);
    };
    client.write = (path, data, requestOptions) => {
      debug("write %o to %s", data, path);
      const options = { ...config.requestOptions, ...requestOptions };
      options.path = `/${path}`;
      options.json = data;
      options.method = "POST";
      return client.request(options);
    };
    client.read = (path, requestOptions) => {
      debug(`read ${path}`);
      const options = { ...config.requestOptions, ...requestOptions };
      options.path = `/${path}`;
      options.method = "GET";
      return client.request(options);
    };
    client.list = (path, requestOptions) => {
      debug(`list ${path}`);
      const options = { ...config.requestOptions, ...requestOptions };
      options.path = `/${path}`;
      if (client.noCustomHTTPVerbs) {
        options.path = `/${path}?list=1`;
        options.method = "GET";
      } else {
        options.path = `/${path}`;
        options.method = "LIST";
      }
      return client.request(options);
    };
    client.delete = (path, requestOptions) => {
      debug(`delete ${path}`);
      const options = { ...config.requestOptions, ...requestOptions };
      options.path = `/${path}`;
      options.method = "DELETE";
      return client.request(options);
    };
    function validate(json, schema) {
      if (schema === undefined)
        return Promise.resolve();
      const valid = tv4.validate(json, schema);
      if (!valid) {
        debug(tv4.error.dataPath);
        debug(tv4.error.message);
        return Promise.reject(tv4.error);
      }
      return Promise.resolve();
    }
    function extendOptions(conf, options, args = {}) {
      const hasArgs = Object.keys(args).length > 0;
      if (!hasArgs)
        return Promise.resolve(options);
      const querySchema = conf.schema.query;
      if (querySchema) {
        const params = [];
        for (const key of Object.keys(querySchema.properties)) {
          if (key in args) {
            params.push(`${key}=${encodeURIComponent(args[key])}`);
          }
        }
        if (params.length > 0) {
          options.path += `?${params.join("&")}`;
        }
      }
      const reqSchema = conf.schema.req;
      if (reqSchema) {
        const json = {};
        for (const key of Object.keys(reqSchema.properties)) {
          if (key in args) {
            json[key] = args[key];
          }
        }
        if (Object.keys(json).length > 0) {
          options.json = json;
        }
      }
      return Promise.resolve(options);
    }
    function generateFunction(name, conf) {
      client[name] = (args = {}) => {
        const options = { ...config.requestOptions, ...args.requestOptions };
        options.method = conf.method;
        options.path = mustache.render(conf.path, args);
        if (!conf.schema) {
          if (options.method === "POST" || options.method === "PUT") {
            options.json = args;
          }
          return client.request(options);
        }
        let promise = validate(args, conf.schema.req).then(() => validate(args, conf.schema.query)).then(() => extendOptions(conf, options, args)).then((extendedOptions) => client.request(extendedOptions));
        if (conf.tokenSource) {
          promise = promise.then((response) => {
            const candidateToken = response.auth && response.auth.client_token;
            if (candidateToken) {
              client.token = candidateToken;
            }
            return response;
          });
        }
        return promise;
      };
    }
    client.generateFunction = generateFunction;
    const assignFunctions = (commandName) => generateFunction(commandName, commands[commandName]);
    Object.keys(commands).forEach(assignFunctions);
    return client;
  };
});

// node_modules/zod/lib/helpers/util.js
var require_util4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = undefined;
  var util2;
  (function(util3) {
    util3.assertEqual = (val) => val;
    function assertIs(_arg) {}
    util3.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util3.assertNever = assertNever;
    util3.arrayToEnum = (items) => {
      const obj2 = {};
      for (const item of items) {
        obj2[item] = item;
      }
      return obj2;
    };
    util3.getValidEnumValues = (obj2) => {
      const validKeys = util3.objectKeys(obj2).filter((k) => typeof obj2[obj2[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj2[k];
      }
      return util3.objectValues(filtered);
    };
    util3.objectValues = (obj2) => {
      return util3.objectKeys(obj2).map(function(e) {
        return obj2[e];
      });
    };
    util3.objectKeys = typeof Object.keys === "function" ? (obj2) => Object.keys(obj2) : (object2) => {
      const keys = [];
      for (const key in object2) {
        if (Object.prototype.hasOwnProperty.call(object2, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util3.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array2, separator = " | ") {
      return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util3.joinValues = joinValues;
    util3.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util2 || (exports.util = util2 = {}));
  var objectUtil2;
  (function(objectUtil3) {
    objectUtil3.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil2 || (exports.objectUtil = objectUtil2 = {}));
  exports.ZodParsedType = util2.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return exports.ZodParsedType.undefined;
      case "string":
        return exports.ZodParsedType.string;
      case "number":
        return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
      case "boolean":
        return exports.ZodParsedType.boolean;
      case "function":
        return exports.ZodParsedType.function;
      case "bigint":
        return exports.ZodParsedType.bigint;
      case "symbol":
        return exports.ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return exports.ZodParsedType.array;
        }
        if (data === null) {
          return exports.ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return exports.ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return exports.ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return exports.ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return exports.ZodParsedType.date;
        }
        return exports.ZodParsedType.object;
      default:
        return exports.ZodParsedType.unknown;
    }
  };
  exports.getParsedType = getParsedType2;
});

// node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = undefined;
  var util_1 = require_util4();
  exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson2 = (obj2) => {
    const json = JSON.stringify(obj2, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  exports.quotelessJson = quotelessJson2;

  class ZodError2 extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError2)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  exports.ZodError = ZodError2;
  ZodError2.create = (issues) => {
    const error = new ZodError2(issues);
    return error;
  };
});

// node_modules/zod/lib/locales/en.js
var require_en = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util4();
  var ZodError_1 = require_ZodError();
  var errorMap2 = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodError_1.ZodIssueCode.invalid_type:
        if (issue.received === util_1.ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodError_1.ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
        break;
      case ZodError_1.ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodError_1.ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodError_1.ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
        break;
      case ZodError_1.ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodError_1.ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodError_1.ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodError_1.ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodError_1.ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util_1.util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodError_1.ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_1.ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_1.ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodError_1.ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodError_1.ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodError_1.ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util_1.util.assertNever(issue);
    }
    return { message };
  };
  exports.default = errorMap2;
});

// node_modules/zod/lib/errors.js
var require_errors4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = undefined;
  var en_1 = __importDefault(require_en());
  exports.defaultErrorMap = en_1.default;
  var overrideErrorMap2 = en_1.default;
  function setErrorMap2(map2) {
    overrideErrorMap2 = map2;
  }
  exports.setErrorMap = setErrorMap2;
  function getErrorMap2() {
    return overrideErrorMap2;
  }
  exports.getErrorMap = getErrorMap2;
});

// node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = undefined;
  var errors_1 = require_errors4();
  var en_1 = __importDefault(require_en());
  var makeIssue2 = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== undefined) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  exports.makeIssue = makeIssue2;
  exports.EMPTY_PATH = [];
  function addIssueToContext2(ctx, issueData) {
    const overrideMap = (0, errors_1.getErrorMap)();
    const issue = (0, exports.makeIssue)({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        overrideMap,
        overrideMap === en_1.default ? undefined : en_1.default
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  exports.addIssueToContext = addIssueToContext2;

  class ParseStatus2 {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return exports.INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus2.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return exports.INVALID;
        if (value.status === "aborted")
          return exports.INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  exports.ParseStatus = ParseStatus2;
  exports.INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY2 = (value) => ({ status: "dirty", value });
  exports.DIRTY = DIRTY2;
  var OK2 = (value) => ({ status: "valid", value });
  exports.OK = OK2;
  var isAborted2 = (x) => x.status === "aborted";
  exports.isAborted = isAborted2;
  var isDirty2 = (x) => x.status === "dirty";
  exports.isDirty = isDirty2;
  var isValid2 = (x) => x.status === "valid";
  exports.isValid = isValid2;
  var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  exports.isAsync = isAsync2;
});

// node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errorUtil = undefined;
  var errorUtil2;
  (function(errorUtil3) {
    errorUtil3.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil3.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
  })(errorUtil2 || (exports.errorUtil = errorUtil2 = {}));
});

// node_modules/zod/lib/types.js
var require_types2 = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f2) {
    if (kind === "a" && !f2)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f2)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
  };
  var _ZodEnum_cache2;
  var _ZodNativeEnum_cache2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.datetimeRegex = exports.ZodType = undefined;
  exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = exports.date = undefined;
  var errors_1 = require_errors4();
  var errorUtil_1 = require_errorUtil();
  var parseUtil_1 = require_parseUtil();
  var util_1 = require_util4();
  var ZodError_1 = require_ZodError();

  class ParseInputLazyPath2 {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  var handleResult2 = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError_1.ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams3(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a, _b;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== undefined ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }

  class ZodType2 {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: (0, util_1.getParsedType)(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new parseUtil_1.ParseStatus,
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if ((0, parseUtil_1.isAsync)(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
          contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
        },
        path: (params === null || params === undefined ? undefined : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_1.getParsedType)(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult2(ctx, result);
    }
    "~validate"(data) {
      var _a, _b;
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_1.getParsedType)(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return (0, parseUtil_1.isValid)(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_1.isValid)(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
          async: true
        },
        path: (params === null || params === undefined ? undefined : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_1.getParsedType)(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult2(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodError_1.ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects2({
        schema: this,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional2.create(this, this._def);
    }
    nullable() {
      return ZodNullable2.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray2.create(this);
    }
    promise() {
      return ZodPromise2.create(this, this._def);
    }
    or(option) {
      return ZodUnion2.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection2.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects2({
        ...processCreateParams3(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault2({
        ...processCreateParams3(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind2.ZodDefault
      });
    }
    brand() {
      return new ZodBranded2({
        typeName: ZodFirstPartyTypeKind2.ZodBranded,
        type: this,
        ...processCreateParams3(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch2({
        ...processCreateParams3(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind2.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline2.create(this, target);
    }
    readonly() {
      return ZodReadonly2.create(this);
    }
    isOptional() {
      return this.safeParse(undefined).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  exports.ZodType = ZodType2;
  exports.Schema = ZodType2;
  exports.ZodSchema = ZodType2;
  var cuidRegex2 = /^c[^\s-]{8,}$/i;
  var cuid2Regex2 = /^[0-9a-z]+$/;
  var ulidRegex2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var uuidRegex2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex2 = /^[a-z0-9_-]{21}$/i;
  var jwtRegex2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var durationRegex2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex3;
  var ipv4Regex2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv4CidrRegex2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var ipv6Regex2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var ipv6CidrRegex2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64Regex2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var base64urlRegex2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var dateRegexSource2 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex2 = new RegExp(`^${dateRegexSource2}$`);
  function timeRegexSource2(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex2(args) {
    return new RegExp(`^${timeRegexSource2(args)}$`);
  }
  function datetimeRegex2(args) {
    let regex = `${dateRegexSource2}T${timeRegexSource2(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  exports.datetimeRegex = datetimeRegex2;
  function isValidIP2(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex2.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex2.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT2(jwt, alg) {
    if (!jwtRegex2.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if (!decoded.typ || !decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch (_a) {
      return false;
    }
  }
  function isValidCidr2(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex2.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex2.test(ip)) {
      return true;
    }
    return false;
  }

  class ZodString2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.string,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const status = new parseUtil_1.ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "email",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex3) {
            emojiRegex3 = new RegExp(_emojiRegex2, "u");
          }
          if (!emojiRegex3.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "emoji",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "uuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "nanoid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid2",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ulid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "url",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "regex",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex2(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex2;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex2(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "duration",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP2(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ip",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT2(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "jwt",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr2(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cidr",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "base64",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "base64url",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodError_1.ZodIssueCode.invalid_string,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a, _b;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
        local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === undefined ? undefined : options.position,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  exports.ZodString = ZodString2;
  ZodString2.create = (params) => {
    var _a;
    return new ZodString2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodString,
      coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
      ...processCreateParams3(params)
    });
  };
  function floatSafeRemainder2(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }

  class ZodNumber2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.number,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      let ctx = undefined;
      const status = new parseUtil_1.ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util_1.util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder2(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber2({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil_1.errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  exports.ZodNumber = ZodNumber2;
  ZodNumber2.create = (params) => {
    return new ZodNumber2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodNumber,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams3(params)
    });
  };

  class ZodBigInt2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch (_a) {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new parseUtil_1.ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_1.addIssueToContext)(ctx, {
        code: ZodError_1.ZodIssueCode.invalid_type,
        expected: util_1.ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return parseUtil_1.INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt2({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  exports.ZodBigInt = ZodBigInt2;
  ZodBigInt2.create = (params) => {
    var _a;
    return new ZodBigInt2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodBigInt,
      coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
      ...processCreateParams3(params)
    });
  };

  class ZodBoolean2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodBoolean = ZodBoolean2;
  ZodBoolean2.create = (params) => {
    return new ZodBoolean2({
      typeName: ZodFirstPartyTypeKind2.ZodBoolean,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams3(params)
    });
  };

  class ZodDate2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.date,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_date
        });
        return parseUtil_1.INVALID;
      }
      const status = new parseUtil_1.ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  exports.ZodDate = ZodDate2;
  ZodDate2.create = (params) => {
    return new ZodDate2({
      checks: [],
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind2.ZodDate,
      ...processCreateParams3(params)
    });
  };

  class ZodSymbol2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodSymbol = ZodSymbol2;
  ZodSymbol2.create = (params) => {
    return new ZodSymbol2({
      typeName: ZodFirstPartyTypeKind2.ZodSymbol,
      ...processCreateParams3(params)
    });
  };

  class ZodUndefined2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodUndefined = ZodUndefined2;
  ZodUndefined2.create = (params) => {
    return new ZodUndefined2({
      typeName: ZodFirstPartyTypeKind2.ZodUndefined,
      ...processCreateParams3(params)
    });
  };

  class ZodNull2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.null,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodNull = ZodNull2;
  ZodNull2.create = (params) => {
    return new ZodNull2({
      typeName: ZodFirstPartyTypeKind2.ZodNull,
      ...processCreateParams3(params)
    });
  };

  class ZodAny2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodAny = ZodAny2;
  ZodAny2.create = (params) => {
    return new ZodAny2({
      typeName: ZodFirstPartyTypeKind2.ZodAny,
      ...processCreateParams3(params)
    });
  };

  class ZodUnknown2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodUnknown = ZodUnknown2;
  ZodUnknown2.create = (params) => {
    return new ZodUnknown2({
      typeName: ZodFirstPartyTypeKind2.ZodUnknown,
      ...processCreateParams3(params)
    });
  };

  class ZodNever2 extends ZodType2 {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_1.addIssueToContext)(ctx, {
        code: ZodError_1.ZodIssueCode.invalid_type,
        expected: util_1.ZodParsedType.never,
        received: ctx.parsedType
      });
      return parseUtil_1.INVALID;
    }
  }
  exports.ZodNever = ZodNever2;
  ZodNever2.create = (params) => {
    return new ZodNever2({
      typeName: ZodFirstPartyTypeKind2.ZodNever,
      ...processCreateParams3(params)
    });
  };

  class ZodVoid2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.void,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodVoid = ZodVoid2;
  ZodVoid2.create = (params) => {
    return new ZodVoid2({
      typeName: ZodFirstPartyTypeKind2.ZodVoid,
      ...processCreateParams3(params)
    });
  };

  class ZodArray2 extends ZodType2 {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== util_1.ZodParsedType.array) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
        })).then((result2) => {
          return parseUtil_1.ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
      });
      return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray2({
        ...this._def,
        minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray2({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray2({
        ...this._def,
        exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  exports.ZodArray = ZodArray2;
  ZodArray2.create = (schema, params) => {
    return new ZodArray2({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind2.ZodArray,
      ...processCreateParams3(params)
    });
  };
  function deepPartialify2(schema) {
    if (schema instanceof ZodObject2) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
      }
      return new ZodObject2({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray2) {
      return new ZodArray2({
        ...schema._def,
        type: deepPartialify2(schema.element)
      });
    } else if (schema instanceof ZodOptional2) {
      return ZodOptional2.create(deepPartialify2(schema.unwrap()));
    } else if (schema instanceof ZodNullable2) {
      return ZodNullable2.create(deepPartialify2(schema.unwrap()));
    } else if (schema instanceof ZodTuple2) {
      return ZodTuple2.create(schema.items.map((item) => deepPartialify2(item)));
    } else {
      return schema;
    }
  }

  class ZodObject2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util_1.util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever2) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {} else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil_1.errorUtil.errToObj;
      return new ZodObject2({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject2({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject2({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject2({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject2({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind2.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject2({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util_1.util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify2(this);
    }
    partial(mask) {
      const newShape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional2) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum2(util_1.util.objectKeys(this.shape));
    }
  }
  exports.ZodObject = ZodObject2;
  ZodObject2.create = (shape, params) => {
    return new ZodObject2({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams3(params)
    });
  };
  ZodObject2.strictCreate = (shape, params) => {
    return new ZodObject2({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams3(params)
    });
  };
  ZodObject2.lazycreate = (shape, params) => {
    return new ZodObject2({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams3(params)
    });
  };

  class ZodUnion2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_1.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  exports.ZodUnion = ZodUnion2;
  ZodUnion2.create = (types, params) => {
    return new ZodUnion2({
      options: types,
      typeName: ZodFirstPartyTypeKind2.ZodUnion,
      ...processCreateParams3(params)
    });
  };
  var getDiscriminator2 = (type) => {
    if (type instanceof ZodLazy2) {
      return getDiscriminator2(type.schema);
    } else if (type instanceof ZodEffects2) {
      return getDiscriminator2(type.innerType());
    } else if (type instanceof ZodLiteral2) {
      return [type.value];
    } else if (type instanceof ZodEnum2) {
      return type.options;
    } else if (type instanceof ZodNativeEnum2) {
      return util_1.util.objectValues(type.enum);
    } else if (type instanceof ZodDefault2) {
      return getDiscriminator2(type._def.innerType);
    } else if (type instanceof ZodUndefined2) {
      return [undefined];
    } else if (type instanceof ZodNull2) {
      return [null];
    } else if (type instanceof ZodOptional2) {
      return [undefined, ...getDiscriminator2(type.unwrap())];
    } else if (type instanceof ZodNullable2) {
      return [null, ...getDiscriminator2(type.unwrap())];
    } else if (type instanceof ZodBranded2) {
      return getDiscriminator2(type.unwrap());
    } else if (type instanceof ZodReadonly2) {
      return getDiscriminator2(type.unwrap());
    } else if (type instanceof ZodCatch2) {
      return getDiscriminator2(type._def.innerType);
    } else {
      return [];
    }
  };

  class ZodDiscriminatedUnion2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.object) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator2(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion2({
        typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams3(params)
      });
    }
  }
  exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion2;
  function mergeValues2(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
      const bKeys = util_1.util.objectKeys(b);
      const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues2(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0;index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues2(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }

  class ZodIntersection2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
          return parseUtil_1.INVALID;
        }
        const merged = mergeValues2(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_intersection_types
          });
          return parseUtil_1.INVALID;
        }
        if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  exports.ZodIntersection = ZodIntersection2;
  ZodIntersection2.create = (left, right, params) => {
    return new ZodIntersection2({
      left,
      right,
      typeName: ZodFirstPartyTypeKind2.ZodIntersection,
      ...processCreateParams3(params)
    });
  };

  class ZodTuple2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.array) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return parseUtil_1.INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return parseUtil_1.ParseStatus.mergeArray(status, results);
        });
      } else {
        return parseUtil_1.ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple2({
        ...this._def,
        rest
      });
    }
  }
  exports.ZodTuple = ZodTuple2;
  ZodTuple2.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple2({
      items: schemas,
      typeName: ZodFirstPartyTypeKind2.ZodTuple,
      rest: null,
      ...processCreateParams3(params)
    });
  };

  class ZodRecord2 extends ZodType2 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.object) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType2) {
        return new ZodRecord2({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams3(third)
        });
      }
      return new ZodRecord2({
        keyType: ZodString2.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams3(second)
      });
    }
  }
  exports.ZodRecord = ZodRecord2;

  class ZodMap2 extends ZodType2 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.map) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.map,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return parseUtil_1.INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  exports.ZodMap = ZodMap2;
  ZodMap2.create = (keyType, valueType, params) => {
    return new ZodMap2({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind2.ZodMap,
      ...processCreateParams3(params)
    });
  };

  class ZodSet2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.set) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.set,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return parseUtil_1.INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet2({
        ...this._def,
        minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet2({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  exports.ZodSet = ZodSet2;
  ZodSet2.create = (valueType, params) => {
    return new ZodSet2({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind2.ZodSet,
      ...processCreateParams3(params)
    });
  };

  class ZodFunction2 extends ZodType2 {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.function) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.function,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      function makeArgsIssue(args, error) {
        return (0, parseUtil_1.makeIssue)({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            errors_1.defaultErrorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodError_1.ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return (0, parseUtil_1.makeIssue)({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            errors_1.defaultErrorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodError_1.ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise2) {
        const me = this;
        return (0, parseUtil_1.OK)(async function(...args) {
          const error = new ZodError_1.ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return (0, parseUtil_1.OK)(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction2({
        ...this._def,
        args: ZodTuple2.create(items).rest(ZodUnknown2.create())
      });
    }
    returns(returnType) {
      return new ZodFunction2({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction2({
        args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
        returns: returns || ZodUnknown2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodFunction,
        ...processCreateParams3(params)
      });
    }
  }
  exports.ZodFunction = ZodFunction2;

  class ZodLazy2 extends ZodType2 {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  exports.ZodLazy = ZodLazy2;
  ZodLazy2.create = (getter, params) => {
    return new ZodLazy2({
      getter,
      typeName: ZodFirstPartyTypeKind2.ZodLazy,
      ...processCreateParams3(params)
    });
  };

  class ZodLiteral2 extends ZodType2 {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return parseUtil_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  exports.ZodLiteral = ZodLiteral2;
  ZodLiteral2.create = (value, params) => {
    return new ZodLiteral2({
      value,
      typeName: ZodFirstPartyTypeKind2.ZodLiteral,
      ...processCreateParams3(params)
    });
  };
  function createZodEnum2(values, params) {
    return new ZodEnum2({
      values,
      typeName: ZodFirstPartyTypeKind2.ZodEnum,
      ...processCreateParams3(params)
    });
  }

  class ZodEnum2 extends ZodType2 {
    constructor() {
      super(...arguments);
      _ZodEnum_cache2.set(this, undefined);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_1.addIssueToContext)(ctx, {
          expected: util_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_1.ZodIssueCode.invalid_type
        });
        return parseUtil_1.INVALID;
      }
      if (!__classPrivateFieldGet2(this, _ZodEnum_cache2, "f")) {
        __classPrivateFieldSet2(this, _ZodEnum_cache2, new Set(this._def.values), "f");
      }
      if (!__classPrivateFieldGet2(this, _ZodEnum_cache2, "f").has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum2.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  exports.ZodEnum = ZodEnum2;
  _ZodEnum_cache2 = new WeakMap;
  ZodEnum2.create = createZodEnum2;

  class ZodNativeEnum2 extends ZodType2 {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache2.set(this, undefined);
    }
    _parse(input) {
      const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
        const expectedValues = util_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          expected: util_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_1.ZodIssueCode.invalid_type
        });
        return parseUtil_1.INVALID;
      }
      if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache2, "f")) {
        __classPrivateFieldSet2(this, _ZodNativeEnum_cache2, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
      }
      if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache2, "f").has(input.data)) {
        const expectedValues = util_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  exports.ZodNativeEnum = ZodNativeEnum2;
  _ZodNativeEnum_cache2 = new WeakMap;
  ZodNativeEnum2.create = (values, params) => {
    return new ZodNativeEnum2({
      values,
      typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
      ...processCreateParams3(params)
    });
  };

  class ZodPromise2 extends ZodType2 {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.promise,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return (0, parseUtil_1.OK)(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  exports.ZodPromise = ZodPromise2;
  ZodPromise2.create = (schema, params) => {
    return new ZodPromise2({
      type: schema,
      typeName: ZodFirstPartyTypeKind2.ZodPromise,
      ...processCreateParams3(params)
    });
  };

  class ZodEffects2 extends ZodType2 {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          (0, parseUtil_1.addIssueToContext)(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return parseUtil_1.INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return parseUtil_1.INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return parseUtil_1.INVALID;
          if (result.status === "dirty")
            return (0, parseUtil_1.DIRTY)(result.value);
          if (status.value === "dirty")
            return (0, parseUtil_1.DIRTY)(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return parseUtil_1.INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!(0, parseUtil_1.isValid)(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util_1.util.assertNever(effect);
    }
  }
  exports.ZodEffects = ZodEffects2;
  exports.ZodTransformer = ZodEffects2;
  ZodEffects2.create = (schema, effect, params) => {
    return new ZodEffects2({
      schema,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect,
      ...processCreateParams3(params)
    });
  };
  ZodEffects2.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects2({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      ...processCreateParams3(params)
    });
  };

  class ZodOptional2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_1.ZodParsedType.undefined) {
        return (0, parseUtil_1.OK)(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodOptional = ZodOptional2;
  ZodOptional2.create = (type, params) => {
    return new ZodOptional2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodOptional,
      ...processCreateParams3(params)
    });
  };

  class ZodNullable2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_1.ZodParsedType.null) {
        return (0, parseUtil_1.OK)(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodNullable = ZodNullable2;
  ZodNullable2.create = (type, params) => {
    return new ZodNullable2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodNullable,
      ...processCreateParams3(params)
    });
  };

  class ZodDefault2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === util_1.ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  exports.ZodDefault = ZodDefault2;
  ZodDefault2.create = (type, params) => {
    return new ZodDefault2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams3(params)
    });
  };

  class ZodCatch2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if ((0, parseUtil_1.isAsync)(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  exports.ZodCatch = ZodCatch2;
  ZodCatch2.create = (type, params) => {
    return new ZodCatch2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams3(params)
    });
  };

  class ZodNaN2 extends ZodType2 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.nan,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  exports.ZodNaN = ZodNaN2;
  ZodNaN2.create = (params) => {
    return new ZodNaN2({
      typeName: ZodFirstPartyTypeKind2.ZodNaN,
      ...processCreateParams3(params)
    });
  };
  exports.BRAND = Symbol("zod_brand");

  class ZodBranded2 extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  exports.ZodBranded = ZodBranded2;

  class ZodPipeline2 extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return (0, parseUtil_1.DIRTY)(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return parseUtil_1.INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline2({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind2.ZodPipeline
      });
    }
  }
  exports.ZodPipeline = ZodPipeline2;

  class ZodReadonly2 extends ZodType2 {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if ((0, parseUtil_1.isValid)(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return (0, parseUtil_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodReadonly = ZodReadonly2;
  ZodReadonly2.create = (type, params) => {
    return new ZodReadonly2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodReadonly,
      ...processCreateParams3(params)
    });
  };
  function cleanParams2(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom2(check, _params = {}, fatal) {
    if (check)
      return ZodAny2.create().superRefine((data, ctx) => {
        var _a, _b;
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            var _a2, _b2;
            if (!r2) {
              const params = cleanParams2(_params, data);
              const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams2(_params, data);
          const _fatal = (_b = (_a = params.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny2.create();
  }
  exports.custom = custom2;
  exports.late = {
    object: ZodObject2.lazycreate
  };
  var ZodFirstPartyTypeKind2;
  (function(ZodFirstPartyTypeKind3) {
    ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind2 || (exports.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind2 = {}));
  var instanceOfType2 = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom2((data) => data instanceof cls, params);
  exports.instanceof = instanceOfType2;
  var stringType2 = ZodString2.create;
  exports.string = stringType2;
  var numberType2 = ZodNumber2.create;
  exports.number = numberType2;
  var nanType2 = ZodNaN2.create;
  exports.nan = nanType2;
  var bigIntType2 = ZodBigInt2.create;
  exports.bigint = bigIntType2;
  var booleanType2 = ZodBoolean2.create;
  exports.boolean = booleanType2;
  var dateType2 = ZodDate2.create;
  exports.date = dateType2;
  var symbolType2 = ZodSymbol2.create;
  exports.symbol = symbolType2;
  var undefinedType2 = ZodUndefined2.create;
  exports.undefined = undefinedType2;
  var nullType2 = ZodNull2.create;
  exports.null = nullType2;
  var anyType2 = ZodAny2.create;
  exports.any = anyType2;
  var unknownType2 = ZodUnknown2.create;
  exports.unknown = unknownType2;
  var neverType2 = ZodNever2.create;
  exports.never = neverType2;
  var voidType2 = ZodVoid2.create;
  exports.void = voidType2;
  var arrayType2 = ZodArray2.create;
  exports.array = arrayType2;
  var objectType2 = ZodObject2.create;
  exports.object = objectType2;
  var strictObjectType2 = ZodObject2.strictCreate;
  exports.strictObject = strictObjectType2;
  var unionType2 = ZodUnion2.create;
  exports.union = unionType2;
  var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
  exports.discriminatedUnion = discriminatedUnionType2;
  var intersectionType2 = ZodIntersection2.create;
  exports.intersection = intersectionType2;
  var tupleType2 = ZodTuple2.create;
  exports.tuple = tupleType2;
  var recordType2 = ZodRecord2.create;
  exports.record = recordType2;
  var mapType2 = ZodMap2.create;
  exports.map = mapType2;
  var setType2 = ZodSet2.create;
  exports.set = setType2;
  var functionType2 = ZodFunction2.create;
  exports.function = functionType2;
  var lazyType2 = ZodLazy2.create;
  exports.lazy = lazyType2;
  var literalType2 = ZodLiteral2.create;
  exports.literal = literalType2;
  var enumType2 = ZodEnum2.create;
  exports.enum = enumType2;
  var nativeEnumType2 = ZodNativeEnum2.create;
  exports.nativeEnum = nativeEnumType2;
  var promiseType2 = ZodPromise2.create;
  exports.promise = promiseType2;
  var effectsType2 = ZodEffects2.create;
  exports.effect = effectsType2;
  exports.transformer = effectsType2;
  var optionalType2 = ZodOptional2.create;
  exports.optional = optionalType2;
  var nullableType2 = ZodNullable2.create;
  exports.nullable = nullableType2;
  var preprocessType2 = ZodEffects2.createWithPreprocess;
  exports.preprocess = preprocessType2;
  var pipelineType2 = ZodPipeline2.create;
  exports.pipeline = pipelineType2;
  var ostring2 = () => stringType2().optional();
  exports.ostring = ostring2;
  var onumber2 = () => numberType2().optional();
  exports.onumber = onumber2;
  var oboolean2 = () => booleanType2().optional();
  exports.oboolean = oboolean2;
  exports.coerce = {
    string: (arg) => ZodString2.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber2.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean2.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt2.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate2.create({ ...arg, coerce: true })
  };
  exports.NEVER = parseUtil_1.INVALID;
});

// node_modules/zod/lib/external.js
var require_external = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors4(), exports);
  __exportStar(require_parseUtil(), exports);
  __exportStar(require_typeAliases(), exports);
  __exportStar(require_util4(), exports);
  __exportStar(require_types2(), exports);
  __exportStar(require_ZodError(), exports);
});

// node_modules/zod/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.z = undefined;
  var z2 = __importStar(require_external());
  exports.z = z2;
  __exportStar(require_external(), exports);
  exports.default = z2;
});

// src/index.ts
var import_node_vault = __toESM(require_src2(), 1);

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj2 = {};
    for (const item of items) {
      obj2[item] = item;
    }
    return obj2;
  };
  util2.getValidEnumValues = (obj2) => {
    const validKeys = util2.objectKeys(obj2).filter((k) => typeof obj2[obj2[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj2[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj2) => {
    return util2.objectKeys(obj2).map(function(e) {
      return obj2[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj2) => Object.keys(obj2) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj2) => {
  const json = JSON.stringify(obj2, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2024-11-05";
var SUPPORTED_PROTOCOL_VERSIONS = [
  LATEST_PROTOCOL_VERSION,
  "2024-10-07"
];
var JSONRPC_VERSION = "2.0";
var ProgressTokenSchema = z.union([z.string(), z.number().int()]);
var CursorSchema = z.string();
var BaseRequestParamsSchema = z.object({
  _meta: z.optional(z.object({
    progressToken: z.optional(ProgressTokenSchema)
  }).passthrough())
}).passthrough();
var RequestSchema = z.object({
  method: z.string(),
  params: z.optional(BaseRequestParamsSchema)
});
var BaseNotificationParamsSchema = z.object({
  _meta: z.optional(z.object({}).passthrough())
}).passthrough();
var NotificationSchema = z.object({
  method: z.string(),
  params: z.optional(BaseNotificationParamsSchema)
});
var ResultSchema = z.object({
  _meta: z.optional(z.object({}).passthrough())
}).passthrough();
var RequestIdSchema = z.union([z.string(), z.number().int()]);
var JSONRPCRequestSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION),
  id: RequestIdSchema
}).merge(RequestSchema).strict();
var JSONRPCNotificationSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION)
}).merge(NotificationSchema).strict();
var JSONRPCResponseSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32000] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  error: z.object({
    code: z.number().int(),
    message: z.string(),
    data: z.optional(z.unknown())
  })
}).strict();
var JSONRPCMessageSchema = z.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/cancelled"),
  params: BaseNotificationParamsSchema.extend({
    requestId: RequestIdSchema,
    reason: z.string().optional()
  })
});
var ImplementationSchema = z.object({
  name: z.string(),
  version: z.string()
}).passthrough();
var ClientCapabilitiesSchema = z.object({
  experimental: z.optional(z.object({}).passthrough()),
  sampling: z.optional(z.object({}).passthrough()),
  roots: z.optional(z.object({
    listChanged: z.optional(z.boolean())
  }).passthrough())
}).passthrough();
var InitializeRequestSchema = RequestSchema.extend({
  method: z.literal("initialize"),
  params: BaseRequestParamsSchema.extend({
    protocolVersion: z.string(),
    capabilities: ClientCapabilitiesSchema,
    clientInfo: ImplementationSchema
  })
});
var ServerCapabilitiesSchema = z.object({
  experimental: z.optional(z.object({}).passthrough()),
  logging: z.optional(z.object({}).passthrough()),
  completions: z.optional(z.object({}).passthrough()),
  prompts: z.optional(z.object({
    listChanged: z.optional(z.boolean())
  }).passthrough()),
  resources: z.optional(z.object({
    subscribe: z.optional(z.boolean()),
    listChanged: z.optional(z.boolean())
  }).passthrough()),
  tools: z.optional(z.object({
    listChanged: z.optional(z.boolean())
  }).passthrough())
}).passthrough();
var InitializeResultSchema = ResultSchema.extend({
  protocolVersion: z.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  instructions: z.optional(z.string())
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/initialized")
});
var PingRequestSchema = RequestSchema.extend({
  method: z.literal("ping")
});
var ProgressSchema = z.object({
  progress: z.number(),
  total: z.optional(z.number())
}).passthrough();
var ProgressNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/progress"),
  params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
    progressToken: ProgressTokenSchema
  })
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: BaseRequestParamsSchema.extend({
    cursor: z.optional(CursorSchema)
  }).optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: z.optional(CursorSchema)
});
var ResourceContentsSchema = z.object({
  uri: z.string(),
  mimeType: z.optional(z.string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: z.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: z.string().base64()
});
var ResourceSchema = z.object({
  uri: z.string(),
  name: z.string(),
  description: z.optional(z.string()),
  mimeType: z.optional(z.string())
}).passthrough();
var ResourceTemplateSchema = z.object({
  uriTemplate: z.string(),
  name: z.string(),
  description: z.optional(z.string()),
  mimeType: z.optional(z.string())
}).passthrough();
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: z.literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: z.array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: z.literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: z.array(ResourceTemplateSchema)
});
var ReadResourceRequestSchema = RequestSchema.extend({
  method: z.literal("resources/read"),
  params: BaseRequestParamsSchema.extend({
    uri: z.string()
  })
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: z.array(z.union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/resources/list_changed")
});
var SubscribeRequestSchema = RequestSchema.extend({
  method: z.literal("resources/subscribe"),
  params: BaseRequestParamsSchema.extend({
    uri: z.string()
  })
});
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: z.literal("resources/unsubscribe"),
  params: BaseRequestParamsSchema.extend({
    uri: z.string()
  })
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/resources/updated"),
  params: BaseNotificationParamsSchema.extend({
    uri: z.string()
  })
});
var PromptArgumentSchema = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  required: z.optional(z.boolean())
}).passthrough();
var PromptSchema = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  arguments: z.optional(z.array(PromptArgumentSchema))
}).passthrough();
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: z.literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: z.array(PromptSchema)
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: z.literal("prompts/get"),
  params: BaseRequestParamsSchema.extend({
    name: z.string(),
    arguments: z.optional(z.record(z.string()))
  })
});
var TextContentSchema = z.object({
  type: z.literal("text"),
  text: z.string()
}).passthrough();
var ImageContentSchema = z.object({
  type: z.literal("image"),
  data: z.string().base64(),
  mimeType: z.string()
}).passthrough();
var AudioContentSchema = z.object({
  type: z.literal("audio"),
  data: z.string().base64(),
  mimeType: z.string()
}).passthrough();
var EmbeddedResourceSchema = z.object({
  type: z.literal("resource"),
  resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).passthrough();
var PromptMessageSchema = z.object({
  role: z.enum(["user", "assistant"]),
  content: z.union([
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    EmbeddedResourceSchema
  ])
}).passthrough();
var GetPromptResultSchema = ResultSchema.extend({
  description: z.optional(z.string()),
  messages: z.array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/prompts/list_changed")
});
var ToolSchema = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  inputSchema: z.object({
    type: z.literal("object"),
    properties: z.optional(z.object({}).passthrough())
  }).passthrough()
}).passthrough();
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: z.literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: z.array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  content: z.array(z.union([TextContentSchema, ImageContentSchema, AudioContentSchema, EmbeddedResourceSchema])),
  isError: z.boolean().default(false).optional()
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: z.unknown()
}));
var CallToolRequestSchema = RequestSchema.extend({
  method: z.literal("tools/call"),
  params: BaseRequestParamsSchema.extend({
    name: z.string(),
    arguments: z.optional(z.record(z.unknown()))
  })
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/tools/list_changed")
});
var LoggingLevelSchema = z.enum([
  "debug",
  "info",
  "notice",
  "warning",
  "error",
  "critical",
  "alert",
  "emergency"
]);
var SetLevelRequestSchema = RequestSchema.extend({
  method: z.literal("logging/setLevel"),
  params: BaseRequestParamsSchema.extend({
    level: LoggingLevelSchema
  })
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/message"),
  params: BaseNotificationParamsSchema.extend({
    level: LoggingLevelSchema,
    logger: z.optional(z.string()),
    data: z.unknown()
  })
});
var ModelHintSchema = z.object({
  name: z.string().optional()
}).passthrough();
var ModelPreferencesSchema = z.object({
  hints: z.optional(z.array(ModelHintSchema)),
  costPriority: z.optional(z.number().min(0).max(1)),
  speedPriority: z.optional(z.number().min(0).max(1)),
  intelligencePriority: z.optional(z.number().min(0).max(1))
}).passthrough();
var SamplingMessageSchema = z.object({
  role: z.enum(["user", "assistant"]),
  content: z.union([TextContentSchema, ImageContentSchema, AudioContentSchema])
}).passthrough();
var CreateMessageRequestSchema = RequestSchema.extend({
  method: z.literal("sampling/createMessage"),
  params: BaseRequestParamsSchema.extend({
    messages: z.array(SamplingMessageSchema),
    systemPrompt: z.optional(z.string()),
    includeContext: z.optional(z.enum(["none", "thisServer", "allServers"])),
    temperature: z.optional(z.number()),
    maxTokens: z.number().int(),
    stopSequences: z.optional(z.array(z.string())),
    metadata: z.optional(z.object({}).passthrough()),
    modelPreferences: z.optional(ModelPreferencesSchema)
  })
});
var CreateMessageResultSchema = ResultSchema.extend({
  model: z.string(),
  stopReason: z.optional(z.enum(["endTurn", "stopSequence", "maxTokens"]).or(z.string())),
  role: z.enum(["user", "assistant"]),
  content: z.discriminatedUnion("type", [
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema
  ])
});
var ResourceReferenceSchema = z.object({
  type: z.literal("ref/resource"),
  uri: z.string()
}).passthrough();
var PromptReferenceSchema = z.object({
  type: z.literal("ref/prompt"),
  name: z.string()
}).passthrough();
var CompleteRequestSchema = RequestSchema.extend({
  method: z.literal("completion/complete"),
  params: BaseRequestParamsSchema.extend({
    ref: z.union([PromptReferenceSchema, ResourceReferenceSchema]),
    argument: z.object({
      name: z.string(),
      value: z.string()
    }).passthrough()
  })
});
var CompleteResultSchema = ResultSchema.extend({
  completion: z.object({
    values: z.array(z.string()).max(100),
    total: z.optional(z.number().int()),
    hasMore: z.optional(z.boolean())
  }).passthrough()
});
var RootSchema = z.object({
  uri: z.string().startsWith("file://"),
  name: z.optional(z.string())
}).passthrough();
var ListRootsRequestSchema = RequestSchema.extend({
  method: z.literal("roots/list")
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: z.array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/roots/list_changed")
});
var ClientRequestSchema = z.union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema
]);
var ClientNotificationSchema = z.union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema
]);
var ClientResultSchema = z.union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  ListRootsResultSchema
]);
var ServerRequestSchema = z.union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ListRootsRequestSchema
]);
var ServerNotificationSchema = z.union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema
]);
var ServerResultSchema = z.union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema
]);

class McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;

class Protocol {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = new Map;
    this._requestHandlerAbortControllers = new Map;
    this._notificationHandlers = new Map;
    this._responseHandlers = new Map;
    this._progressHandlers = new Map;
    this._timeoutInfo = new Map;
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
      controller === null || controller === undefined || controller.abort(notification.params.reason);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(PingRequestSchema, (_request) => ({}));
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  async connect(transport) {
    this._transport = transport;
    this._transport.onclose = () => {
      this._onclose();
    };
    this._transport.onerror = (error) => {
      this._onerror(error);
    };
    this._transport.onmessage = (message) => {
      if (!("method" in message)) {
        this._onresponse(message);
      } else if ("id" in message) {
        this._onrequest(message);
      } else {
        this._onnotification(message);
      }
    };
    await this._transport.start();
  }
  _onclose() {
    var _a;
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = new Map;
    this._progressHandlers.clear();
    this._transport = undefined;
    (_a = this.onclose) === null || _a === undefined || _a.call(this);
    const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
    for (const handler of responseHandlers.values()) {
      handler(error);
    }
  }
  _onerror(error) {
    var _a;
    (_a = this.onerror) === null || _a === undefined || _a.call(this, error);
  }
  _onnotification(notification) {
    var _a;
    const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== undefined ? _a : this.fallbackNotificationHandler;
    if (handler === undefined) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request) {
    var _a, _b, _c;
    const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== undefined ? _a : this.fallbackRequestHandler;
    if (handler === undefined) {
      (_b = this._transport) === null || _b === undefined || _b.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      return;
    }
    const abortController = new AbortController;
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const extra = {
      signal: abortController.signal,
      sessionId: (_c = this._transport) === null || _c === undefined ? undefined : _c.sessionId
    };
    Promise.resolve().then(() => handler(request, extra)).then((result) => {
      var _a2;
      if (abortController.signal.aborted) {
        return;
      }
      return (_a2 = this._transport) === null || _a2 === undefined ? undefined : _a2.send({
        result,
        jsonrpc: "2.0",
        id: request.id
      });
    }, (error) => {
      var _a2, _b2;
      if (abortController.signal.aborted) {
        return;
      }
      return (_a2 = this._transport) === null || _a2 === undefined ? undefined : _a2.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: (_b2 = error.message) !== null && _b2 !== undefined ? _b2 : "Internal error"
        }
      });
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        responseHandler(error);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const handler = this._responseHandlers.get(messageId);
    if (handler === undefined) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._progressHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    if ("result" in response) {
      handler(response);
    } else {
      const error = new McpError(response.error.code, response.error.message, response.error.data);
      handler(error);
    }
  }
  get transport() {
    return this._transport;
  }
  async close() {
    var _a;
    await ((_a = this._transport) === null || _a === undefined ? undefined : _a.close());
  }
  request(request, resultSchema, options) {
    return new Promise((resolve, reject) => {
      var _a, _b, _c, _d, _e;
      if (!this._transport) {
        reject(new Error("Not connected"));
        return;
      }
      if (((_a = this._options) === null || _a === undefined ? undefined : _a.enforceStrictCapabilities) === true) {
        this.assertCapabilityForMethod(request.method);
      }
      (_b = options === null || options === undefined ? undefined : options.signal) === null || _b === undefined || _b.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options === null || options === undefined ? undefined : options.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: { progressToken: messageId }
        };
      }
      const cancel = (reason) => {
        var _a2;
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        (_a2 = this._transport) === null || _a2 === undefined || _a2.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
        reject(reason);
      };
      this._responseHandlers.set(messageId, (response) => {
        var _a2;
        if ((_a2 = options === null || options === undefined ? undefined : options.signal) === null || _a2 === undefined ? undefined : _a2.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const result = resultSchema.parse(response.result);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      (_c = options === null || options === undefined ? undefined : options.signal) === null || _c === undefined || _c.addEventListener("abort", () => {
        var _a2;
        cancel((_a2 = options === null || options === undefined ? undefined : options.signal) === null || _a2 === undefined ? undefined : _a2.reason);
      });
      const timeout = (_d = options === null || options === undefined ? undefined : options.timeout) !== null && _d !== undefined ? _d : DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options === null || options === undefined ? undefined : options.maxTotalTimeout, timeoutHandler, (_e = options === null || options === undefined ? undefined : options.resetTimeoutOnProgress) !== null && _e !== undefined ? _e : false);
      this._transport.send(jsonrpcRequest).catch((error) => {
        this._cleanupTimeout(messageId);
        reject(error);
      });
    });
  }
  async notification(notification) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    await this._transport.send(jsonrpcNotification);
  }
  setRequestHandler(requestSchema, handler) {
    const method = requestSchema.shape.method.value;
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => Promise.resolve(handler(requestSchema.parse(request), extra)));
  }
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  setNotificationHandler(notificationSchema, handler) {
    this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
  }
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
}
function mergeCapabilities(base, additional) {
  return Object.entries(additional).reduce((acc, [key, value]) => {
    if (value && typeof value === "object") {
      acc[key] = acc[key] ? { ...acc[key], ...value } : value;
    } else {
      acc[key] = value;
    }
    return acc;
  }, { ...base });
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
class Server extends Protocol {
  constructor(_serverInfo, options) {
    var _a;
    super(options);
    this._serverInfo = _serverInfo;
    this._capabilities = (_a = options === null || options === undefined ? undefined : options.capabilities) !== null && _a !== undefined ? _a : {};
    this._instructions = options === null || options === undefined ? undefined : options.instructions;
    this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
    this.setNotificationHandler(InitializedNotificationSchema, () => {
      var _a2;
      return (_a2 = this.oninitialized) === null || _a2 === undefined ? undefined : _a2.call(this);
    });
  }
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  assertCapabilityForMethod(method) {
    var _a, _b;
    switch (method) {
      case "sampling/createMessage":
        if (!((_a = this._clientCapabilities) === null || _a === undefined ? undefined : _a.sampling)) {
          throw new Error(`Client does not support sampling (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!((_b = this._clientCapabilities) === null || _b === undefined ? undefined : _b.roots)) {
          throw new Error(`Client does not support listing roots (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        }
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        }
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        }
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Server does not support sampling (required for ${method})`);
        }
        break;
      case "logging/setLevel":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "ping":
      case "initialize":
        break;
    }
  }
  async _oninitialize(request) {
    const requestedVersion = request.params.protocolVersion;
    this._clientCapabilities = request.params.capabilities;
    this._clientVersion = request.params.clientInfo;
    return {
      protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  async createMessage(params, options) {
    return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  async sendLoggingMessage(params) {
    return this.notification({ method: "notifications/message", params });
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
}

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: undefined,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};
// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: undefined,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        jsonSchema: undefined
      }
    ]))
  };
};
// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        break;
      case "max":
        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === undefined) {
        unevaluatedProperties = undefined;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = undefined;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : undefined;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex2 = undefined;
var zodPatterns = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex2 === undefined) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ((_) => {})(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0;i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : undefined;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === undefined || propDef._def === undefined) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef instanceof ZodOptional) {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === undefined) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== undefined) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== undefined)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return;
    default:
      return ((_) => {
        return;
      })(typeName);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== undefined) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : undefined;
    }
  }
};
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};
// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? {}
  }), {}) : undefined;
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? undefined : options?.name;
  const main = parseDef(schema._def, name === undefined ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
  if (title !== undefined) {
    main.title = title;
  }
  const combined = name === undefined ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && (("anyOf" in combined) || ("oneOf" in combined) || ("allOf" in combined) || ("type" in combined) && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
// node_modules/@modelcontextprotocol/sdk/dist/esm/server/completable.js
var McpZodTypeKind;
(function(McpZodTypeKind2) {
  McpZodTypeKind2["Completable"] = "McpCompletable";
})(McpZodTypeKind || (McpZodTypeKind = {}));

class Completable extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
Completable.create = (type, params) => {
  return new Completable({
    type,
    typeName: McpZodTypeKind.Completable,
    complete: params.complete,
    ...processCreateParams2(params)
  });
};
function processCreateParams2(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
class McpServer {
  constructor(serverInfo, options) {
    this._registeredResources = {};
    this._registeredResourceTemplates = {};
    this._registeredTools = {};
    this._registeredPrompts = {};
    this._toolHandlersInitialized = false;
    this._completionHandlerInitialized = false;
    this._resourceHandlersInitialized = false;
    this._promptHandlersInitialized = false;
    this.server = new Server(serverInfo, options);
  }
  async connect(transport) {
    return await this.server.connect(transport);
  }
  async close() {
    await this.server.close();
  }
  setToolRequestHandlers() {
    if (this._toolHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListToolsRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(CallToolRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      tools: {}
    });
    this.server.setRequestHandler(ListToolsRequestSchema, () => ({
      tools: Object.entries(this._registeredTools).map(([name, tool]) => {
        return {
          name,
          description: tool.description,
          inputSchema: tool.inputSchema ? zodToJsonSchema(tool.inputSchema, {
            strictUnions: true
          }) : EMPTY_OBJECT_JSON_SCHEMA
        };
      })
    }));
    this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
      const tool = this._registeredTools[request.params.name];
      if (!tool) {
        throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);
      }
      if (tool.inputSchema) {
        const parseResult = await tool.inputSchema.safeParseAsync(request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`);
        }
        const args = parseResult.data;
        const cb = tool.callback;
        try {
          return await Promise.resolve(cb(args, extra));
        } catch (error) {
          return {
            content: [
              {
                type: "text",
                text: error instanceof Error ? error.message : String(error)
              }
            ],
            isError: true
          };
        }
      } else {
        const cb = tool.callback;
        try {
          return await Promise.resolve(cb(extra));
        } catch (error) {
          return {
            content: [
              {
                type: "text",
                text: error instanceof Error ? error.message : String(error)
              }
            ],
            isError: true
          };
        }
      }
    });
    this._toolHandlersInitialized = true;
  }
  setCompletionRequestHandler() {
    if (this._completionHandlerInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(CompleteRequestSchema.shape.method.value);
    this.server.setRequestHandler(CompleteRequestSchema, async (request) => {
      switch (request.params.ref.type) {
        case "ref/prompt":
          return this.handlePromptCompletion(request, request.params.ref);
        case "ref/resource":
          return this.handleResourceCompletion(request, request.params.ref);
        default:
          throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);
      }
    });
    this._completionHandlerInitialized = true;
  }
  async handlePromptCompletion(request, ref) {
    const prompt = this._registeredPrompts[ref.name];
    if (!prompt) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.ref.name} not found`);
    }
    if (!prompt.argsSchema) {
      return EMPTY_COMPLETION_RESULT;
    }
    const field = prompt.argsSchema.shape[request.params.argument.name];
    if (!(field instanceof Completable)) {
      return EMPTY_COMPLETION_RESULT;
    }
    const def = field._def;
    const suggestions = await def.complete(request.params.argument.value);
    return createCompletionResult(suggestions);
  }
  async handleResourceCompletion(request, ref) {
    const template = Object.values(this._registeredResourceTemplates).find((t) => t.resourceTemplate.uriTemplate.toString() === ref.uri);
    if (!template) {
      if (this._registeredResources[ref.uri]) {
        return EMPTY_COMPLETION_RESULT;
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);
    }
    const completer = template.resourceTemplate.completeCallback(request.params.argument.name);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request.params.argument.value);
    return createCompletionResult(suggestions);
  }
  setResourceRequestHandlers() {
    if (this._resourceHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListResourcesRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(ListResourceTemplatesRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(ReadResourceRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      resources: {}
    });
    this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {
      const resources = Object.entries(this._registeredResources).map(([uri, resource]) => ({
        uri,
        name: resource.name,
        ...resource.metadata
      }));
      const templateResources = [];
      for (const template of Object.values(this._registeredResourceTemplates)) {
        if (!template.resourceTemplate.listCallback) {
          continue;
        }
        const result = await template.resourceTemplate.listCallback(extra);
        for (const resource of result.resources) {
          templateResources.push({
            ...resource,
            ...template.metadata
          });
        }
      }
      return { resources: [...resources, ...templateResources] };
    });
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
      const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({
        name,
        uriTemplate: template.resourceTemplate.uriTemplate.toString(),
        ...template.metadata
      }));
      return { resourceTemplates };
    });
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
      const uri = new URL(request.params.uri);
      const resource = this._registeredResources[uri.toString()];
      if (resource) {
        return resource.readCallback(uri, extra);
      }
      for (const template of Object.values(this._registeredResourceTemplates)) {
        const variables = template.resourceTemplate.uriTemplate.match(uri.toString());
        if (variables) {
          return template.readCallback(uri, variables, extra);
        }
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);
    });
    this.setCompletionRequestHandler();
    this._resourceHandlersInitialized = true;
  }
  setPromptRequestHandlers() {
    if (this._promptHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListPromptsRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(GetPromptRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      prompts: {}
    });
    this.server.setRequestHandler(ListPromptsRequestSchema, () => ({
      prompts: Object.entries(this._registeredPrompts).map(([name, prompt]) => {
        return {
          name,
          description: prompt.description,
          arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : undefined
        };
      })
    }));
    this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {
      const prompt = this._registeredPrompts[request.params.name];
      if (!prompt) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);
      }
      if (prompt.argsSchema) {
        const parseResult = await prompt.argsSchema.safeParseAsync(request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`);
        }
        const args = parseResult.data;
        const cb = prompt.callback;
        return await Promise.resolve(cb(args, extra));
      } else {
        const cb = prompt.callback;
        return await Promise.resolve(cb(extra));
      }
    });
    this.setCompletionRequestHandler();
    this._promptHandlersInitialized = true;
  }
  resource(name, uriOrTemplate, ...rest) {
    let metadata;
    if (typeof rest[0] === "object") {
      metadata = rest.shift();
    }
    const readCallback = rest[0];
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      this._registeredResources[uriOrTemplate] = {
        name,
        metadata,
        readCallback
      };
    } else {
      if (this._registeredResourceTemplates[name]) {
        throw new Error(`Resource template ${name} is already registered`);
      }
      this._registeredResourceTemplates[name] = {
        resourceTemplate: uriOrTemplate,
        metadata,
        readCallback
      };
    }
    this.setResourceRequestHandlers();
  }
  tool(name, ...rest) {
    if (this._registeredTools[name]) {
      throw new Error(`Tool ${name} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let paramsSchema;
    if (rest.length > 1) {
      paramsSchema = rest.shift();
    }
    const cb = rest[0];
    this._registeredTools[name] = {
      description,
      inputSchema: paramsSchema === undefined ? undefined : z.object(paramsSchema),
      callback: cb
    };
    this.setToolRequestHandlers();
  }
  prompt(name, ...rest) {
    if (this._registeredPrompts[name]) {
      throw new Error(`Prompt ${name} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let argsSchema;
    if (rest.length > 1) {
      argsSchema = rest.shift();
    }
    const cb = rest[0];
    this._registeredPrompts[name] = {
      description,
      argsSchema: argsSchema === undefined ? undefined : z.object(argsSchema),
      callback: cb
    };
    this.setPromptRequestHandlers();
  }
}
var EMPTY_OBJECT_JSON_SCHEMA = {
  type: "object"
};
function promptArgumentsFromSchema(schema) {
  return Object.entries(schema.shape).map(([name, field]) => ({
    name,
    description: field.description,
    required: !field.isOptional()
  }));
}
function createCompletionResult(suggestions) {
  return {
    completion: {
      values: suggestions.slice(0, 100),
      total: suggestions.length,
      hasMore: suggestions.length > 100
    }
  };
}
var EMPTY_COMPLETION_RESULT = {
  completion: {
    values: [],
    hasMore: false
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
import process2 from "node:process";

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
class ReadBuffer {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf(`
`);
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = undefined;
  }
}
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
class StdioServerTransport {
  constructor(_stdin = process2.stdin, _stdout = process2.stdout) {
    this._stdin = _stdin;
    this._stdout = _stdout;
    this._readBuffer = new ReadBuffer;
    this._started = false;
    this._ondata = (chunk) => {
      this._readBuffer.append(chunk);
      this.processReadBuffer();
    };
    this._onerror = (error) => {
      var _a;
      (_a = this.onerror) === null || _a === undefined || _a.call(this, error);
    };
  }
  async start() {
    if (this._started) {
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    }
    this._started = true;
    this._stdin.on("data", this._ondata);
    this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    var _a, _b;
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        (_a = this.onmessage) === null || _a === undefined || _a.call(this, message);
      } catch (error) {
        (_b = this.onerror) === null || _b === undefined || _b.call(this, error);
      }
    }
  }
  async close() {
    var _a;
    this._stdin.off("data", this._ondata);
    this._stdin.off("error", this._onerror);
    const remainingDataListeners = this._stdin.listenerCount("data");
    if (remainingDataListeners === 0) {
      this._stdin.pause();
    }
    this._readBuffer.clear();
    (_a = this.onclose) === null || _a === undefined || _a.call(this);
  }
  send(message) {
    return new Promise((resolve) => {
      const json = serializeMessage(message);
      if (this._stdout.write(json)) {
        resolve();
      } else {
        this._stdout.once("drain", resolve);
      }
    });
  }
}

// node_modules/@ashgw/ts-env/dist/index.cjs
var zod = require_lib6();
function createEnv(options) {
  const { vars, prefix, skipValidation = false, disablePrefix = [], runtimeEnv: customRuntimeEnv } = options;
  const runtimeEnv = customRuntimeEnv ? { ...process.env, ...customRuntimeEnv } : { ...process.env };
  const transformedEnv = {};
  for (const key of Object.keys(vars)) {
    const shouldPrefix = prefix && !disablePrefix.includes(key);
    const envKey = shouldPrefix ? `${prefix}_${key}` : key;
    const value = runtimeEnv[envKey];
    if (value !== undefined) {
      transformedEnv[key] = value;
    }
  }
  if (skipValidation) {
    const finalEnv2 = {};
    for (const key of Object.keys(vars)) {
      const shouldPrefix = prefix && !disablePrefix.includes(key);
      const envKey = shouldPrefix ? `${prefix}_${key}` : key;
      finalEnv2[envKey] = runtimeEnv[envKey];
    }
    return finalEnv2;
  }
  const schema = zod.z.object(vars);
  const parsed = schema.safeParse(transformedEnv);
  if (!parsed.success) {
    const { fieldErrors } = parsed.error.flatten();
    const prefixedFieldErrors = Object.entries(fieldErrors).reduce((acc, [key, messages]) => {
      if (messages) {
        const shouldPrefix = prefix && !disablePrefix.includes(key);
        const prefixedKey = shouldPrefix ? `${prefix}_${key}` : key;
        acc[prefixedKey] = messages;
      }
      return acc;
    }, {});
    console.error(" Invalid environment variables:", prefixedFieldErrors);
    throw new Error("Invalid environment variables");
  }
  const finalEnv = {};
  for (const [key, value] of Object.entries(parsed.data)) {
    const shouldPrefix = prefix && !disablePrefix.includes(key);
    const envKey = shouldPrefix ? `${prefix}_${key}` : key;
    finalEnv[envKey] = value;
  }
  return finalEnv;
}
var $createEnv = createEnv;

// src/index.ts
class VaultMcpServer {
  server;
  vaultClient;
  constructor(vaultAddress, vaultToken) {
    this.server = new McpServer({
      name: "vault-mcp",
      version: "1.0.0",
      description: "MCP Server for HashiCorp Vault secret management"
    });
    this.vaultClient = import_node_vault.default({
      endpoint: vaultAddress,
      token: vaultToken
    });
    this.registerTools();
    this.registerResources();
    this.registerPrompts();
  }
  registerTools() {
    this.server.tool("create_secret", {
      path: z.string(),
      data: z.record(z.any())
    }, async ({ path, data }) => {
      const result = await this.vaultClient.write(`secret/data/${path}`, {
        data
      });
      return {
        content: [
          {
            type: "text",
            text: `Secret written at: ${path}
${JSON.stringify(result, null, 2)}`
          }
        ]
      };
    });
    this.server.tool("read_secret", {
      path: z.string()
    }, async ({ path }) => {
      const result = await this.vaultClient.read(`secret/data/${path}`);
      return {
        content: [
          {
            type: "text",
            text: `Secret read at: ${path}
${JSON.stringify(result, null, 2)}`
          }
        ]
      };
    });
    this.server.tool("delete_secret", {
      path: z.string()
    }, async ({ path }) => {
      const result = await this.vaultClient.delete(`secret/data/${path}`);
      return {
        content: [
          {
            type: "text",
            text: `Secret deleted at: ${path}
${JSON.stringify(result, null, 2)}`
          }
        ]
      };
    });
    this.server.tool("create_policy", {
      name: z.string(),
      policy: z.string()
    }, async ({ name, policy }) => {
      const result = await this.vaultClient.sys.addPolicy({ name, policy });
      return {
        content: [
          {
            type: "text",
            text: `Policy '${name}' created.
${JSON.stringify(result, null, 2)}`
          }
        ]
      };
    });
  }
  registerResources() {
    this.server.resource("vault_secrets", "vault://secrets", async () => {
      try {
        const result = await this.vaultClient.list("secret/metadata");
        return {
          contents: [
            {
              uri: "vault://secrets",
              text: JSON.stringify(result.data.keys || [])
            }
          ]
        };
      } catch (err) {
        return {
          contents: [
            {
              uri: "vault://secrets",
              text: "[]"
            }
          ]
        };
      }
    });
    this.server.resource("vault_policies", "vault://policies", async () => {
      const result = await this.vaultClient.sys.listPolicies();
      return {
        contents: [
          {
            uri: "vault://policies",
            text: JSON.stringify(result)
          }
        ]
      };
    });
  }
  registerPrompts() {
    this.server.prompt("generate_policy", {
      path: z.string(),
      capabilities: z.string()
    }, async ({ path, capabilities }) => {
      const capArray = capabilities.split(",").map((c) => c.trim());
      const policy = {
        path: {
          [path]: {
            capabilities: capArray
          }
        }
      };
      return {
        messages: [
          {
            role: "user",
            content: {
              type: "text",
              text: JSON.stringify(policy, null, 2)
            }
          }
        ]
      };
    });
  }
  async start() {
    const transport = new StdioServerTransport;
    await this.server.connect(transport);
    console.error("Vault MCP Server running via stdio");
  }
}
var src_default = VaultMcpServer;
async function main() {
  const env = $createEnv({
    vars: {
      VAULT_ADDR: z.string().url({
        message: "VAULT_ADDR must be a valid URL (e.g., http://vault.example.com:8200)"
      }),
      VAULT_TOKEN: z.string().min(3).startsWith("hvs.", {
        message: "VAULT_TOKEN must start with 'hsv.' prefix for HashiCorp Vault tokens"
      }),
      MCP_PORT: z.coerce.number().int().min(1).max(65535).optional().default(3000)
    }
  });
  try {
    const server = new VaultMcpServer(env.VAULT_ADDR, env.VAULT_TOKEN);
    await server.start();
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
}
if (import.meta.url === new URL(import.meta.resolve("./index.ts")).href) {
  main();
}
export {
  src_default as default
};
